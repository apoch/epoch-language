//
// The Epoch Language Project
// EPOCHCOMPILER Compiler Toolchain
//
// Traversal logic for handling the Abstract Syntax Tree
//
// The parser layer generates an AST, which consists of a series of
// nodes representing the parsed program. The AST contains only a
// minimal amount of semantic information; it is the responsibility
// of the Intermediate Representation layers to add semantic markup
// to the tree and generate different data structures that can be
// used by various phases of the compiler.
//
// We separate the logic of traversing the AST from the actual code
// that operates on the AST. This decoupling allows multiple different
// operations to be performed on the AST, without redundant traversal
// logic, and without necessitating the pollution of multiple operations
// crammed into a single code path.
//
// This decoupling is accomplished using functors which are invoked
// on the entry into each AST node, and the exit from that node. The
// tree is traversed depth-first with preorder semantics. This enables
// the callback code to change its state based on its location in the
// AST, and thereby interpret different node types in various contexts.
// This is especially useful for generic nodes like "identifiers" which
// may appear in many different contexts.
//

#pragma once


// Dependencies
#include "Compiler/Abstract Syntax Tree/Program.h"
#include "Compiler/Abstract Syntax Tree/CodeBlock.h"
#include "Compiler/Abstract Syntax Tree/AnyStatement.h"
#include "Compiler/Abstract Syntax Tree/Identifiers.h"


namespace ASTTraverse
{

	//
	// Internal implementation details
	//
	namespace
	{
		//
		// SFINAE helper for determining if a given type fits the interface
		// of a boost variant. This is admittedly a very kludgy kind of thing
		// to do, but it's split into a separate template metaprogramming
		// helper so that we can improve on it later with minimal effects on
		// the code that relies on this concept.
		//
		// A complete treatment of how this technique works can be found here:
		// http://code.google.com/p/scribblings-by-apoch/wiki/MetaProgrammingEnableIfConvertible
		//
		// Instead of detecting a conversion between types, however, this code
		// detects the presence of a typedef named "types" in the target class.
		//
		template <typename T>
		struct IsVariantType
		{
			typedef char (&yes)[1];
			typedef char (&no)[2];

			template <typename U>
			static yes TestDummy(typename U::types*);

			template <typename U>
			static no TestDummy(...);

			enum PerformCheck
			{
				CheckResult = (sizeof(TestDummy<T>(NULL)) == sizeof(yes))
			};
		};

		//
		// Dummy helper for making the EnableIf stuff work
		//
		struct EnableDummy
		{ };

		//
		// Enablement helper; provides a typedef if the conversion
		// parameter passed in is true, and omits the typedef if
		// that parameter is false
		//
		template <bool>
		struct EnableIfVariantHelper;

		template <>
		struct EnableIfVariantHelper<true>
		{
			typedef EnableDummy type;
		};

		template <>
		struct EnableIfVariantHelper<false>
		{ };

		//
		// Template metafunction for checking if a type is a boost::variant
		//
		template <typename T>
		struct EnableIfVariant : public EnableIfVariantHelper<IsVariantType<T>::CheckResult>
		{ };
	}

	//
	// Special dummy markers used for indicating to the callback
	// wrapper code what kind of AST nodes to expect. These are
	// useful for differentiating between similar branches of the
	// AST that can't necessarily be recognized just by looking
	// at the nodes themselves. This enables context-sensitive
	// handling of the AST branches based on more than just the
	// node types themselves.
	//
	namespace Markers
	{
		struct FunctionReturnExpression { };
	}

	//
	// The actual AST traveral logic
	//
	// This struct completely encapsulates the process of walking
	// through the AST as generated by the parser layer. By using
	// this approach we protect AST examination/manipulation code
	// from the gory details of how the AST is really structured.
	//
	// We also insulate the traversal itself from the details of
	// what various operations on the AST actually want to do.
	//
	struct Traverser
	{
		//
		// Traverse a node of otherwise unknown type
		//
		// Generally used only for leaf nodes in the AST. Nodes that
		// have children should receive their own overloads so that
		// those child nodes can be traversed correctly. Traversal of
		// child nodes should never be left to the callback functors.
		//
		// Note that the Evil Ellipsis is used here in order to demote
		// this overload to the lowest priority class as per C++'s
		// overload resolution rules. This ensures that the variant
		// handling overload (see below) is tried first, and resolves
		// ambiguity in the presence of other potential overloads.
		//
		template <typename EntryActionT, typename ExitActionT, typename NodeT>
		void Do(EntryActionT& entryaction, NodeT& node, ExitActionT& exitaction, ...)
		{
			entryaction(node);
			exitaction(node);
		}

		//
		// Traverse a node wrapped in a variant
		//
		// Makes use of the helper VariantVisitor (see below) to do
		// the actual unwrapping. Uses some template metaprogramming
		// to do compile-time reflection on the passed node type, in
		// an effort to ensure that only boost::variant objects are
		// handed to this overload. See the notes on EnableIfVariant
		// above for details.
		//
		template <typename EntryActionT, typename ExitActionT, typename NodeT>
		void Do(EntryActionT& entryaction, NodeT& node, ExitActionT& exitaction, typename EnableIfVariant<NodeT>::type& = EnableDummy())
		{
			VariantVisitor<EntryActionT, ExitActionT> visitor(*this, entryaction, exitaction);
			boost::apply_visitor(visitor, node);			
		}

		//
		// Traverse a deferred-construction node
		//
		// Unwraps the node content from the deferred-construction
		// wrapper and traverses the content using the appropriate
		// overload of Do(). See the notes on the Deferred<> class
		// for more details.
		//
		template <typename EntryActionT, typename ExitActionT, typename T, typename PtrT>
		void Do(EntryActionT& entryaction, AST::Deferred<T, PtrT>& deferred, ExitActionT& exitaction)
		{
			Do(entryaction, *deferred.Content, exitaction);
		}

		//
		// Traverse a deferred-construction container
		//
		// Like deferred-construction nodes, containers are simply
		// wrapped to minimize copies and dynamic allocation while
		// parsing. This overload unwraps the container and passes
		// it off to the appropriate Do() overload.
		//
		template <typename EntryActionT, typename ExitActionT, typename T, typename PtrT>
		void Do(EntryActionT& entryaction, AST::DeferredContainer<T, PtrT>& deferred, ExitActionT& exitaction)
		{
			Do(entryaction, deferred.Content->Container, exitaction);
		}

		//
		// Traverse a container of nodes
		//
		// Often, AST nodes are held in a container to represent a
		// many-to-one child/parent relationship in the tree. This
		// overload recursively traverses each child node in turn,
		// providing depth-first pre-order traversal semantics.
		//
		template <typename EntryActionT, typename ExitActionT, typename T, typename AllocT>
		void Do(EntryActionT& entryaction, std::vector<T, AllocT>& nodes, ExitActionT& exitaction)
		{
			for(std::vector<T, AllocT>::iterator iter = nodes.begin(); iter != nodes.end(); ++iter)
				Do(entryaction, *iter, exitaction);
		}

		//
		// Traverse an Epoch statement
		//
		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::Statement& statement, ExitActionT& exitaction)
		{
			entryaction(statement);
			Do(entryaction, statement.Params, exitaction);
			exitaction(statement);
		}

		//
		// Traverse an Epoch expression
		//
		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::Expression& expression, ExitActionT& exitaction)
		{
			entryaction(expression);
			Do(entryaction, expression.First, exitaction);
			Do(entryaction, expression.Remaining, exitaction);
			exitaction(expression);
		}

		//
		// Traverse a component of an Epoch expression
		//
		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::ExpressionComponent& component, ExitActionT& exitaction)
		{
			entryaction(component);
			Do(entryaction, component.UnaryPrefixes, exitaction);
			Do(entryaction, component.Component.Content->V, exitaction);
			exitaction(component);
		}

		//
		// Traverse a fragment of an Epoch expression
		//
		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::ExpressionFragment& fragment, ExitActionT& exitaction)
		{
			entryaction(fragment);
			Do(entryaction, fragment.Component.Content->Component.Content->V, exitaction);
			exitaction(fragment);
		}

		//
		// Traverse an Epoch assignment
		//
		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::Assignment& assignment, ExitActionT& exitaction)
		{
			entryaction(assignment);
			Do(entryaction, assignment.RHS, exitaction);
			exitaction(assignment);
		}

		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::SimpleAssignment& assignment, ExitActionT& exitaction)
		{
			entryaction(assignment);
			Do(entryaction, assignment.RHS, exitaction);
			exitaction(assignment);
		}

		//
		// Traverse a block of code
		//
		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::CodeBlock& codeblock, ExitActionT& exitaction)
		{
			entryaction(codeblock);
			Do(entryaction, codeblock.Entries, exitaction);
			exitaction(codeblock);
		}

		//
		// Traverse an entity invocation, including any chained entities
		//
		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::Entity& entity, ExitActionT& exitaction)
		{
			entryaction(entity);
			Do(entryaction, entity.Parameters, exitaction);
			Do(entryaction, entity.Code, exitaction);
			Do(entryaction, entity.Chain, exitaction);
			exitaction(entity);
		}

		//
		// Traverse a postfix entity invocation
		//
		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::PostfixEntity& entity, ExitActionT& exitaction)
		{
			entryaction(entity);
			Do(entryaction, entity.Parameters, exitaction);
			Do(entryaction, entity.Code, exitaction);
			Do(entryaction, entity.PostfixIdentifier, exitaction);
			Do(entryaction, entity.PostfixParameters, exitaction);
			exitaction(entity);
		}

		//
		// Traverse a chained entity invocation
		//
		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::ChainedEntity& entity, ExitActionT& exitaction)
		{
			entryaction(entity);
			Do(entryaction, entity.Parameters, exitaction);
			Do(entryaction, entity.Code, exitaction);
			exitaction(entity);
		}

		//
		// Traverse a function definition
		//
		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::Function& function, ExitActionT& exitaction)
		{
			entryaction(function);
			Do(entryaction, function.Parameters, exitaction);
			entryaction(Markers::FunctionReturnExpression());
			Do(entryaction, function.Return, exitaction);
			exitaction(Markers::FunctionReturnExpression());
			Do(entryaction, function.Code, exitaction);
			exitaction(function);
		}

		//
		// Traverse a structure definition
		//
		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::Structure& structure, ExitActionT& exitaction)
		{
			entryaction(structure);
			Do(entryaction, structure.Members, exitaction);
			exitaction(structure);
		}

		//
		// Traverse a complete program from the AST root node downwards
		//
		template <typename EntryActionT, typename ExitActionT>
		void Do(EntryActionT& entryaction, AST::Program& program, ExitActionT& exitaction)
		{
			entryaction(program);
			Do(entryaction, program.MetaEntities, exitaction);
			exitaction(program);
		}

	private:
		//
		// Helper visitor for unwrapping boost::variants
		//
		// Simply re-invokes the traverser with the original typed contents
		// of a variant. Invocation is templated so that any type contained
		// within the variant will be passed back to the traverser cleanly.
		//
		template <typename EntryActionT, typename ExitActionT>
		struct VariantVisitor : public boost::static_visitor<>
		{
			VariantVisitor(Traverser& traverser, EntryActionT& entry, ExitActionT& exit)
				: self(traverser),
				  Entry(entry),
				  Exit(exit)
			{ }

			template <typename T>
			void operator () (T& value)
			{
				self.Do(Entry, value, Exit);
			}

		private:
			Traverser& self;
			EntryActionT& Entry;
			ExitActionT& Exit;
		};
	};


	template <typename TraverserT>
	void DoTraversal(TraverserT& tr, AST::Program& program)
	{
		ASTTraverse::Traverser traverse;
		traverse.Do(tr.Entry, program, tr.Exit);
	}

}

