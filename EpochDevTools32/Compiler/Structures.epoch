

FindStructureAndAddMember : list<StructureDefinition> ref structures, integer structurename, integer structuretype, StructureMember ref member
{
	if(structures.value.Name == structurename)
	{
		AppendStructureMember(structures.value.Members, structures.value.Members.next, member)
		structures.value.MemberCount = structures.value.MemberCount + 1
	}
	else
	{
		FindStructureAndAddMember(structures.next, structurename, structuretype, member)
	}
}

FindStructureAndAddMember : nothing, integer structurename, integer structuretype, StructureMember ref member
{
	list<StructureMember> members = member, nothing
	StructureDefinition def = structurename, structuretype, 0, 0, 0, members, 1, GetPooledString(structurename), false

	prepend<StructureDefinition>(Structures, def)
	BinaryTreeCreateOrInsert<StructureDefinition>(GlobalRootNamespace.Structures, structurename, def)
}

AppendStructureMember : list<StructureMember> ref members, list<StructureMember> ref tail, StructureMember ref member
{
	AppendStructureMember(tail, tail.next, member)
}

AppendStructureMember : list<StructureMember> ref members, nothing, StructureMember ref member
{
	list<StructureMember> newtail = member, nothing
	members.next = newtail
}


FindStructureAndAddMemberParam : list<StructureDefinition> ref structures, integer structurename, integer structuretype, integer membername, Parameter ref param
{
	if(structures.value.Name == structurename)
	{
		AppendStructureMemberParam(structures.value.Members, membername, param)
	}
	else
	{
		FindStructureAndAddMemberParam(structures.next, structurename, structuretype, membername, param)
	}
}

AppendStructureMemberParam : list<StructureMember> ref members, integer membername, Parameter ref param
{
	boolean match = CheckMemberForAddingParam(members.value, membername, param)
	if(!match)
	{
		AppendStructureMemberParam(members.next, membername, param)
	}
}

CheckMemberForAddingParam : StructureMemberVariable ref member, integer membername, Parameter ref param -> false

CheckMemberForAddingParam : StructureMemberFunctionRef ref member, integer membername, Parameter ref param -> boolean ret = false
{
	if(member.Name == membername)
	{
		AppendParameter(member.Signature.Parameters, param)
		ret = true
	}
}




FindStructureAndSetConstructors : integer structurename, integer constructorname, integer anonname, integer copyname
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(GlobalRootNamespace.Structures.RootNode, structurename, wrap)
	assertmsg(found, "Internal error: constructors cannot be set on non-existent structure")

	SetConstructors(wrap, constructorname, anonname, copyname)
}

SetConstructors : StructureDefinition ref struct, integer constructorname, integer anonname, integer copyname
{
	struct.ConstructorName = constructorname
	struct.AnonConstructorName = anonname
	struct.CopyConstructorName = copyname
}



GetNameOfStructureByType : integer typeid -> integer name = 0
{
	name = GetNameOfStructureByType(Structures, typeid)
}

GetNameOfStructureByType : list<StructureDefinition> ref structures, integer typeid -> integer name = 0
{
	if(structures.value.Type == typeid)
	{
		name = structures.value.Name
	}
	else
	{
		name = GetNameOfStructureByType(structures.next, typeid)
	}
}

GetNameOfStructureByType : nothing, integer typeid -> integer name = 0


GetStructureMemberType : integer structurename, integer membername -> integer rtype = 0
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(GlobalRootNamespace.Structures.RootNode, structurename, wrap)
	if(found)
	{
		rtype = GetMemberType(wrap, membername)
	}
	else
	{
		print("Bogus structure")
		print(GetPooledString(structurename))
		assert(false)
	}
}


GetMemberType : StructureDefinition ref struct, integer membername -> integer ty = GetMemberType(struct.Members, membername)


GetMemberType : list<StructureMember> ref members, integer membername -> integer rtype = 0
{
	if(GetMemberName(members.value) == membername)
	{
		rtype = GetMemberTypeDecompose(members.value)
		assertmsg(rtype != 0, "Member has no type; cannot return from GetMemberType")
	}
	else
	{
		rtype = GetMemberType(members.next, membername)
	}
}

GetMemberType : nothing, integer membername -> integer rtype = 0
{
	print("Bogus structure member!")
	print(GetPooledString(membername))
}


GetStructureMemberIndex : integer structurename, integer membername -> integer index = 0
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(GlobalRootNamespace.Structures.RootNode, structurename, wrap)
	assert(found)
	
	GetStructureMemberIndexInternal(wrap, membername, index)
}

GetStructureMemberIndexInternal : StructureDefinition ref struct, integer membername, integer ref index
{
	GetStructureMemberIndexInternal(struct.Members, membername, index)
}

GetStructureMemberIndexInternal : list<StructureMember> ref members, integer membername, integer ref index
{
	integer thisname = GetMemberName(members.value)
	if(thisname != membername)
	{
		if(thisname != 0)
		{
			++index
		}
		
		GetStructureMemberIndexInternal(members.next, membername, index)
	}
}

GetStructureMemberIndexInternal : nothing, integer membername, integer ref index
{
	index = -1
}


GetMemberTypeDecompose : StructureMemberVariable ref memvar -> integer rtype = memvar.Type

GetMemberTypeDecompose : StructureMemberFunctionRef ref member -> integer rtype = FindOrCreateFunctionSignatureType(member.Signature)


GetMemberName : StructureMemberVariable ref memvar -> integer name = memvar.Name

GetMemberName : StructureMemberFunctionRef ref member -> integer name = member.Name


GetStructureTypeByName : integer name -> integer typeid = 0
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(GlobalRootNamespace.Structures.RootNode, name, wrap)

	if(found)
	{
		typeid = UnwrapStructureType(wrap)
	}
}

UnwrapStructureType : StructureDefinition ref struct -> integer ty = struct.Type



ParseStructDependencies : list<StructureMember> ref members, simplelist<integer> ref out
{
	integer dependency = GetMemberDependency(members.value)
	if(dependency != 0)
	{		
		if(IsStructureType(dependency))
		{
			//ParseStructDependenciesDeep(GetNameOfType(dependency), out)
			simpleprepend<integer>(out, MakeNonReferenceType(dependency))
		}
	}

	ParseStructDependencies(members.next, out)
}

ParseStructDependencies : nothing, simplelist<integer> ref out


ParseStructDependencies : StructureDefinition ref struct, simplelist<integer> ref out
{
	ParseStructDependencies(struct.Members, out)
}


ParseStructDependenciesDeep : integer name, simplelist<integer> ref out
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(GlobalRootNamespace.Structures.RootNode, name, wrap)
	assertmsg(found, "Error in structure dependency graph, missing a structure!")
	
	ParseStructDependencies(wrap, out)
}


GetMemberDependency : StructureMemberVariable ref var -> integer dep = 0
{
	if(var.Name != 0)
	{
		if(IsStructureType(var.Type))
		{
			dep = var.Type
		}
	}
}

GetMemberDependency : StructureMemberFunctionRef ref member -> 0


MissingDependency : simplelist<integer> ref dependencies, simplelist<integer> ref processed -> integer missing = 0
{
	// TODO - clean up this horrible code
	if(dependencies.value != 0)
	{
		if(listcontains(processed, dependencies.value))
		{
			missing = MissingDependency(dependencies.next, processed)
		}
		else
		{
			missing = dependencies.value
		}
	}
	else
	{
		missing = MissingDependency(dependencies.next, processed)
	}
}

MissingDependency : nothing, simplelist<integer> ref processed -> 0


ConstructorMatchesParameterTypes : list<StructureDefinition> ref structures, integer ctorname, simplelist<integer> ref types, boolean ref matchesctor -> boolean match = false
{
	if(structures.value.ConstructorName == ctorname)
	{
		matchesctor = true
		if(types.value != 0x01000000)		// identifier type signature
		{
			return()
		}

		match = CheckMemberTypes(structures.value.Members, types.next)
	}
	elseif(structures.value.AnonConstructorName == ctorname)
	{
		matchesctor = true
		match = CheckMemberTypes(structures.value.Members, types)
	}
	elseif(structures.value.CopyConstructorName == ctorname)
	{
		matchesctor = true
		if(types.value != 0x01000000)		// identifier type signature
		{
			return()
		}

		match = CheckCopyType(types.next, MakeReferenceType(structures.value.Type))
	}
	else
	{
		match = ConstructorMatchesParameterTypes(structures.next, ctorname, types, matchesctor)
	}
}

ConstructorMatchesParameterTypes : nothing, integer ctorname, simplelist<integer> ref types, boolean ref matchesctor -> false


GatherAllPossibleParamTypesForConstructor : list<StructureDefinition> ref structures, integer funcname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo -> boolean found = false
{
	if(structures.value.ConstructorName == funcname)
	{
		integer membercount = structures.value.MemberCount
		if(numparams == (membercount + 1))
		{
			simpleprepend<integer>(outinfo.value.Types, 0x01000000)		// Identifier type signature
			ExtractAllMemberTypes(structures.value.Members, outinfo.next)
			found = true
		}

		if(numparams == membercount)
		{
			ExtractAllMemberTypes(structures.value.Members, outinfo)
			found = true
		}
		
		if(numparams == 2)
		{
			AddTypeToParamTypeList(outinfo, 0x01000000)			// Identifier type signature
			AddTypeToParamTypeList(outinfo.next, MakeReferenceType(structures.value.Type))
			found = true
		}
	}
	else
	{
		found = GatherAllPossibleParamTypesForConstructor(structures.next, funcname, numparams, toplevel, outinfo)
	}
}

GatherAllPossibleParamTypesForConstructor : nothing, integer funcname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo -> false


FindConstructorAndAddParameterTypes : list<StructureDefinition> ref structures, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types -> boolean hit = false
{
	integer membercount = structures.value.MemberCount

	if((structures.value.ConstructorName == funcname) && (paramcount == membercount + 1))
	{
		if(paramindex == 0)
		{
			simpleprepend<integer>(types, 0x01000000)	// identifier type signature
		}
		else
		{
			FindMemberAndAddParameterTypes(structures.value.Members, paramindex - 1, types)
		}
		hit = true
	}
	elseif((structures.value.AnonConstructorName == funcname) && (paramcount == membercount))
	{
		FindMemberAndAddParameterTypes(structures.value.Members, paramindex, types)
		hit = true
	}
	elseif((toplevel) && (structures.value.CopyConstructorName == funcname) && (paramcount == 2))
	{
		if(paramindex == 0)
		{
			simpleprepend<integer>(types, 0x01000000)	// identifier type signature
		}
		elseif(paramindex == 1)
		{
			simpleprepend<integer>(types, MakeReferenceType(structures.value.Type))
		}
		hit = true
	}
	else
	{
		hit = FindConstructorAndAddParameterTypes(structures.next, funcname, paramindex, paramcount, toplevel, types)
	}
}

FindConstructorAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types -> false


FindMemberAndAddParameterTypes : list<StructureMember> ref members, integer paramindex, simplelist<integer> ref types
{
	if(paramindex == 0)
	{
		AddParameterTypesForMember(members.value, types)
	}
	else
	{
		FindMemberAndAddParameterTypes(members.next, paramindex - 1, types)
	}
}

FindMemberAndAddParameterTypes : nothing, integer paramindex, simplelist<integer> ref types
{
	print("Too many arguments to constructor")
	assert(false)
}


AddParameterTypesForMember : StructureMemberVariable ref memvar, simplelist<integer> ref types
{
	simpleprepend<integer>(types, memvar.Type)
}

AddParameterTypesForMember : StructureMemberFunctionRef ref memfunc, simplelist<integer> ref types
{
	simpleprepend<integer>(types, GetMemberTypeDecompose(memfunc))
}


GetConstructorName : list<StructureDefinition> ref structures, integer typeid -> integer name = 0
{
	if(structures.value.Type == typeid)
	{
		name = structures.value.ConstructorName
	}
	else
	{
		name = GetConstructorName(structures.next, typeid)
	}
}


StructureConstructorExists : list<StructureDefinition> ref structures, integer ctorname -> boolean exists = false
{
	if(structures.value.ConstructorName == ctorname)
	{
		exists = true
	}
	elseif(structures.value.CopyConstructorName == ctorname)
	{
		exists = true
	}
	elseif(structures.value.AnonConstructorName == ctorname)
	{
		exists = true
	}
	else
	{
		exists = StructureConstructorExists(structures.next, ctorname)
	}
}

StructureConstructorExists : nothing, integer ctorname -> false



IsMemberReferenceType : StructureMemberVariable ref memvar -> boolean isref = IsReferenceType(memvar.Type)
IsMemberReferenceType : StructureMemberFunctionRef ref memfunc -> false


GetStructureByAnonConstructorName : nothing, integer name -> 0

GetStructureByAnonConstructorName : list<StructureDefinition> ref structures, integer name -> integer typeid = 0
{
	if(structures.value.AnonConstructorName == name)
	{
		typeid = structures.value.Type
	}
	else
	{
		typeid = GetStructureByAnonConstructorName(structures.next, name)
	}
}


PopMember : list<StructureMember> ref members, list<StructureMember> ref tail
{
	members = tail
}


ExtractAllMemberTypes : list<StructureMember> ref members, list<ParameterTypeList> ref outinfo
{
	simpleprepend<integer>(outinfo.value.Types, GetMemberTypeDecompose(members.value))
	ExtractAllMemberTypes(members.next, outinfo.next)
}

ExtractAllMemberTypes : nothing, nothing


ComputeStructureSize : integer typeid -> integer size = 0
{
	integer structurename = GetNameOfType(typeid)
	
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(GlobalRootNamespace.Structures.RootNode, structurename, wrap)
	assert(found)

	ComputeStructureMemberSizes(wrap, size)
}

ComputeStructureMemberSizes : StructureDefinition ref structuredef, integer ref size
{
	ComputeStructureMemberSizes(structuredef.Members, size)
}

ComputeStructureMemberSizes : list<StructureMember> ref members, integer ref size
{
	size = size + GetTypeSize(GetMemberTypeDecompose(members.value))
	ComputeStructureMemberSizes(members.next, size)
}

ComputeStructureMemberSizes : nothing, integer ref size

