
// The Epoch Language Project
// Epoch Development Tools - Compiler Core
//
// LLVM.EPOCH
// Link between Epoch compiler and LLVM bindings
//
// This module contains the logic for invoking the LLVM
// bindings in EpochLLVM.DLL. These APIs are configured
// to allow Epoch code to generate LLVM bitcode, invoke
// optimization passes, and of course emit machine code
// for compiled binaries.
//


type LLVMContextHandle : integer
type LLVMFunctionRef : integer
type LLVMFunctionType : integer
type LLVMType : integer
type LLVMBasicBlock : integer
type LLVMGlobalVar : integer
type LLVMAlloca : integer
type LLVMGEP : integer


structure LLVMBuildContext :
	LLVMContextHandle             Context,
	LLVMFunctionRef               EmittingFunction,
	BinaryTreeRoot<LLVMAlloca>    LocalVariables,
	BinaryTreeRoot<LLVMGlobalVar> GlobalVariables,
	LLVMBasicBlock			      ExitBlock




EpochLLVMInitialize : 																								[external("EpochLLVM.dll", "EpochLLVMInitialize")]

EpochLLVMContextCreate : -> LLVMContextHandle ret = 0 																[external("EpochLLVM.dll", "EpochLLVMContextCreate")]
EpochLLVMContextDestroy : LLVMContextHandle handle																	[external("EpochLLVM.dll", "EpochLLVMContextDestroy")]

EpochLLVMFunctionTypePush : LLVMContextHandle context																[external("EpochLLVM.dll", "EpochLLVMFunctionTypePush")]
EpochLLVMFunctionTypeCreate : LLVMContextHandle context, LLVMType rettype -> LLVMFunctionType ret = 0				[external("EpochLLVM.dll", "EpochLLVMFunctionTypeCreate")]

EpochLLVMFunctionCreate :
	LLVMContextHandle handle,
	string funcname,
	LLVMFunctionType functype
  ->
	LLVMFunctionRef ret = 0
  [external("EpochLLVM.dll", "EpochLLVMFunctionCreate")]

// TODO - this should return LLVMGlobalVar
EpochLLVMFunctionCreateThunk : LLVMContextHandle context, string name, LLVMFunctionType ty -> integer v = 0			[external("EpochLLVM.dll", "EpochLLVMFunctionCreateThunk")]

EpochLLVMFunctionQueueParamType : LLVMContextHandle context, LLVMType t, string name								[external("EpochLLVM.dll", "EpochLLVMFunctionQueueParamType")]

EpochLLVMFunctionFinalize : LLVMContextHandle context																[external("EpochLLVM.dll", "EpochLLVMFunctionFinalize")]
EpochLLVMFunctionSetEntry : LLVMContextHandle context, LLVMFunctionRef func											[external("EpochLLVM.dll", "EpochLLVMFunctionSetEntry")]


EpochLLVMStructureQueueMemberType : LLVMContextHandle context, LLVMType t											[external("EpochLLVM.dll", "EpochLLVMStructureQueueMemberType")]
EpochLLVMStructureTypeCreate : LLVMContextHandle context, string structurename -> LLVMType t = 0					[external("EpochLLVM.dll", "EpochLLVMStructureTypeCreate")]

EpochLLVMSumTypeCreate : LLVMContextHandle context, string name, integer width -> LLVMType t = 0					[external("EpochLLVM.dll", "EpochLLVMSumTypeCreate")]


EpochLLVMTypeGetBoolean : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetBoolean")]
EpochLLVMTypeGetInteger : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetInteger")]
EpochLLVMTypeGetInteger16 : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetInteger16")]
EpochLLVMTypeGetInteger64 : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetInteger64")]
EpochLLVMTypeGetPointerTo : LLVMContextHandle context, LLVMType raw -> LLVMType t = 0								[external("EpochLLVM.dll", "EpochLLVMTypeGetPointerTo")]
EpochLLVMTypeGetPointerTo : LLVMContextHandle context, LLVMFunctionType raw -> LLVMType t = 0						[external("EpochLLVM.dll", "EpochLLVMTypeGetPointerTo")]
EpochLLVMTypeGetReal : LLVMContextHandle context -> LLVMType t = 0													[external("EpochLLVM.dll", "EpochLLVMTypeGetReal")]
EpochLLVMTypeGetString : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetString")]
EpochLLVMTypeGetVoid : LLVMContextHandle context -> LLVMType t = 0													[external("EpochLLVM.dll", "EpochLLVMTypeGetVoid")]
EpochLLVMTypeGetBuffer : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetBuffer")]
EpochLLVMTypeGetArrayOfType : LLVMContextHandle context, LLVMType elementtype, integer arity -> LLVMType t = 0		[external("EpochLLVM.dll", "EpochLLVMTypeGetArrayOfType")]

EpochLLVMPrepareBinaryObject : LLVMContextHandle handle																[external("EpochLLVM.dll", "EpochLLVMPrepareBinaryObject")]
EpochLLVMEmitBinaryObject : LLVMContextHandle handle, buffer ref outbuffer, integer maxsize, integer entrypointaddress, integer gcaddress -> integer written = 0 	[external("EpochLLVM.dll", "EpochLLVMEmitBinaryObject")]

EpochLLVMRelocateBuffers : LLVMContextHandle handle, integer offsetxdata, integer offsettext						[external("EpochLLVM.dll", "EpochLLVMRelocateBuffers")]

EpochLLVMSetThunkCallback : LLVMContextHandle handle, (func : string -> integer)                                    [external("EpochLLVM.dll", "EpochLLVMSetThunkCallback")]
EpochLLVMSetStringCallback : LLVMContextHandle handle, (func : integer -> integer)									[external("EpochLLVM.dll", "EpochLLVMSetStringCallback")]


EpochLLVMGetCurrentBasicBlock : LLVMContextHandle handle -> LLVMBasicBlock ret = 0									[external("EpochLLVM.dll", "EpochLLVMGetCurrentBasicBlock")]
EpochLLVMSetCurrentBasicBlock : LLVMContextHandle handle, LLVMBasicBlock block										[external("EpochLLVM.dll", "EpochLLVMSetCurrentBasicBlock")]


EpochLLVMCodeCreateBasicBlock :
	LLVMContextHandle handle,
	LLVMFunctionRef func,
	boolean setinsertpoint
  ->
	LLVMBasicBlock ret = 0
  [external("EpochLLVM.dll", "EpochLLVMCodeCreateBasicBlock")]
    
  
EpochLLVMCodeCreateAlloca : LLVMContextHandle handle, LLVMType vartype, string varname, integer origin -> LLVMAlloca ret = 0		[external("EpochLLVM.dll", "EpochLLVMCodeCreateAlloca")]
EpochLLVMCodeCreateBranch : LLVMContextHandle handle, LLVMBasicBlock target, boolean setinsertpoint 				[external("EpochLLVM.dll", "EpochLLVMCodeCreateBranch")]
EpochLLVMCodeCreateCall : LLVMContextHandle handle, LLVMFunctionRef target -> integer ret = 0						[external("EpochLLVM.dll", "EpochLLVMCodeCreateCall")]
EpochLLVMCodeCreateCallIndirect : LLVMContextHandle handle, LLVMAlloca alloca -> integer ret = 0					[external("EpochLLVM.dll", "EpochLLVMCodeCreateCallIndirect")]
EpochLLVMCodeCreateCallThunk : LLVMContextHandle handle, integer target -> integer ret = 0							[external("EpochLLVM.dll", "EpochLLVMCodeCreateCallThunk")]
EpochLLVMCodeCreateCast : LLVMContextHandle context, LLVMType targettype											[external("EpochLLVM.dll", "EpochLLVMCodeCreateCast")]
EpochLLVMCodeCreateCondBranch : LLVMContextHandle handle, integer cond, LLVMBasicBlock tt, LLVMBasicBlock ft		[external("EpochLLVM.dll", "EpochLLVMCodeCreateCondBranch")]
EpochLLVMCodeCreateGEP : LLVMContextHandle handle, integer index -> LLVMGEP ret = 0									[external("EpochLLVM.dll", "EpochLLVMCodeCreateGEP")]
EpochLLVMCodeCreateGlobal : LLVMContextHandle context, LLVMType targettype, string varname -> LLVMGlobalVar ret = 0 [external("EpochLLVM.dll", "EpochLLVMCodeCreateGlobal")]
EpochLLVMCodeCreateRead : LLVMContextHandle handle, LLVMAlloca alloca												[external("EpochLLVM.dll", "EpochLLVMCodeCreateRead")]
EpochLLVMCodeCreateReadArray : LLVMContextHandle handle, LLVMAlloca alloca -> LLVMGEP ret = 0						[external("EpochLLVM.dll", "EpochLLVMCodeCreateReadArray")]
EpochLLVMCodeCreateReadParam : LLVMContextHandle handle, integer index												[external("EpochLLVM.dll", "EpochLLVMCodeCreateReadParam")]
EpochLLVMCodeCreateReadStructure : LLVMContextHandle handle, LLVMGEP gep											[external("EpochLLVM.dll", "EpochLLVMCodeCreateReadStructure")]
EpochLLVMCodeCreateRet : LLVMContextHandle handle																	[external("EpochLLVM.dll", "EpochLLVMCodeCreateRet")]
EpochLLVMCodeCreateRetVoid : LLVMContextHandle handle																[external("EpochLLVM.dll", "EpochLLVMCodeCreateRetVoid")]
EpochLLVMCodeCreateWrite : LLVMContextHandle handle, LLVMAlloca alloca												[external("EpochLLVM.dll", "EpochLLVMCodeCreateWrite")]
EpochLLVMCodeCreateWriteGlobal : LLVMContextHandle handle, LLVMGlobalVar global										[external("EpochLLVM.dll", "EpochLLVMCodeCreateWriteGlobal")]
EpochLLVMCodeCreateWriteIndirect : LLVMContextHandle handle, LLVMAlloca alloca										[external("EpochLLVM.dll", "EpochLLVMCodeCreateWriteIndirect")]
EpochLLVMCodeCreateWriteParam : LLVMContextHandle handle, integer index												[external("EpochLLVM.dll", "EpochLLVMCodeCreateWriteParam")]
EpochLLVMCodeCreateWriteStructure : LLVMContextHandle handle, LLVMGEP gep											[external("EpochLLVM.dll", "EpochLLVMCodeCreateWriteStructure")]
EpochLLVMCodeCreateWriteStructurePop : LLVMContextHandle handle														[external("EpochLLVM.dll", "EpochLLVMCodeCreateWriteStructurePop")]
EpochLLVMCodeCreateWriteStructurePopSumType : LLVMContextHandle handle												[external("EpochLLVM.dll", "EpochLLVMCodeCreateWriteStructurePopSumType")]

EpochLLVMCodeCreateDereference : LLVMContextHandle handle															[external("EpochLLVM.dll", "EpochLLVMCodeCreateDereference")]

EpochLLVMCodeStatementFinalize : LLVMContextHandle handle, integer line, integer column								[external("EpochLLVM.dll", "EpochLLVMCodeStatementFinalize")]
EpochLLVMCodeTagDebugLocation : LLVMContextHandle handle, integer instr, integer line, integer column				[external("EpochLLVM.dll", "EpochLLVMCodeTagDebugLocation")]

EpochLLVMCodeOperatorBooleanNot : LLVMContextHandle context															[external("EpochLLVM.dll", "EpochLLVMCodeOperatorBooleanNot")]
EpochLLVMCodeOperatorBooleanAnd : LLVMContextHandle context															[external("EpochLLVM.dll", "EpochLLVMCodeOperatorBooleanAnd")]
EpochLLVMCodeOperatorIntegerBitwiseAnd : LLVMContextHandle context													[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerBitwiseAnd")]
EpochLLVMCodeOperatorIntegerEquals : LLVMContextHandle context														[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerEquals")]
EpochLLVMCodeOperatorIntegerNotEquals : LLVMContextHandle context													[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerNotEquals")]
EpochLLVMCodeOperatorIntegerGreaterThan : LLVMContextHandle context													[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerGreaterThan")]
EpochLLVMCodeOperatorIntegerLessThan : LLVMContextHandle context													[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerLessThan")]
EpochLLVMCodeOperatorIntegerPlus : LLVMContextHandle context														[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerPlus")]
EpochLLVMCodeOperatorIntegerMinus : LLVMContextHandle context														[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerMinus")]
EpochLLVMCodeOperatorIntegerMultiply : LLVMContextHandle context													[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerMultiply")]
EpochLLVMCodeOperatorIntegerDivide : LLVMContextHandle context														[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerDivide")]

EpochLLVMCodePushAllocate : LLVMContextHandle context																[external("EpochLLVM.dll", "EpochLLVMCodePushAllocate")]
EpochLLVMCodePushBoolean : LLVMContextHandle context, boolean literal												[external("EpochLLVM.dll", "EpochLLVMCodePushBoolean")]
EpochLLVMCodePushInteger : LLVMContextHandle context, integer literal												[external("EpochLLVM.dll", "EpochLLVMCodePushInteger")]
EpochLLVMCodePushInteger16 : LLVMContextHandle context, integer16 literal											[external("EpochLLVM.dll", "EpochLLVMCodePushInteger16")]
EpochLLVMCodePushInteger64 : LLVMContextHandle context, integer literal												[external("EpochLLVM.dll", "EpochLLVMCodePushInteger64")]
EpochLLVMCodePushReal : LLVMContextHandle context, real literal														[external("EpochLLVM.dll", "EpochLLVMCodePushReal")]
EpochLLVMCodePushRawAlloca : LLVMContextHandle context, LLVMAlloca alloca											[external("EpochLLVM.dll", "EpochLLVMCodePushRawAlloca")]
EpochLLVMCodePushRawCall : LLVMContextHandle context, integer callinst												[external("EpochLLVM.dll", "EpochLLVMCodePushRawCall")]
EpochLLVMCodePushRawGEP : LLVMContextHandle context, LLVMGEP gep													[external("EpochLLVM.dll", "EpochLLVMCodePushRawGEP")]
EpochLLVMCodePushRawGlobal : LLVMContextHandle context, LLVMGlobalVar global										[external("EpochLLVM.dll", "EpochLLVMCodePushRawGlobal")]
EpochLLVMCodePushString : LLVMContextHandle context, integer handle													[external("EpochLLVM.dll", "EpochLLVMCodePushString")]
EpochLLVMCodePushFunction : LLVMContextHandle context, LLVMFunctionRef func											[external("EpochLLVM.dll", "EpochLLVMCodePushFunction")]
EpochLLVMCodePushExtractedStructValue : LLVMContextHandle context, integer fieldindex								[external("EpochLLVM.dll", "EpochLLVMCodePushExtractedStructValue")]
EpochLLVMCodePushNothing : LLVMContextHandle context																[external("EpochLLVM.dll", "EpochLLVMCodePushNothing")]

EpochLLVMCodePopValue : LLVMContextHandle context -> integer magic = 0												[external("EpochLLVM.dll", "EpochLLVMCodePopValue")]
EpochLLVMCodePopGEP : LLVMContextHandle context -> LLVMGEP gep = 0													[external("EpochLLVM.dll", "EpochLLVMCodePopValue")]

EpochLLVMCodeMergeSumType : LLVMContextHandle context																[external("EpochLLVM.dll", "EpochLLVMCodeMergeSumType")]

EpochLLVMSectionGetPDataSize : LLVMContextHandle context -> integer size = 0										[external("EpochLLVM.dll", "EpochLLVMSectionGetPDataSize")]
EpochLLVMSectionGetXDataSize : LLVMContextHandle context -> integer size = 0										[external("EpochLLVM.dll", "EpochLLVMSectionGetXDataSize")]
EpochLLVMSectionGetGCSize : LLVMContextHandle context -> integer size = 0											[external("EpochLLVM.dll", "EpochLLVMSectionGetGCSize")]
EpochLLVMSectionGetDebugSize : LLVMContextHandle context -> integer size = 0										[external("EpochLLVM.dll", "EpochLLVMSectionGetDebugSize")]
EpochLLVMSectionGetDebugRelocSize : LLVMContextHandle context -> integer size = 0									[external("EpochLLVM.dll", "EpochLLVMSectionGetDebugRelocSize")]
EpochLLVMSectionGetDebugSymbolSize : LLVMContextHandle context -> integer size = 0									[external("EpochLLVM.dll", "EpochLLVMSectionGetDebugSymbolSize")]

EpochLLVMSectionCopyPData : LLVMContextHandle context, buffer ref targetbuffer										[external("EpochLLVM.dll", "EpochLLVMSectionCopyPData")]
EpochLLVMSectionCopyXData : LLVMContextHandle context, buffer ref targetbuffer										[external("EpochLLVM.dll", "EpochLLVMSectionCopyXData")]
EpochLLVMSectionCopyGC : LLVMContextHandle context, buffer ref targetbuffer											[external("EpochLLVM.dll", "EpochLLVMSectionCopyGC")]
EpochLLVMSectionCopyDebug : LLVMContextHandle context, buffer ref targetbuffer										[external("EpochLLVM.dll", "EpochLLVMSectionCopyDebug")]
EpochLLVMSectionCopyDebugReloc : LLVMContextHandle context, buffer ref targetbuffer									[external("EpochLLVM.dll", "EpochLLVMSectionCopyDebugReloc")]
EpochLLVMSectionCopyDebugSymbols : LLVMContextHandle context, buffer ref targetbuffer -> integer numsyms = 0		[external("EpochLLVM.dll", "EpochLLVMSectionCopyDebugSymbols")]


SetUpAllLLVMCode : LLVMContextHandle context, integer ref globaloffsettracker
{	
	print("Generating LLVM structure types...")
	CodeGenRearrangeStructures(Structures)
	CreateAllStructuresInLLVM(context, Structures)
	
	print("Generating LLVM structure constructors...")
	CreateAllConstructorsInLLVM(context, Structures)
	
	print("Generating LLVM function signatures...")
	CreateAllFunctionSignaturesInLLVM(context, FunctionSignatures)

	print("Generating LLVM function thunks...")
	SetUpCustomLLVMThunks(context, GlobalRootNamespace.FunctionTags)

	print("Generating LLVM type-matcher declarations...")
	GenerateTypeMatcherMappings(Functions)
	GeneratePendingTypeMatchersInLLVM(context, PendingTypeMatchers)
	
	print("Generating LLVM function declarations...")
	CreateAllFunctionsInLLVM(context, Functions)

	print("Generating LLVM type-matcher implementations...")
	EmitAllTypeMatchersInLLVM(context, TypeMatchers)

	print("Generating LLVM global variables...")
	CreateAllGlobalsInLLVM(context, GlobalScope.Wrapped, globaloffsettracker)
	CreateGlobalInitsInLLVM(context)
}



CreateGlobalInitsInLLVM : LLVMContextHandle context
{
	LLVMFunctionRef llvmfunc = 0

	LLVMBasicBlock nullblock = 0
	EpochLLVMSetCurrentBasicBlock(context, nullblock)

	BinaryTreeRoot<LLVMAlloca> novars = nothing

	LLVMBuildContext build = context, llvmfunc, novars, LLVMGlobalTable, nullblock
	EmitCodeBlockToLLVM(build, GlobalCodeBlock)
}



CreateAllGlobalsInLLVM : LLVMContextHandle context, Scope ref scope, integer ref offset
{
	CreateAllGlobalsInLLVM(context, scope.Variables, offset)
}

CreateAllGlobalsInLLVM : LLVMContextHandle context, list<Variable> ref vars, integer ref offset
{
	if(vars.value.VarType != 0)
	{
		LLVMType vartype = GetLLVMTypeForEpochType(context, vars.value.VarType)
		LLVMGlobalVar global = EpochLLVMCodeCreateGlobal(context, vartype, GetPooledString(vars.value.Name))
		BinaryTreeCreateOrInsert<LLVMGlobalVar>(LLVMGlobalTable, vars.value.Name, global)

		integer size = GetTypeSize(vars.value.VarType)
		GlobalMetadata meta = vars.value.Name, size, offset
		BinaryTreeCreateOrInsert<GlobalMetadata>(LLVMGlobalVariables, vars.value.Name, meta)

		offset = offset + size
	}

	CreateAllGlobalsInLLVM(context, vars.next, offset)
}

CreateAllGlobalsInLLVM : LLVMContextHandle context, nothing, integer ref offset


CreateAllFunctionSignaturesInLLVM : LLVMContextHandle context, list<FunctionSignature> ref signatures
{
	if(signatures.value.Name != 0)
	{
		if(!signatures.value.InferenceDone)
		{
			ResolveSignatureTypes(signatures.value.Parameters)
			signatures.value.InferenceDone = true
		}

		EpochLLVMFunctionTypePush(context)
		LLVMType funcrettype = EpochLLVMTypeGetVoid(context)
		if((signatures.value.ReturnTypeName != 0))
		{
			integer t = GetTypeByName(signatures.value.ReturnTypeName)
			assertmsg(t != 0, "Invalid return type signature")
			funcrettype = GetLLVMTypeForEpochType(context, t)
		}

		CreateFunctionParamTypesInLLVM(context, signatures.value.Parameters, 0, false)

		LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
		BinaryTreeCreateOrInsert<LLVMFunctionType>(LLVMFunctionSignatureTable, signatures.value.Name, functype)
	}
	
	CreateAllFunctionSignaturesInLLVM(context, signatures.next)
}

CreateAllFunctionSignaturesInLLVM : LLVMContextHandle context, nothing



CreateAllFunctionsInLLVM : LLVMContextHandle context, list<FunctionDefinition> ref funcs
{
	if(!funcs.value.IsTemplate)
	{
		if(funcs.value.Name != 0)
		{
			CreateSingleFunctionInLLVM(context, funcs.value)
		}
	}

	CreateAllFunctionsInLLVM(context, funcs.next)
}

CreateAllFunctionsInLLVM : LLVMContextHandle context, nothing



CreateSingleFunctionInLLVM : LLVMContextHandle context, FunctionDefinition ref func
{
	string funcname = GetPooledString(func.Name)

	EpochLLVMFunctionTypePush(context)

	LLVMType funcrettype = GetLLVMTypeForEpochType(context, func.Return)
	
	integer rawname = 0
	if(listcontains(CustomConstructors, func.Name))
	{
		rawname = func.RawName
	}
	
	CreateFunctionParamTypesInLLVM(context, func.Params, rawname, false)
	
	LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
	LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, funcname, functype)

	BinaryTreeCreateOrInsert<LLVMFunctionRef>(LLVMFunctionTable, func.Name, llvmfunc)
}

CreateFunctionParamTypesInLLVM : LLVMContextHandle context, FunctionParams ref params, integer rawfuncname, boolean isthunk
{
	CreateFunctionParamTypesInLLVM(context, params.Params, rawfuncname, isthunk)
}

CreateFunctionParamTypesInLLVM : LLVMContextHandle context, list<UnresolvedParameter> ref params, integer rawfuncname, boolean isthunk
{
	if((MakeNonReferenceType(params.value.ResolvedType) == 0x01000000) && (rawfuncname != 0))
	{
		integer typeid = GetTypeByName(rawfuncname)
		assertmsg(typeid != 0, "Invalid constructor name")
		LLVMType paramtype = GetLLVMTypeForEpochType(context, MakeReferenceType(typeid))
		EpochLLVMFunctionQueueParamType(context, paramtype, GetPooledString(rawfuncname))
	}
	else
	{
		assertmsg(params.value.ResolvedType != 0, "Invalid param type")
		LLVMType paramtype = GetLLVMTypeForEpochType(context, params.value.ResolvedType)
		EpochLLVMFunctionQueueParamType(context, paramtype, GetPooledString(params.value.NameHandle))
	}
	
	CreateFunctionParamTypesInLLVM(context, params.next, rawfuncname, isthunk)
}

CreateFunctionParamTypesInLLVM : LLVMContextHandle context, nothing, integer rawfuncname, boolean isthunk


CreateFunctionParamTypesInLLVM : LLVMContextHandle context, list<Parameter> ref params, integer rawfuncname, boolean isthunk
{
	if(params.value.Type != 0)
	{
		LLVMType paramtype = GetLLVMTypeForEpochType(context, params.value.Type)
		if(params.value.Name == 2)
		{
			paramtype = EpochLLVMTypeGetPointerTo(context, paramtype)
		}

		EpochLLVMFunctionQueueParamType(context, paramtype, GetPooledString(params.value.Name))
	}	

	CreateFunctionParamTypesInLLVM(context, params.next, rawfuncname, isthunk)
}


GetLLVMTypeForEpochType : LLVMContextHandle context, Expression ref expr -> LLVMType t = 0
{
	assertmsg(expr.Type != 0, "Invalid expression type")
	t = GetLLVMTypeForEpochType(context, expr.Type)
}

GetLLVMTypeForEpochType : LLVMContextHandle context, integer typeid -> LLVMType t = 0
{
	integer originaltype = typeid

	boolean wasref = IsReferenceType(typeid)
	typeid = MakeNonReferenceType(typeid)
	
	while((typeid & 0x7f000000) == 0x05000000)
	{
		typeid = FindTypeAliasBase(typeid)
	}
	

	if(typeid == 0x01000001)
	{
		t = EpochLLVMTypeGetInteger(context)	
	}
	elseif(typeid == 0x01000002)
	{
		t = EpochLLVMTypeGetInteger16(context)
	}
	elseif(typeid == 0x01000003)
	{
		t = EpochLLVMTypeGetBoolean(context)
	}
	elseif(typeid == 0x01000004)
	{
		t = EpochLLVMTypeGetReal(context)
	}
	elseif(typeid == 0x01000005)
	{
		t = EpochLLVMTypeGetInteger64(context)
	}
	elseif(typeid == 0x02000000)
	{
		t = EpochLLVMTypeGetString(context)
	}
	elseif(typeid == 0x02000001)
	{
		t = EpochLLVMTypeGetBuffer(context)
	}
	elseif(typeid == 4)			// nothing
	{
		t = EpochLLVMTypeGetInteger(context)
	}
	elseif(IsStructureType(typeid))
	{
		boolean found = BinaryTreeCopyPayload<LLVMType>(LLVMStructureTypeTable.RootNode, typeid, t)
		assertmsg(found, "Structure type not registered with LLVM " ; GetPooledString(GetNameOfType(typeid)))
	}
	elseif(IsSumType(typeid))
	{
		boolean found = BinaryTreeCopyPayload<LLVMType>(LLVMSumTypeTable.RootNode, typeid, t)
		if(!found)
		{
			t = EpochLLVMSumTypeCreate(context, GetPooledString(GetNameOfType(typeid)), GetTypeSize(typeid))			// TODO - double check return values from this function
			BinaryTreeCreateOrInsert<LLVMType>(LLVMSumTypeTable, typeid, t)
		}
	}
	elseif(IsArrayType(typeid))
	{
		boolean found = BinaryTreeCopyPayload<LLVMType>(LLVMArrayTypeTable.RootNode, typeid, t)
		if(!found)
		{
			LLVMType elty = GetLLVMTypeForEpochType(context, GetArrayElementType(ArrayTypes, typeid))
			t = EpochLLVMTypeGetArrayOfType(context, elty, GetArrayArity(ArrayTypes, typeid))
			BinaryTreeCreateOrInsert<LLVMType>(LLVMArrayTypeTable, typeid, t)
		}
	}
	elseif(IsFunctionType(typeid))
	{
		LLVMFunctionType fty = 0
		boolean found = BinaryTreeCopyPayload<LLVMFunctionType>(LLVMFunctionSignatureTable.RootNode, typeid, fty)
		assertmsg(found, "Function signature not registered with LLVM")
		
		t = EpochLLVMTypeGetPointerTo(context, fty)
	}
	else
	{
		assertmsg(false, "Unsupported type for LLVM bindings: " ; cast(string, originaltype)) //GetPooledString(GetNameOfType(typeid)))
	}
	
	if(wasref)
	{
		t = EpochLLVMTypeGetPointerTo(context, t)
	}
}

GetLLVMTypeForEpochType : LLVMContextHandle context, nothing -> LLVMType t = EpochLLVMTypeGetVoid(context)



EmitAllFunctionsToLLVM : LLVMContextHandle context, list<FunctionDefinition> ref funcs
{
	if(!funcs.value.IsTemplate)
	{
		if(funcs.value.Name != 0)
		{
			EmitSingleFunctionToLLVM(context, funcs.value)
		}
	}

	EmitAllFunctionsToLLVM(context, funcs.next)
}

EmitAllFunctionsToLLVM : LLVMContextHandle context, nothing



CreateLLVMAllocasForScope : LLVMBuildContext ref context, Scope ref scope, FunctionDefinition ref func
{
	CreateLLVMAllocasForScope(context, scope.Variables, func)
}

CreateLLVMAllocasForScope : LLVMBuildContext ref context, list<Variable> ref variables, FunctionDefinition ref func
{
	if(variables.value.Name != 0)
	{
		CreateSingleLLVMAlloca(context, variables.value, func)
	}
	
	CreateLLVMAllocasForScope(context, variables.next, func)
}

CreateLLVMAllocasForScope : LLVMBuildContext ref context, nothing, FunctionDefinition ref func


CreateSingleLLVMAlloca : LLVMBuildContext ref context, Variable ref var, FunctionDefinition ref func
{
	if(var.VarType == 0x81000000)
	{
		if(listcontains(CustomConstructors, func.Name))
		{
			integer typeid = GetTypeByName(func.RawName)
			assertmsg(typeid != 0, "Invalid constructor")
			
			LLVMType vartype = GetLLVMTypeForEpochType(context.Context, MakeReferenceType(typeid))
			LLVMAlloca alloca = EpochLLVMCodeCreateAlloca(context.Context, vartype, GetPooledString(var.Name), var.Origin)
			BinaryTreeCreateOrInsert<LLVMAlloca>(context.LocalVariables, var.Name, alloca)
			
			return()
		}
	}

	assertmsg(var.VarType != 0, "Invalid variable type")

	LLVMType vartype = GetLLVMTypeForEpochType(context.Context, var.VarType)
	LLVMAlloca alloca = EpochLLVMCodeCreateAlloca(context.Context, vartype, GetPooledString(var.Name), var.Origin)
	BinaryTreeCreateOrInsert<LLVMAlloca>(context.LocalVariables, var.Name, alloca)
}



EmitRetInitializerToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, Expression ref expr -> LLVMAlloca ret = 0
{
	integer returnname = 0
	FindReturnVariableNameInSingleScope(func.AttachedScope.Wrapped, returnname)
	
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, returnname, alloca)
	assertmsg(alloca != 0, "Missing return alloca")
	
	EmitExpressionAtomsToLLVM(context, expr.Atoms)
	
	if(!IsStructureType(expr.Type))
	{
		if(func.AnonymousReturn)
		{
			EpochLLVMCodeCreateWrite(context.Context, alloca)
		}
		else
		{
			EpochLLVMCodeStatementFinalize(context.Context, 1, 1)			// TODO - real debug info
		}
	}
	
	ret = alloca
}

EmitRetInitializerToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, nothing -> LLVMAlloca ret = 0


EmitParamInitializersToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, integer paramindex, FunctionParams ref params
{
	EmitParamInitializersToLLVM(context, func, paramindex, params.Params)
}

EmitParamInitializersToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, integer paramindex, list<UnresolvedParameter> ref params
{
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, params.value.NameHandle, alloca)
	assertmsg(alloca != 0, "Missing local alloca for parameter")
	
	EpochLLVMCodeCreateReadParam(context.Context, paramindex)
	EpochLLVMCodeCreateWrite(context.Context, alloca)

	EmitParamInitializersToLLVM(context, func, paramindex + 1, params.next)
}

EmitParamInitializersToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, integer paramindex, nothing


EmitSingleFunctionToLLVM : LLVMContextHandle context, FunctionDefinition ref func
{
	//print("Generating LLVM code for function: " ; GetPooledString(func.Name))

	LLVMFunctionRef llvmfunc = 0
	BinaryTreeCopyPayload<LLVMFunctionRef>(LLVMFunctionTable.RootNode, func.Name, llvmfunc)

	LLVMBasicBlock funcbody = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, true)
	LLVMBasicBlock exitblock = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, false)
	

	BinaryTreeRoot<LLVMAlloca> vartree = nothing
	LLVMBuildContext build = context, llvmfunc, vartree, LLVMGlobalTable, exitblock
	CreateLLVMAllocasForScope(build, func.AttachedScope.Wrapped, func)
	
	FindScopeAndSetContext(func)

	EmitParamInitializersToLLVM(build, func, 0, func.Params)
	LLVMAlloca ret = EmitRetInitializerToLLVM(build, func, func.Return)
		
	EmitExternalInvokeTagToLLVM(build, func, GlobalRootNamespace.FunctionTags, ret)
	
	EmitCodeBlockToLLVM(build, func.Code)
	
	if(listcontains(CustomConstructors, func.Name))
	{
		integer returnname = 0
		FindReturnVariableNameInSingleScope(func.AttachedScope.Wrapped, returnname)
		
		LLVMAlloca alloca = 0
		BinaryTreeCopyPayload<LLVMAlloca>(vartree.RootNode, returnname, alloca)
		
		EpochLLVMCodeCreateRead(context, alloca)
		EpochLLVMCodeCreateWriteParam(context, 0)
	}

	EpochLLVMCodeCreateBranch(context, exitblock, true)
	
	if(func.AnonymousReturn)
	{
		EmitReturnRegisterToLLVMAnonymous(build, func.Return)
	}
	else
	{
		EmitReturnRegisterToLLVM(build, func, func.Return)
	}
		
	string funcname = GetPooledString(func.Name)
	if(funcname == "entrypoint")
	{
		EpochLLVMFunctionSetEntry(context, llvmfunc)
	}
	
	EpochLLVMFunctionFinalize(context)
}

EmitAllParamsToLLVM : LLVMContextHandle context, integer paramindex, FunctionParams ref params
{
	EmitAllParamsToLLVM(context, paramindex, params.Params)
}


EmitAllParamsToLLVM : LLVMContextHandle context, integer paramindex, list<UnresolvedParameter> ref params
{
	EpochLLVMCodeCreateReadParam(context, paramindex)
	EmitAllParamsToLLVM(context, paramindex + 1, params.next)
}

EmitAllParamsToLLVM : LLVMContextHandle context, integer paramindex, nothing


EmitExternalInvokeTagToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, list<FunctionTag> ref taglist, LLVMAlloca ret
{
	if(taglist.value.FunctionName == func.Name)
	{
		if(taglist.value.TagName == "external")
		{
			EmitAllParamsToLLVM(context.Context, 0, func.Params)

			integer thunk = 0
			BinaryTreeCopyPayload<integer>(LLVMGlobalThunks.RootNode, func.Name, thunk)
			
			assertmsg(thunk != 0, "Missing external thunk")
			integer callinst = EpochLLVMCodeCreateCallThunk(context.Context, thunk)
			
			if(GetOptionalExpressionType(func.Return) != 0)
			{
				EpochLLVMCodePushRawCall(context.Context, callinst)
				EpochLLVMCodeCreateWrite(context.Context, ret)
			}
			
			return()
		}
	}

	EmitExternalInvokeTagToLLVM(context, func, taglist.next, ret)
}

EmitExternalInvokeTagToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, nothing, LLVMAlloca ret



EmitCodeBlockToLLVM : LLVMBuildContext ref context, CodeBlock ref code
{
	EmitCodeBlockEntriesToLLVM(context, code.Entries)
}

EmitCodeBlockToLLVM : LLVMBuildContext ref context, nothing


EmitReturnRegisterToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, Expression ref expr
{
	integer returnname = 0
	FindReturnVariableNameInSingleScope(func.AttachedScope.Wrapped, returnname)
	
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, returnname, alloca)
	assertmsg(alloca != 0, "Missing alloca for return value")
	
	EpochLLVMCodeCreateRead(context.Context, alloca)
	EpochLLVMCodeCreateRet(context.Context)
}

EmitReturnRegisterToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, nothing
{
	EpochLLVMCodeCreateRetVoid(context.Context)
}


EmitReturnRegisterToLLVMAnonymous : LLVMBuildContext ref context, Expression ref expr
{
	EmitExpressionAtomsToLLVM(context, expr.Atoms)
	EpochLLVMCodeCreateRet(context.Context)
}


EmitReturnRegisterToLLVMAnonymous : LLVMBuildContext ref context, nothing
{
	EpochLLVMCodeCreateRetVoid(context.Context)
}



EmitCodeBlockEntriesToLLVM : LLVMBuildContext ref context, list<CodeBlockEntry> ref entries
{
	EmitSingleCodeBlockEntryToLLVM(context, entries.value)
	EmitCodeBlockEntriesToLLVM(context, entries.next)
}

EmitCodeBlockEntriesToLLVM : LLVMBuildContext ref context, nothing




EmitAssignmentRHSToLLVM : LLVMBuildContext ref context, Assignment ref entry
{
	EmitSingleCodeBlockEntryToLLVM(context, entry)
	
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, entry.LHSName, alloca)
	assertmsg(alloca != 0, "Missing local assignment LHS")

	EpochLLVMCodeCreateRead(context.Context, alloca)
}

EmitAssignmentRHSToLLVM : LLVMBuildContext ref context, Expression ref expr
{
	EmitExpressionAtomsToLLVM(context, expr)
}



EmitSingleCodeBlockEntryToLLVM : LLVMBuildContext ref context, Assignment ref entry
{
	LLVMGlobalVar global = 0
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, entry.LHSName, alloca)
	

	if(alloca == 0)
	{
		BinaryTreeCopyPayload<LLVMGlobalVar>(context.GlobalVariables.RootNode, entry.LHSName, global)
	}


	integer rhstype = GetAssignmentRHSType(entry)
	EmitAssignmentRHSToLLVM(context, entry.RHS)

	if(entry.Operator == PooledStringHandleForAssignment)
	{
		// Nothing to do here, simple assignment
	}
	elseif(entry.Operator == PooledStringHandleForIncrementAssignInteger)
	{
		if(alloca != 0)
		{
			EpochLLVMCodeCreateRead(context.Context, alloca)
		}
		else
		{
			assertmsg(false, "Not implemented (increment-assign on global)")
		}

		if(IsReferenceType(entry.LHSType))
		{
			EpochLLVMCodeCreateDereference(context.Context)
		}

		EpochLLVMCodeOperatorIntegerPlus(context.Context)
	}
	else
	{
		assertmsg(false, "Unsupported assignment operator")
	}

	if(alloca != 0)
	{
		if(IsReferenceType(entry.LHSType))
		{
			EpochLLVMCodeCreateWriteIndirect(context.Context, alloca)		
		}
		else
		{
			if(IsSumType(entry.LHSType) && IsReferenceType(rhstype))
			{
				EpochLLVMCodeCreateDereference(context.Context)
			}

			EpochLLVMCodeCreateWrite(context.Context, alloca)
		}
	}
	else
	{
		assertmsg(global != 0, "Missing global variable")
		EpochLLVMCodeCreateWriteGlobal(context.Context, global)		
	}
}

EmitSingleCodeBlockEntryToLLVM : LLVMBuildContext ref context, AssignmentArrayIndex ref entry
{
	assertmsg(entry.Operator == PooledStringHandleForAssignment, "Unsupported assignment operator")
	
	EmitAssignmentRHSToLLVM(context, entry.RHS)
		
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, entry.LHSName, alloca)
	assertmsg(alloca != 0, "Missing array")

	EmitExpressionAtomsToLLVM(context, entry.IndexExpression)
	EpochLLVMCodeCreateReadArray(context.Context, alloca)
	EpochLLVMCodeCreateWriteStructurePop(context.Context)
}

EmitSingleCodeBlockEntryToLLVM : LLVMBuildContext ref context, AssignmentCompound ref entry
{
	assertmsg(entry.Operator == PooledStringHandleForAssignment, "Unsupported assignment operator")

	EmitAssignmentRHSToLLVM(context, entry.RHS)
	
	LLVMGlobalVar global = 0
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, entry.LHS.value, alloca)
	
	if(alloca == 0)
	{
		BinaryTreeCopyPayload<LLVMGlobalVar>(context.GlobalVariables.RootNode, entry.LHS.value, global)
	}
	
	integer typeid = FindVariableType(entry.LHS.value)
	boolean isref = IsReferenceType(typeid)
	typeid = MakeNonReferenceType(typeid)

	integer rhstype = GetAssignmentRHSType(entry.RHS)

	integer structurename = GetNameOfStructureByType(typeid)
	
	if(alloca != 0)
	{
		EpochLLVMCodePushRawAlloca(context.Context, alloca)
	}
	else
	{
		EpochLLVMCodePushRawGlobal(context.Context, global)
	}

	if(isref)
	{
		EpochLLVMCodeCreateDereference(context.Context)
	}

	EmitAssignmentLHSGEPsToLLVM(context, entry.LHS.next, structurename, typeid, rhstype)
	
	if(IsSumType(entry.LHSType))
	{
		if (IsReferenceType(entry.LHSType))
		{
			EpochLLVMCodeCreateDereference(context.Context)
		}

		if(entry.LHSType == rhstype)
		{
			EpochLLVMCodeCreateWriteStructurePop(context.Context)
		}
		else
		{
			EpochLLVMCodePushInteger(context.Context, MakeNonReferenceType(rhstype))
			EpochLLVMCodeCreateWriteStructurePopSumType(context.Context)
		}
	}
	else
	{
		if(IsReferenceType(rhstype))		// TODO - this is not correct, we should key off MakeAlloc, not type signature (because we might assign ref = ref)
		{
			EpochLLVMCodeCreateDereference(context.Context)
		}

		EpochLLVMCodeCreateWriteStructurePop(context.Context)
	}
}


EmitSingleCodeBlockEntryToLLVM : LLVMBuildContext ref context, Statement ref entry
{
	if(entry.Name == 0)
	{
		return()
	}

	integer call = 0

	if(IsRecognizedBuiltIn(entry.Name))
	{
		if(GetTypeByName(entry.Name) == 0)
		{
			if(entry.Name == PooledStringHandleForReturn)
			{
				EpochLLVMCodeCreateBranch(context.Context, context.ExitBlock, false)
				EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, true)
			}
			elseif(entry.Name == PooledStringHandleForCastInteger16ToInteger)
			{
				EmitPartialExpressionListToLLVM(context, entry.Parameters)
				EpochLLVMCodeCreateCast(context.Context, GetLLVMTypeForEpochType(context.Context, 0x01000001))
			}
			elseif(entry.Name == PooledStringHandleForCastBooleanToInteger)
			{
				EmitPartialExpressionListToLLVM(context, entry.Parameters)
				EpochLLVMCodeCreateCast(context.Context, GetLLVMTypeForEpochType(context.Context, 0x01000001))				
			}
			else
			{
				if(entry.Name == PooledStringHandleForCastIntegerToString)
				{
					EmitPartialExpressionListToLLVM(context, entry.Parameters)
				}
				elseif(entry.Name == PooledStringHandleForCastIntegerToInteger16)
				{
					EmitPartialExpressionListToLLVM(context, entry.Parameters)
				}
				else
				{
					EmitExpressionListToLLVM(context, entry.Parameters)
				}
			
				integer thunk = 0
				BinaryTreeCopyPayload<integer>(LLVMGlobalThunks.RootNode, entry.Name, thunk)

				assertmsg(thunk != 0, "Missing function " ; GetPooledString(entry.Name) ; " - " ; cast(string, entry.Name))

				EpochLLVMCodeCreateCallThunk(context.Context, thunk)
			}
		}
		else
		{
			integer varname = ExtractConstructorIdentifier(entry.Parameters)
			assertmsg(varname != 0, "Couldn't find variable to initialize")

			LLVMAlloca alloca = 0
			BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, varname, alloca)
			
			if(alloca != 0)
			{
				if(entry.ArrayArity > 0)
				{
					integer paramcount = 0
					while(paramcount < entry.ArrayArity)
					{
						EmitExpressionToLLVMFromList(context, entry.Parameters, 0, paramcount + 1)

						EpochLLVMCodePushInteger(context.Context, paramcount)
						EpochLLVMCodeCreateReadArray(context.Context, alloca)
						EpochLLVMCodeCreateWriteStructurePop(context.Context)

						++paramcount
					}
				}
				elseif(entry.Name == PooledStringHandleForBuffer)
				{
					integer thunk = 0
					BinaryTreeCopyPayload<integer>(LLVMGlobalThunks.RootNode, PooledStringHandleForBuffer, thunk)

					EpochLLVMCodePushRawAlloca(context.Context, alloca)
					EmitPartialExpressionListToLLVM(context, entry.Parameters)
					EpochLLVMCodeCreateCallThunk(context.Context, thunk)
				}
				else
				{			
					EmitPartialExpressionListToLLVM(context, entry.Parameters)
					EpochLLVMCodeCreateWrite(context.Context, alloca)
				}
			}
			else
			{
				// Must be a global
				LLVMGlobalVar globvar = 0
				BinaryTreeCopyPayload<LLVMGlobalVar>(context.GlobalVariables.RootNode, varname, globvar)
				assertmsg(globvar != 0, "Missing local and global variable for initialization")

				EmitPartialExpressionListToLLVM(context, entry.Parameters)
				EpochLLVMCodeCreateWriteGlobal(context.Context, globvar)
			}
		}
	}
	elseif(SumTypeExists(entry.Name))
	{
		integer stvarname = ExtractConstructorIdentifier(entry.Parameters)
		assertmsg(stvarname != 0, "Couldn't find sum-typed variable to initialize")

		LLVMAlloca stalloca = 0
		BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, stvarname, stalloca)
		assertmsg(stalloca != 0, "Couldn't find LLVM binding sum-typed alloca to initialize")

		integer rhstype = GetParameterTypeFromExpressionList(entry.Parameters, 1)
		if (IsReferenceType(rhstype))
		{
			EmitPartialExpressionListToLLVM(context, entry.Parameters)
			EpochLLVMCodeCreateDereference(context.Context)
			EpochLLVMCodePushRawAlloca(context.Context, stalloca)
			EpochLLVMCodePushInteger(context.Context, MakeNonReferenceType(rhstype))
			EpochLLVMCodeCreateWriteStructurePopSumType(context.Context)
		}
		else
		{
			EpochLLVMCodePushRawAlloca(context.Context, stalloca)
			LLVMGEP stgep = EpochLLVMCodeCreateGEP(context.Context, 0)

			EmitPartialExpressionListToLLVM(context, entry.Parameters)
			EpochLLVMCodeCreateWriteStructure(context.Context, stgep)
		}
	}
	else
	{
		if(entry.MakeAlloc)
		{
			integer consvarname = ExtractConstructorIdentifier(entry.Parameters)
			assertmsg(consvarname != 0, "Couldn't find variable to initialize")

			LLVMAlloca consalloca = 0
			BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, consvarname, consalloca)
			assertmsg(consalloca != 0, "Couldn't find LLVM binding alloca to initialize")

			EpochLLVMCodePushRawAlloca(context.Context, consalloca)
			EpochLLVMCodePushAllocate(context.Context)

			EmitPartialExpressionListToLLVM(context, entry.Parameters)
		}
		else
		{
			EmitExpressionListToLLVM(context, entry.Parameters)
		}

		integer vartype = GetVariableTypeFromScope(EmittingScope.Wrapped, entry.Name)
		if((vartype & 0x7f000000) == 0x09000000)
		{
			LLVMAlloca fpalloca = 0
			BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, entry.Name, fpalloca)
			assertmsg(fpalloca != 0, "Missing higher order function parameter")
			
			call = EpochLLVMCodeCreateCallIndirect(context.Context, fpalloca)
		}
		else
		{
			LLVMFunctionRef llvmfunc = 0
			BinaryTreeCopyPayload<LLVMFunctionRef>(LLVMFunctionTable.RootNode, entry.Name, llvmfunc)
			
			if(llvmfunc == 0)
			{
				assertmsg(llvmfunc != 0, "Failed to map LLVM function " ; GetPooledString(entry.Name))
			}
			
			call = EpochLLVMCodeCreateCall(context.Context, llvmfunc)
		}
	}
	
	ParsedToken token = "", "", 0, 0
	if(entry.DebugInfoIndex > 0)
	{
		BinaryTreeCopyPayload<ParsedToken>(DebugDataMap.RootNode, entry.DebugInfoIndex, token)
		assertmsg(token.Row > 0, "Missing statement debug data " ; cast(string, entry.DebugInfoIndex))
	}
	else
	{
		print("WARNING - statement has no debug metadata yet!")
	}
	
	if(entry.TopLevel)
	{
		EpochLLVMCodeStatementFinalize(context.Context, token.Row, token.Column)
	}
	elseif(call != 0)
	{
		EpochLLVMCodeTagDebugLocation(context.Context, call, token.Row, token.Column)
	}
}


EmitSingleCodeBlockEntryToLLVM : LLVMBuildContext ref context, PreOpStatement ref preop
{
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, preop.Operand.value, alloca)
	if(alloca != 0)
	{
		if(countnonzero(preop.Operand) == 1)
		{
			if(preop.Operator == PooledStringHandleForPrePostIncrementInteger)
			{
				if(IsReferenceType(preop.Type))
				{
					EpochLLVMCodePushInteger(context.Context, 1)
					EpochLLVMCodeCreateRead(context.Context, alloca)
					EpochLLVMCodeCreateDereference(context.Context)
					EpochLLVMCodeOperatorIntegerPlus(context.Context)
					EpochLLVMCodeCreateWriteIndirect(context.Context, alloca)
					EpochLLVMCodeCreateRead(context.Context, alloca)
					EpochLLVMCodeCreateDereference(context.Context)
				}
				else
				{
					EpochLLVMCodeCreateRead(context.Context, alloca)
					EpochLLVMCodePushInteger(context.Context, 1)
					EpochLLVMCodeOperatorIntegerPlus(context.Context)
					EpochLLVMCodeCreateWrite(context.Context, alloca)
					EpochLLVMCodeCreateRead(context.Context, alloca)
				}
			}
			elseif(preop.Operator == PooledStringHandleForPrePostDecrementInteger)
			{
				if(IsReferenceType(preop.Type))
				{
					EpochLLVMCodePushInteger(context.Context, 1)
					EpochLLVMCodeCreateRead(context.Context, alloca)
					EpochLLVMCodeCreateDereference(context.Context)
					EpochLLVMCodeOperatorIntegerMinus(context.Context)
					EpochLLVMCodeCreateWriteIndirect(context.Context, alloca)
					EpochLLVMCodeCreateRead(context.Context, alloca)
					EpochLLVMCodeCreateDereference(context.Context)
				}
				else
				{
					EpochLLVMCodePushInteger(context.Context, 1)
					EpochLLVMCodeCreateRead(context.Context, alloca)
					EpochLLVMCodeOperatorIntegerMinus(context.Context)
					EpochLLVMCodeCreateWrite(context.Context, alloca)
					EpochLLVMCodeCreateRead(context.Context, alloca)
				}
			}
			else
			{
				assertmsg(false, "Unsupported pre-operation")
			}
		}
		else
		{
			assertmsg(false, "Compound preincrement/decrement not implemented")
		}
	}
	else		// Must be a parameter
	{
		LLVMGlobalVar global = 0
		BinaryTreeCopyPayload<LLVMGlobalVar>(context.GlobalVariables.RootNode, preop.Operand.value, global)
		assertmsg(global != 0, "Missing local and global variable")

		if(countnonzero(preop.Operand) == 1)
		{
			if(preop.Operator == PooledStringHandleForPrePostIncrementInteger)
			{
				EpochLLVMCodePushRawGlobal(context.Context, global)
				EpochLLVMCodeCreateDereference(context.Context)
				EpochLLVMCodePushInteger(context.Context, 1)
				EpochLLVMCodeOperatorIntegerPlus(context.Context)
				EpochLLVMCodeCreateWriteGlobal(context.Context, global)
				EpochLLVMCodePushRawGlobal(context.Context, global)
				EpochLLVMCodeCreateDereference(context.Context)
			}
			elseif(preop.Operator == PooledStringHandleForPrePostDecrementInteger)
			{
				EpochLLVMCodePushInteger(context.Context, 1)
				EpochLLVMCodePushRawGlobal(context.Context, global)
				EpochLLVMCodeCreateDereference(context.Context)
				EpochLLVMCodeOperatorIntegerMinus(context.Context)
				EpochLLVMCodeCreateWriteGlobal(context.Context, global)
				EpochLLVMCodePushRawGlobal(context.Context, global)
				EpochLLVMCodeCreateDereference(context.Context)
			}
			else
			{
				assertmsg(false, "Unsupported pre-operation")
			}
		}
		else
		{
			assertmsg(false, "Compound preincrement/decrement not implemented")
		}		
	}

	if(preop.TopLevel)
	{
		EpochLLVMCodeStatementFinalize(context.Context, 1, 1)
	}
}

EmitSingleCodeBlockEntryToLLVM : LLVMBuildContext ref context, EntityChain ref entry
{
	EmitEntityChainEntriesToLLVM(context, entry.Entries)
}

EmitEntityChainEntriesToLLVM : LLVMBuildContext ref context, EntityList ref entitylist
{
	EmitEntityChainEntriesToLLVM(context, entitylist.ActualList)
}

EmitEntityChainEntriesToLLVM : LLVMBuildContext ref context, list<Entity> ref entities
{
	boolean entityiforelse = false
	
	if(entities.value.Tag == 0x11)
	{
		entityiforelse = true
	}
		
	if(entities.value.Tag == 0x12)
	{
		entityiforelse = true
	}

	if(entityiforelse)			// if/elseif
	{
		EmitExpressionAtomsToLLVM(context, entities.value.Param)
		integer magiccond = EpochLLVMCodePopValue(context.Context)
		
		LLVMBasicBlock currentinsertpoint = EpochLLVMGetCurrentBasicBlock(context.Context)
		
		LLVMBasicBlock falseblock = EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, false)
		LLVMBasicBlock mergeblock = EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, false)
		
		LLVMBasicBlock trueblock = EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, true)
		EmitCodeBlockToLLVM(context, entities.value.Code)
		EpochLLVMCodeCreateBranch(context.Context, mergeblock, false)
				
		EpochLLVMSetCurrentBasicBlock(context.Context, currentinsertpoint)
		EpochLLVMCodeCreateCondBranch(context.Context, magiccond, trueblock, falseblock)
		
		EpochLLVMSetCurrentBasicBlock(context.Context, falseblock)
		EmitEntityChainEntriesToLLVM(context, entities.next)
		EpochLLVMCodeCreateBranch(context.Context, mergeblock, true)
	}
	elseif(entities.value.Tag == 0x13)		// else
	{
		EmitCodeBlockToLLVM(context, entities.value.Code)
	}
	elseif(entities.value.Tag == 0x14)		// while
	{		
		LLVMBasicBlock condblock = EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, false)
		LLVMBasicBlock loopblock = EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, false)
		LLVMBasicBlock mergeblock = EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, false)

		EpochLLVMCodeCreateBranch(context.Context, condblock, true)
		
		EmitExpressionAtomsToLLVM(context, entities.value.Param)
		integer magiccond = EpochLLVMCodePopValue(context.Context)
		EpochLLVMCodeCreateCondBranch(context.Context, magiccond, loopblock, mergeblock)
		
		EpochLLVMSetCurrentBasicBlock(context.Context, loopblock)
		EmitCodeBlockToLLVM(context, entities.value.Code)
		EpochLLVMCodeCreateBranch(context.Context, condblock, false)
		
		EpochLLVMSetCurrentBasicBlock(context.Context, mergeblock)
	}
	elseif(entities.value.Tag == 0)
	{
		EmitEntityChainEntriesToLLVM(context, entities.next)
	}
}



EmitEntityChainEntriesToLLVM : LLVMBuildContext ref context, nothing



// TODO - remaining code block entry types


EmitExpressionListToLLVM : LLVMBuildContext ref context, nothing

EmitExpressionListToLLVM : LLVMBuildContext ref context, ExpressionList ref exprs
{
	EmitExpressionListToLLVM(context, exprs.Expressions)
}

EmitExpressionListToLLVM : LLVMBuildContext ref context, list<Expression> ref exprs
{
	EmitExpressionAtomsToLLVM(context, exprs.value.Atoms)
	EmitExpressionListToLLVM(context, exprs.next)
}


EmitPartialExpressionListToLLVM : LLVMBuildContext ref context, ExpressionList ref exprs
{
	EmitExpressionListToLLVM(context, exprs.Expressions.next)
}


EmitExpressionToLLVMFromList : LLVMBuildContext ref context, ExpressionList ref exprs, integer counter, integer target
{
	EmitExpressionToLLVMFromList(context, exprs.Expressions, counter, target)
}

EmitExpressionToLLVMFromList : LLVMBuildContext ref context, list<Expression> ref exprs, integer counter, integer target
{
	if(counter == target)
	{
		EmitExpressionAtomsToLLVM(context, exprs.value.Atoms)
	}
	else
	{
		EmitExpressionToLLVMFromList(context, exprs.next, counter + 1, target)
	}
}


EmitExpressionAtomsToLLVM : LLVMBuildContext ref context, Expression ref expr
{
	EmitExpressionAtomsToLLVM(context, expr.Atoms)
}

EmitExpressionAtomsToLLVM : LLVMBuildContext ref context, list<ExpressionAtom> ref atoms
{
	EmitSingleAtomToLLVM(context, atoms.value)
	EmitExpressionAtomsToLLVM(context, atoms.next)
}

EmitExpressionAtomsToLLVM : LLVMBuildContext ref context, nothing


EmitSingleAtomToLLVM : LLVMBuildContext ref context, AtomSentinel ref sentinel


EmitSingleAtomToLLVM : LLVMBuildContext ref context, integer ref literal
{
	EpochLLVMCodePushInteger(context.Context, literal)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, integer16 ref literal
{
	EpochLLVMCodePushInteger16(context.Context, literal)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, integer64 ref literal
{
	EpochLLVMCodePushInteger64(context.Context, literal.dummy)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, boolean ref literal
{
	EpochLLVMCodePushBoolean(context.Context, literal)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, real ref literal
{
	EpochLLVMCodePushReal(context.Context, literal)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, StringHandleAtom ref literal
{
	EpochLLVMCodePushString(context.Context, literal.Handle)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, Statement ref statement
{
	EmitSingleCodeBlockEntryToLLVM(context, statement)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, IdentifierAtom ref idatom
{
	integer atomtype = MakeNonReferenceType(idatom.Type)

	if(atomtype == 0x00000004)							// Nothing type signature
	{
		EpochLLVMCodePushNothing(context.Context)
	}
	else
	{
		if(idatom.IsFunction)
		{
			LLVMFunctionRef func = 0
			BinaryTreeCopyPayload<LLVMFunctionRef>(LLVMFunctionTable.RootNode, idatom.Handle, func)

			if(func != 0)
			{
				EpochLLVMCodePushFunction(context.Context, func)
			}
			else
			{
				LLVMAlloca alloca = 0
				BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, idatom.Handle, alloca)
				assertmsg(alloca != 0, "Missing function used as higher-order parameter")

				EpochLLVMCodeCreateRead(context.Context, alloca)
			}
		}
		elseif(GetTypeByName(idatom.Handle) != 0)
		{
			EpochLLVMCodePushString(context.Context, idatom.Handle)
		}
		else
		{
			if(atomtype == 0x01000000)					// Identifier type signature
			{
				if(!IsReferenceType(idatom.Type))
				{
					EpochLLVMCodePushString(context.Context, idatom.Handle)
				}
				else
				{
					LLVMAlloca alloca = 0
					BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, idatom.Handle, alloca)
					if(alloca != 0)
					{
						EpochLLVMCodePushRawAlloca(context.Context, alloca)
					}
					else
					{
						// Must be a global
						LLVMGlobalVar globvar = 0
						BinaryTreeCopyPayload<LLVMGlobalVar>(context.GlobalVariables.RootNode, idatom.Handle, globvar)
						assertmsg(globvar != 0, "Missing local and global variable")

						EpochLLVMCodePushRawGlobal(context.Context, globvar)
					}
				}
			}
			elseif((atomtype & 0x7f000000) == 0x09000000)			// Function type family signature
			{
				LLVMFunctionRef func = 0
				BinaryTreeCopyPayload<LLVMFunctionRef>(LLVMFunctionTable.RootNode, idatom.Handle, func)
				
				if(func != 0)
				{
					EpochLLVMCodePushFunction(context.Context, func)
				}
				else
				{
					LLVMAlloca alloca = 0
					BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, idatom.Handle, alloca)
					assertmsg(alloca != 0, "Missing function used as higher-order parameter")

					EpochLLVMCodeCreateRead(context.Context, alloca)
				}
			}
			else
			{
				LLVMAlloca alloca = 0
				BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, idatom.Handle, alloca)

				if(alloca == 0)
				{
					LLVMGlobalVar global = 0
					BinaryTreeCopyPayload<LLVMGlobalVar>(context.GlobalVariables.RootNode, idatom.Handle, global)
		
					assertmsg(global != 0, "Missing local and global variable")
					EpochLLVMCodePushRawGlobal(context.Context, global)		
				}
				else
				{
					if(idatom.IsReference)
					{
						EpochLLVMCodePushRawAlloca(context.Context, alloca)
					}
					else
					{	
						EpochLLVMCodeCreateRead(context.Context, alloca)
					}
				}
					
				Variable var = 0, 0, 0, 0
				FindVariableDataInSingleScope(EmittingScope.Wrapped, idatom.Handle, var)
				if(var.Name == 0)
				{
					assertmsg(false, "Missing variable " ; GetPooledString(idatom.Handle))
				}
				
				if(IsReferenceType(var.VarType))
				{
					//if(!IsSumType(var.VarType))
					//{
						EpochLLVMCodeCreateDereference(context.Context)
					//}
				}
				elseif(alloca == 0)
				{
					if(!idatom.IsReference)
					{
						EpochLLVMCodeCreateDereference(context.Context)
					}
				}
			}
		}
	}
}


EmitSingleAtomToLLVM : LLVMBuildContext ref context, OperatorInvokeAtom ref atom
{
	boolean getthunk = false

	if(atom.OperatorName == PooledStringHandleForUnaryNotBoolean)
	{
		EpochLLVMCodeOperatorBooleanNot(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForEqualityInteger)
	{
		EpochLLVMCodeOperatorIntegerEquals(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForEqualityInteger16)
	{
		EpochLLVMCodeOperatorIntegerEquals(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForInequalityInteger)
	{
		EpochLLVMCodeOperatorIntegerNotEquals(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForPlusInteger)
	{
		EpochLLVMCodeOperatorIntegerPlus(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForMinusInteger)
	{
		EpochLLVMCodeOperatorIntegerMinus(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForMultiplyInteger)
	{
		EpochLLVMCodeOperatorIntegerMultiply(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForDivideInteger)
	{
		EpochLLVMCodeOperatorIntegerDivide(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForGreaterThanInteger)
	{
		EpochLLVMCodeOperatorIntegerGreaterThan(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForLessThanInteger)
	{
		EpochLLVMCodeOperatorIntegerLessThan(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForBitwiseAnd)
	{
		EpochLLVMCodeOperatorIntegerBitwiseAnd(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForBooleanAnd)
	{
		EpochLLVMCodeOperatorBooleanAnd(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForEqualityString)
	{
		getthunk = true
	}
	elseif(atom.OperatorName == PooledStringHandleForInequalityString)
	{
		getthunk = true
	}
	elseif(atom.OperatorName == PooledStringHandleForStringConcat)
	{
		getthunk = true
	}
	else
	{
		assertmsg(false, "Operator not implemented in LLVM bindings " ; GetPooledString(atom.OperatorName))
	}

	if(getthunk)
	{
		integer thunk = 0
		BinaryTreeCopyPayload<integer>(LLVMGlobalThunks.RootNode, atom.OperatorName, thunk)
		
		assertmsg(thunk != 0, "Missing external thunk")
		EpochLLVMCodeCreateCallThunk(context.Context, thunk)
	}
}


EmitSingleAtomToLLVM : LLVMBuildContext ref context, RefBinding ref atom
{
	integer index = GetStructureMemberIndex(atom.StructureName, atom.Identifier)
	LLVMGEP gep = EpochLLVMCodeCreateGEP(context.Context, index)
	EpochLLVMCodePushRawGEP(context.Context, gep)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, CompoundAtom ref atom
{
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, atom.Bindings.value.Identifier, alloca)
	if(alloca == 0)
	{
		LLVMGlobalVar global = 0
		BinaryTreeCopyPayload<LLVMGlobalVar>(context.GlobalVariables.RootNode, atom.Bindings.value.Identifier, global)
		
		assertmsg(global != 0, "Missing local and global variable for compound atom: " ; GetPooledString(atom.Bindings.value.Identifier))
		EpochLLVMCodePushRawGlobal(context.Context, global)
	}
	else
	{
		assertmsg(alloca != 0, "Missing local variable for compound atom: " ; GetPooledString(atom.Bindings.value.Identifier))
		EpochLLVMCodePushRawAlloca(context.Context, alloca)
	}

	boolean endwithpointer = false
	if(IsSumType(atom.Type) && IsReferenceType(atom.Type))
	{
		endwithpointer = true
	}
	elseif(IsReferenceType(atom.Type) && (MakeNonReferenceType(atom.Type) == 0x02000001))			// TODO - try and understand *why* buffer type is an exceptional case here!
	{
		endwithpointer = true
	}

	EmitCompoundBindingsToLLVM(context, endwithpointer, atom.Bindings, atom.Bindings.next)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, TypeAnnotationAtom ref atom
{
	EpochLLVMCodePushInteger(context.Context, MakeNonReferenceType(atom.Type))
	EpochLLVMCodeMergeSumType(context.Context)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, ArrayIndexAtom ref atom
{
	EmitExpressionAtomsToLLVM(context, atom.IndexExpression)

	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, atom.ArrayVarName, alloca)
	assertmsg(alloca != 0, "Missing array")
	
	EpochLLVMCodeCreateReadArray(context.Context, alloca)
	EpochLLVMCodeCreateDereference(context.Context)
}


EmitSingleAtomToLLVM : LLVMBuildContext ref context, ParentheticalExpression ref atom
{
	DecomposeParentheticalInLLVM(context, atom.Inner)
}

DecomposeParentheticalInLLVM : LLVMBuildContext ref context, Expression ref expr
{
	EmitExpressionAtomsToLLVM(context, expr.Atoms)
}

DecomposeParentheticalInLLVM : LLVMBuildContext ref context, PreOpStatement ref preop
{
	EmitSingleCodeBlockEntryToLLVM(context, preop)
}

DecomposeParentheticalInLLVM : LLVMBuildContext ref context, PostOpStatement ref postop
{
	assertmsg(false, "Post-operations are not supported yet")
}


EmitCompoundBindingsToLLVM : LLVMBuildContext ref context, boolean endwithpointer, list<RefBinding> ref bindings, list<RefBinding> ref tail
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(EmittingScope.Wrapped, bindings.value.Identifier, var)

	assertmsg(var.VarType != 0, "Compound bindings reference bogus variable")
	integer lhstypename = GetNameOfType(var.VarType)
	integer index = GetStructureMemberIndex(lhstypename, tail.value.Identifier)

	if(IsReferenceType(var.VarType))
	{
		EpochLLVMCodeCreateDereference(context.Context)
	}
	
	LLVMGEP gep = EpochLLVMCodeCreateGEP(context.Context, index)
	EpochLLVMCodePushRawGEP(context.Context, gep)

	EmitCompoundSubsequentBindingsToLLVM(context, endwithpointer, tail.next)

	if(!endwithpointer)
	{
		// TODO - if ultimate binding has type != expected type, and expected type is sum type, alloca a sumtype and stash payload (don't forget to hoist allocas later)
		EpochLLVMCodeCreateDereference(context.Context)
	}
}

EmitCompoundSubsequentBindingsToLLVM : LLVMBuildContext ref context, boolean endwithpointer, nothing

EmitCompoundSubsequentBindingsToLLVM : LLVMBuildContext ref context, boolean endwithpointer, list<RefBinding> ref bindings
{
	EpochLLVMCodeCreateDereference(context.Context)

	EmitSingleAtomToLLVM(context, bindings.value)

	EmitCompoundSubsequentBindingsToLLVM(context, endwithpointer, bindings.next)
}


CheckForFollowingBinding : list<RefBinding> ref thelist -> true
CheckForFollowingBinding : nothing -> false





SetUpBuiltInLLVMThunks : LLVMContextHandle context
{
	BuiltInThunkCreateAssert(context)
	BuiltInThunkCreateBufferAlloc(context)
	BuiltInThunkCreateBufferCopy(context)
	BuiltInThunkCreatePasstest(context)
	BuiltInThunkCreatePrint(context)
	BuiltInThunkCreateStringEquality(context)
	BuiltInThunkCreateStringInequality(context)
	BuiltInThunkCreateStringConcat(context)
	BuiltInThunkCreateStringFromInteger(context)
	BuiltInThunkCreateStringLength(context)
	BuiltInThunkCreateInteger16FromInteger(context)
	BuiltInThunkCreateStringToReal(context)
	BuiltInThunkCreateWriteBufferString(context)
	BuiltInThunkCreateSubstringWithLength(context)
	BuiltInThunkCreateSubstringNoLength(context)
	BuiltInThunkCreateUnescape(context)
	BuiltInThunkCreateWriteBufferMultiple(context)
	BuiltInThunkCreateStringToInteger(context)
	BuiltInThunkCreateSubchar(context)
	BuiltInThunkCreateNarrowString(context)
	BuiltInThunkCreateWriteBuffer(context)
	BuiltInThunkCreateRealToString(context)
	BuiltInThunkCreateCommandLineIsValid(context)
	BuiltInThunkCreateCommandLineGetCount(context)
	BuiltInThunkCreateCommandLineGet(context)
	BuiltInThunkCreateWriteBufferReal(context)
	BuiltInThunkCreateWidenFromPtr(context)
	
	BuiltInThunkCreateGCInit(context)
	BuiltInThunkCreateGCCollectStrings(context)
}


SetUpCustomLLVMThunks : LLVMContextHandle context, list<FunctionTag> ref taglist
{
	if(taglist.value.TagName == "external")
	{
		string libname = ""
		string thunkname = ""
		string callconv = ""
		
		copyfromlist<string>(taglist.value.Parameters, 1, libname)
		copyfromlist<string>(taglist.value.Parameters, 2, thunkname)
		copyfromlist<string>(taglist.value.Parameters, 3, callconv)

		SetUpSingleLLVMThunk(context, Functions, taglist.value.FunctionName, thunkname, callconv)
		
		ThunkTableAddEntry(GlobalThunkTable, libname, thunkname)
	}
	
	SetUpCustomLLVMThunks(context, taglist.next)
}

SetUpCustomLLVMThunks : LLVMContextHandle context, nothing


SetUpSingleLLVMThunk : LLVMContextHandle context, list<FunctionDefinition> ref funcs, integer funcname, string thunkname, string callconv
{
	if(funcs.value.Name == funcname)
	{
		EpochLLVMFunctionTypePush(context)
		LLVMType funcrettype = GetLLVMTypeForEpochType(context, funcs.value.Return)
		CreateFunctionParamTypesInLLVM(context, funcs.value.Params, 0, true)
		LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, funcrettype)
		
		integer thunk = EpochLLVMFunctionCreateThunk(context, thunkname, fty)

		BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, funcname, thunk)
	}
	else
	{
		SetUpSingleLLVMThunk(context, funcs.next, funcname, thunkname, callconv)
	}
}



BuiltInThunkCreateAssert : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetBoolean(context), "expression")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_assert", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForAssert, thunk)
}

BuiltInThunkCreateBufferAlloc : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, EpochLLVMTypeGetBuffer(context)), "out")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "size")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_buffer_alloc", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForBuffer, thunk)
}

BuiltInThunkCreateBufferCopy : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetBuffer(context), "in")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetBuffer(context), "out")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_buffer_copy", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForBufferCopy, thunk)
}

BuiltInThunkCreatePasstest : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_passtest", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForPassTest, thunk)
}

BuiltInThunkCreatePrint : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "str")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_print", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForPrint, thunk)
}

BuiltInThunkCreateStringEquality : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "l")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "r")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetBoolean(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_string_compare", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForEqualityString, thunk)
}

BuiltInThunkCreateStringInequality : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "l")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "r")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetBoolean(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_string_compare_notequal", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForInequalityString, thunk)
}

BuiltInThunkCreateStringConcat : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "l")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "r")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetString(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_string_concat", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForStringConcat, thunk)
}

BuiltInThunkCreateStringLength : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "str")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetInteger(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "lstrlenA", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForLength, thunk)
}


BuiltInThunkCreateStringFromInteger : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "val")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetString(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_string_from_integer", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForCastIntegerToString, thunk)
}

BuiltInThunkCreateStringToInteger : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "str")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetInteger(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_string_to_integer", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForCastStringToInteger, thunk)
}

BuiltInThunkCreateRealToString : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetReal(context), "val")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetString(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_real_to_string", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForCastRealToString, thunk)
}

BuiltInThunkCreateSubchar : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "str")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "index")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetInteger(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_subchar", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForSubchar, thunk)
}

BuiltInThunkCreateInteger16FromInteger : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "val")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetInteger16(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_integer16_from_integer", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForCastIntegerToInteger16, thunk)
}

BuiltInThunkCreateStringToReal : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "str")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetReal(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_string_to_real", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForCastStringToReal, thunk)
}

BuiltInThunkCreateGCInit : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "magic")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_gc_init", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForGCInit, thunk)
}

BuiltInThunkCreateGCCollectStrings : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_gc_collect_strings", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringhandleForGCCollectStrings, thunk)
}


BuiltInThunkCreateWriteBuffer : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, EpochLLVMTypeGetBuffer(context)), "buf")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "ptr")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "bytes")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_write_buffer", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForWriteBuffer, thunk)
}

BuiltInThunkCreateWriteBufferString : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, EpochLLVMTypeGetBuffer(context)), "buf")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "offset")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "str")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "bytes")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_write_buffer_string", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForWriteBufferString, thunk)
}


BuiltInThunkCreateWriteBufferMultiple : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, EpochLLVMTypeGetBuffer(context)), "buf")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "arg1")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "arg2")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "arg3")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_write_buffer_multiple", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForWriteBufferMultiple, thunk)
}


BuiltInThunkCreateWriteBufferReal : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, EpochLLVMTypeGetBuffer(context)), "buf")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "offset")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetReal(context), "val")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_write_buffer_real", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForWriteBufferReal, thunk)
}


BuiltInThunkCreateSubstringWithLength : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "str")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "start")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "length")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetString(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_substring_length", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForSubstringWithLength, thunk)
}



BuiltInThunkCreateSubstringNoLength : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "str")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "start")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetString(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_substring_nolength", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForSubstringNoLength, thunk)
}


BuiltInThunkCreateUnescape : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "str")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetString(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_string_unescape", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForUnescape, thunk)
}

BuiltInThunkCreateNarrowString : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context), "str")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetBuffer(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_string_narrow", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForNarrowString, thunk)
}

BuiltInThunkCreateCommandLineIsValid : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetBoolean(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_cmdlineisvalid", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForCmdLineIsValid, thunk)	
}

BuiltInThunkCreateCommandLineGetCount : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetInteger(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_cmdlinegetcount", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForCmdLineGetCount, thunk)	
}

BuiltInThunkCreateCommandLineGet : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "index")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetString(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_cmdlineget", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForCmdLineGet, thunk)	
}

BuiltInThunkCreateWidenFromPtr : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "ptr")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetInteger(context), "length")
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetString(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_widenfromptr", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForWidenFromPtr, thunk)	
}



CreateAllStructuresInLLVM : LLVMContextHandle context, list<StructureDefinition> ref structures
{
	CreateAllStructuresInLLVM(context, structures.next)

	if((structures.value.Name != 0) && (!structures.value.IsTemplate))
	{	
		CreateStructureMembersInLLVM(context, structures.value.Members)
		LLVMType sty = EpochLLVMStructureTypeCreate(context, GetPooledString(structures.value.Name))

		BinaryTreeCreateOrInsert<LLVMType>(LLVMStructureTypeTable, structures.value.Type, sty)
	}
}


CreateAllStructuresInLLVM : LLVMContextHandle context, nothing



CreateStructureMembersInLLVM : LLVMContextHandle context, list<StructureMember> ref members
{
	if(GetMemberName(members.value) != 0)
	{
		EpochLLVMStructureQueueMemberType(context, GetLLVMTypeForMemberType(context, members.value))
	}

	CreateStructureMembersInLLVM(context, members.next)
}

CreateStructureMembersInLLVM : LLVMContextHandle context, nothing


GetLLVMTypeForMemberType : LLVMContextHandle context, StructureMemberVariable ref member -> LLVMType t = 0
{
	assertmsg(member.Type != 0, "Invalid structure member variable type")
	t = GetLLVMTypeForEpochType(context, member.Type)
}

GetLLVMTypeForMemberType : LLVMContextHandle context, StructureMemberFunctionRef ref member -> LLVMType t = 0
{
	EpochLLVMFunctionTypePush(context)

	integer ret = GetTypeByName(member.Signature.ReturnTypeName)
	assertmsg(ret != 0, "Invalid return type from structure member function signature")

	LLVMType funcrettype = GetLLVMTypeForEpochType(context, ret)
	CreateFunctionParamTypesInLLVM(context, member.Signature.Parameters, 0, false)
	
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, funcrettype)
	t = EpochLLVMTypeGetPointerTo(context, fty)
}


CreateAllConstructorsInLLVM : LLVMContextHandle context, list<StructureDefinition> ref structures
{
	if((structures.value.Name != 0) && (!structures.value.IsTemplate))
	{
		CreateConstructorInLLVM(context, structures.value)
		CreateAnonConstructorInLLVM(context, structures.value)

		if(structures.value.CopyConstructorName != 0)
		{
			CreateCopyConstructorInLLVM(context, structures.value)
		}
	}

	CreateAllConstructorsInLLVM(context, structures.next)
}

CreateAllConstructorsInLLVM : LLVMContextHandle context, nothing



CreateMemberParamTypesInLLVM : LLVMContextHandle context, list<StructureMember> ref members
{
	EpochLLVMFunctionQueueParamType(context, GetLLVMTypeForMemberType(context, members.value), GetPooledString(GetMemberName(members.value)))
	CreateMemberParamTypesInLLVM(context, members.next)
}

CreateMemberParamTypesInLLVM : LLVMContextHandle context, nothing




CreateConstructorInLLVM : LLVMContextHandle context, StructureDefinition ref struct
{
	EpochLLVMFunctionTypePush(context)
	LLVMType funcrettype = EpochLLVMTypeGetVoid(context)
	
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, GetLLVMTypeForEpochType(context, struct.Type)), GetPooledString(struct.Name))
	CreateMemberParamTypesInLLVM(context, struct.Members)
	
	LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
	LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, GetPooledString(struct.ConstructorName), functype)

	BinaryTreeCreateOrInsert<LLVMFunctionRef>(LLVMFunctionTable, struct.ConstructorName, llvmfunc)


	LLVMBasicBlock funcbody = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, true)

	EmitStructureInitializationToLLVM(context, struct.Members, 0, 1)
	
	EpochLLVMCodeCreateRetVoid(context)
}

CreateAnonConstructorInLLVM : LLVMContextHandle context, StructureDefinition ref struct
{
	EpochLLVMFunctionTypePush(context)
	LLVMType funcrettype = GetLLVMTypeForEpochType(context, struct.Type)
	CreateMemberParamTypesInLLVM(context, struct.Members)
	
	LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
	LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, GetPooledString(struct.AnonConstructorName), functype)
	
	BinaryTreeCreateOrInsert<LLVMFunctionRef>(LLVMFunctionTable, struct.AnonConstructorName, llvmfunc)
	
	
	LLVMBasicBlock funcbody = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, true)
	LLVMAlloca retalloca = EpochLLVMCodeCreateAlloca(context, funcrettype, "@anonymous", 2)
	
	EmitAnonStructureInitializationToLLVM(context, struct.Members, 0, 0, retalloca)
	
	EpochLLVMCodePushRawAlloca(context, retalloca)
	EpochLLVMCodeCreateDereference(context)
	EpochLLVMCodeCreateRet(context)
}

CreateCopyConstructorInLLVM : LLVMContextHandle context, StructureDefinition ref struct
{
	EpochLLVMFunctionTypePush(context)
	LLVMType funcrettype = EpochLLVMTypeGetVoid(context)
	
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, GetLLVMTypeForEpochType(context, struct.Type)), "a")
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, GetLLVMTypeForEpochType(context, struct.Type)), "b")

	LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
	LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, GetPooledString(struct.CopyConstructorName), functype)
	
	BinaryTreeCreateOrInsert<LLVMFunctionRef>(LLVMFunctionTable, struct.CopyConstructorName, llvmfunc)
	
	
	LLVMBasicBlock funcbody = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, true)

	EpochLLVMCodeCreateReadParam(context, 1)
	EpochLLVMCodeCreateDereference(context)
	EpochLLVMCodeCreateWriteParam(context, 0)
	EpochLLVMCodeCreateRetVoid(context)
}




EmitStructureInitializationToLLVM : LLVMContextHandle context, list<StructureMember> ref members, integer memberindex, integer paramindex
{
	EpochLLVMCodeCreateReadParam(context, 0)
	LLVMGEP gep = EpochLLVMCodeCreateGEP(context, memberindex)

	EpochLLVMCodeCreateReadParam(context, paramindex)
	EpochLLVMCodeCreateWriteStructure(context, gep)
	
	EmitStructureInitializationToLLVM(context, members.next, memberindex + 1, paramindex + 1)
}


EmitStructureInitializationToLLVM : LLVMContextHandle context, nothing, integer memberindex, integer paramindex



EmitAnonStructureInitializationToLLVM : LLVMContextHandle context, list<StructureMember> ref members, integer memberindex, integer paramindex, LLVMAlloca retalloca
{
	EpochLLVMCodePushRawAlloca(context, retalloca)
	LLVMGEP gep = EpochLLVMCodeCreateGEP(context, memberindex)
	
	EpochLLVMCodeCreateReadParam(context, paramindex)
	EpochLLVMCodeCreateWriteStructure(context, gep)
	
	EmitAnonStructureInitializationToLLVM(context, members.next, memberindex + 1, paramindex + 1, retalloca)
}

EmitAnonStructureInitializationToLLVM : LLVMContextHandle context, nothing, integer memberindex, integer paramindex, LLVMAlloca retalloca



EmitAssignmentLHSGEPsToLLVM : LLVMBuildContext ref context, simplelist<integer> ref lhsmembers, integer structurename, integer typeid, integer rhstype
{
	integer membertype = GetStructureMemberType(structurename, lhsmembers.value)
	integer memberindex = GetStructureMemberIndex(structurename, lhsmembers.value)
	
	while((membertype & 0x7f000000) == 0x05000000)
	{
		membertype = FindTypeAliasBase(membertype)
	}

	if(IsReferenceType(typeid))
	{
		EpochLLVMCodeCreateDereference(context.Context)
	}

	LLVMGEP gep = EpochLLVMCodeCreateGEP(context.Context, memberindex)
	EpochLLVMCodePushRawGEP(context.Context, gep)

	// Recurse
	assertmsg(membertype != 0, "Member has no type!")
	EmitAssignmentLHSGEPsToLLVM(context, lhsmembers.next, GetNameOfType(membertype), membertype, rhstype)
}

EmitAssignmentLHSGEPsToLLVM : LLVMBuildContext ref context, nothing, integer structurename, integer typeid, integer rhstype


ADummyFunction :
{
	simplelist<boolean> hack = false, nothing
	hack.value = true
}



GeneratePendingTypeMatchersInLLVM : LLVMContextHandle context, list<PendingTypeMatcher> ref pendingmatchers
{
	GeneratePendingTypeMatcherInLLVM(context, pendingmatchers.value)
	GeneratePendingTypeMatchersInLLVM(context, pendingmatchers.next)
}

GeneratePendingTypeMatchersInLLVM : LLVMContextHandle context, nothing

GeneratePendingTypeMatcherInLLVM : LLVMContextHandle context, PendingTypeMatcher ref matcher
{
	if(matcher.OverloadName == 0)
	{
		return()
	}

	ContextNode<TypeMatcher> matchwrap = nothing
	if(!GetExistingTypeMatcher(TypeMatchers, matcher.MatcherName, matchwrap))
	{
		FunctionSignature sig = 0, dummyparamlist, InferFunctionReturnType(matcher.OverloadImplementation), true
		list<FunctionSignature> dsl = sig, nothing
		TypeMatcher m = matcher.MatcherName, dsl
		prepend<TypeMatcher>(TypeMatchers, m)

		matchwrap = TypeMatchers.value
	}

	ContextNode<FunctionDefinition> wrap = nothing
	SearchBinaryTreeForPayload<FunctionDefinition>(GlobalRootNamespace.Functions.RootNode, matcher.OverloadName, wrap)

	WalkParametersForTypeMatcherContext(wrap, matchwrap)
}



EmitAllTypeMatchersInLLVM : LLVMContextHandle context, list<TypeMatcher> ref matchers
{
	if(matchers.value.Name != 0)
	{
		string funcname = GetPooledString(matchers.value.Name)

		EpochLLVMFunctionTypePush(context)

		integer rettypeid = matchers.value.Overloads.value.ReturnTypeName
		LLVMType funcrettype = EpochLLVMTypeGetVoid(context)
		if(rettypeid != 0)
		{
			funcrettype = GetLLVMTypeForEpochType(context, rettypeid)
		}

		CreateTypeMatcherParamsInLLVM(context, matchers.value.Name)
		
		LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
		LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, funcname, functype)

		BinaryTreeCreateOrInsert<LLVMFunctionRef>(LLVMFunctionTable, matchers.value.Name, llvmfunc)

		EpochLLVMCodeCreateBasicBlock(context, llvmfunc, true)
		LLVMAlloca retalloca = 0
		
		if(rettypeid != 0)
		{
			retalloca = EpochLLVMCodeCreateAlloca(context, funcrettype, "retval", 2)
		}

		LLVMBasicBlock exitblock = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, false)

		EmitTypeMatcherOverloadsInLLVM(context, llvmfunc, exitblock, matchers.value.Overloads, matchers.value.Overloads, matchers.value.Name, retalloca)

		EpochLLVMSetCurrentBasicBlock(context, exitblock)
		if(rettypeid != 0)
		{
			EpochLLVMCodePushRawAlloca(context, retalloca)
			EpochLLVMCodeCreateDereference(context)
			EpochLLVMCodeCreateRet(context)
		}
		else
		{
			EpochLLVMCodeCreateRetVoid(context)
		}
	}

	EmitAllTypeMatchersInLLVM(context, matchers.next)
}

EmitAllTypeMatchersInLLVM : LLVMContextHandle context, nothing


EmitTypeMatcherOverloadsInLLVM : LLVMContextHandle context, LLVMFunctionRef func, LLVMBasicBlock exitblock, list<FunctionSignature> ref signatures, list<FunctionSignature> ref alloverloads, integer matchername, LLVMAlloca retalloca
{
	if(signatures.value.Name != 0)
	{
		LLVMFunctionRef overloadfunc = 0
		BinaryTreeCopyPayload<LLVMFunctionRef>(LLVMFunctionTable.RootNode, signatures.value.Name, overloadfunc)

		LLVMBasicBlock nextoverloadblock = EpochLLVMCodeCreateBasicBlock(context, func, false)

		integer paramindex = 0
		EmitTypeMatcherParamsInLLVM(context, alloverloads, signatures.value.Parameters, paramindex, 0, func, overloadfunc, nextoverloadblock, signatures.value, exitblock, matchername, retalloca)
	}

	EmitTypeMatcherOverloadsInLLVM(context, func, exitblock, signatures.next, alloverloads, matchername, retalloca)
}

EmitTypeMatcherOverloadsInLLVM : LLVMContextHandle context, LLVMFunctionRef func, LLVMBasicBlock exitblock, nothing, list<FunctionSignature> ref alloverloads, integer matchername, LLVMAlloca retalloca
{
	integer assertfunc = 0
	BinaryTreeCopyPayload<integer>(LLVMGlobalThunks.RootNode, PooledStringHandleForAssert, assertfunc)

	EpochLLVMCodePushBoolean(context, false)
	EpochLLVMCodeCreateCallThunk(context, assertfunc)
	EpochLLVMCodeStatementFinalize(context, 1, 1)

	EpochLLVMCodeCreateBranch(context, exitblock, false)
}


EmitTypeMatcherParamsInLLVM : LLVMContextHandle context, list<FunctionSignature> ref overloads, list<Parameter> ref params, integer paramindex, integer relevantparams, LLVMFunctionRef func, LLVMFunctionRef overloadfunc, LLVMBasicBlock nextoverloadblock, FunctionSignature ref overloadsig, LLVMBasicBlock exitblock, integer matchername, LLVMAlloca retalloca
{
	if(params.value.Name != 0)
	{
		LLVMBasicBlock nextparamblock = EpochLLVMCodeCreateBasicBlock(context, func, false)

		simplelist<integer> typelist = 0, nothing
		EnumerateSignaturesAndAddParameterTypes(overloads, paramindex, typelist)
		integer typecount = countnonzero(typelist)

		if(typecount == 1)
		{
			EpochLLVMCodeCreateBranch(context, nextparamblock, false)
			++relevantparams
		}
		else
		{
			boolean refflag = IsReferenceType(params.value.Type)	
			integer paramtype = MakeNonReferenceType(params.value.Type)
			while((paramtype & 0x7f000000) == 0x05000000)
			{
				paramtype = FindTypeAliasBase(paramtype)
			}


			integer paramsumtype = TypeMatcherGetSumTypeForParamIndex(matchername, paramindex)
			if(paramsumtype != 0)
			{
				if(SumTypeHasBase(paramsumtype, paramtype))
				{
					EpochLLVMCodeCreateReadParam(context, paramindex)
					EpochLLVMCodePushExtractedStructValue(context, 0)
					EpochLLVMCodePushInteger(context, MakeNonReferenceType(paramtype))
					EpochLLVMCodeOperatorIntegerEquals(context)
					EpochLLVMCodeCreateCondBranch(context, EpochLLVMCodePopValue(context), nextparamblock, nextoverloadblock)
					++relevantparams
				}
				else
				{
					EpochLLVMCodeCreateBranch(context, nextparamblock, false)
				}
			}
			else
			{
				EpochLLVMCodeCreateBranch(context, nextparamblock, false)
			}
		}

		EpochLLVMSetCurrentBasicBlock(context, nextparamblock)

		EmitTypeMatcherParamsInLLVM(context, overloads, params.next, paramindex + 1, relevantparams, func, overloadfunc, nextoverloadblock, overloadsig, exitblock, matchername, retalloca)
	}
	else
	{
		EmitTypeMatcherParamsInLLVM(context, overloads, params.next, paramindex, relevantparams, func, overloadfunc, nextoverloadblock, overloadsig, exitblock, matchername, retalloca)
	}

	EpochLLVMSetCurrentBasicBlock(context, nextoverloadblock)
}

EmitTypeMatcherParamsInLLVM : LLVMContextHandle context, list<FunctionSignature> ref overloads, nothing, integer paramindex, integer relevantparams, LLVMFunctionRef func, LLVMFunctionRef overloadfunc, LLVMBasicBlock nextoverloadblock, FunctionSignature ref overloadsig, LLVMBasicBlock exitblock, integer matchername, LLVMAlloca retalloca
{
	if(relevantparams == paramindex)
	{
		ForwardTypeMatcherParamsInLLVM(context, overloads, matchername, overloadsig)
		integer call = EpochLLVMCodeCreateCall(context, overloadfunc)

		if (call != 0)
		{
			EpochLLVMCodeTagDebugLocation(context, call, 1, 1)			// TODO - solve this better
		}

		if(retalloca != 0)
		{
			EpochLLVMCodeCreateWrite(context, retalloca)
		}
		EpochLLVMCodeStatementFinalize(context, 1, 1)
		EpochLLVMCodeCreateBranch(context, exitblock, false)
	}
	else
	{
		EpochLLVMCodeCreateBranch(context, nextoverloadblock, false)
	}
}


CreateTypeMatcherParamsInLLVM : LLVMContextHandle context, integer matchername
{
	ContextNode<CallSiteMetadata> wrap = nothing
	if(!SearchBinaryTreeForPayload<CallSiteMetadata>(TypeMatcherCallSiteMetadata.RootNode, matchername, wrap))
	{
		assertmsg(false, "Missing type matcher call site metadata")
	}

	CreateTypeMatcherParamsInLLVM(context, wrap)
}

CreateTypeMatcherParamsInLLVM : LLVMContextHandle context, CallSiteMetadata ref metadata
{
	CreateTypeMatcherParamsInLLVM(context, metadata.ArgTypeSets)
}

CreateTypeMatcherParamsInLLVM : LLVMContextHandle context, list<ArgumentMetadata> ref argtypesets
{
	integer sumtypeid = FindFirstSumTypeInList(argtypesets.value.ArgTypes)
	integer argtype = argtypesets.value.ArgTypes.value

	if(sumtypeid != 0)
	{
		argtype = sumtypeid
	}

	if(TypeMatcherTypeListNeedsRef(argtypesets.value.ArgTypes))
	{
		argtype = MakeReferenceType(argtype)
	}

	LLVMType paramtype = GetLLVMTypeForEpochType(context, argtype)
	EpochLLVMFunctionQueueParamType(context, paramtype, "arg")

	CreateTypeMatcherParamsInLLVM(context, argtypesets.next)
}

CreateTypeMatcherParamsInLLVM : LLVMContextHandle context, nothing


EnumerateSignaturesAndAddParameterTypes : list<FunctionSignature> ref signatures, integer paramindex, simplelist<integer> ref typelist
{
	GetParameterTypeFromSignature(signatures.value.Parameters, paramindex, typelist)
	EnumerateSignaturesAndAddParameterTypes(signatures.next, paramindex, typelist)
}

EnumerateSignaturesAndAddParameterTypes : nothing, integer paramindex, simplelist<integer> ref typelist



GetParameterTypeFromSignature : list<Parameter> ref params, integer paramindex, simplelist<integer> ref typelist
{
	if(paramindex == 0)
	{
		if(!listcontains(typelist, params.value.Type))
		{
			simpleprepend<integer>(typelist, params.value.Type)
		}
		return()
	}

	GetParameterTypeFromSignature(params.next, paramindex - 1, typelist)
}

GetParameterTypeFromSignature : nothing, integer paramindex, simplelist<integer> ref typelist


ForwardTypeMatcherParamsInLLVM : LLVMContextHandle context, list<FunctionSignature> ref overloads, integer matchername, FunctionSignature ref signature
{
	ForwardTypeMatcherParamsInLLVM(context, overloads, matchername, signature.Parameters, 0)
}

ForwardTypeMatcherParamsInLLVM : LLVMContextHandle context, list<FunctionSignature> ref overloads, integer matchername, list<Parameter> ref params, integer paramindex
{
	EpochLLVMCodeCreateReadParam(context, paramindex)

	integer ty = params.value.Type
	if(TypeMatcherNeedsSumTypeForParamIndex(matchername, paramindex) && !IsSumType(ty))
	{
		EpochLLVMCodePushExtractedStructValue(context, 1)
		EpochLLVMCodeCreateCast(context, GetLLVMTypeForEpochType(context, ty))
	}

	ForwardTypeMatcherParamsInLLVM(context, overloads, matchername, params.next, paramindex + 1)
}

ForwardTypeMatcherParamsInLLVM : LLVMContextHandle context, list<FunctionSignature> ref overloads, integer matchername, nothing, integer paramindex



TypeMatcherTypeListNeedsRef : simplelist<integer> ref typelist -> boolean ret = false
{
	if(IsSumType(typelist.value))
	{
		ret = true
	}
	elseif(IsReferenceType(typelist.value))
	{
		ret = true
	}
	else
	{
		ret = TypeMatcherTypeListNeedsRef(typelist.next)
	}
}

TypeMatcherTypeListNeedsRef : nothing -> false

