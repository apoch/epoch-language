//
// The Epoch Language Project
// Epoch Development Tools - Compiler Core
//
// EXE.EPOCH
// Executable binary generation routines
//
// This module is responsible for outputting executable
// 64-bit Windows binaries in the PE format. The binary
// itself is compiled via LLVM, but the linking and all
// on-disk arrangement of the image is done here.
//
// In general code in this file is pretty hacky and not
// especially clear. It could use some major cleanup.
//




structure ThunkTableEntry :
	string FunctionName,
	integer ThunkTableOffset,
	integer ThunkAddressOffset,
	integer ThunkAddressCopyOffset

structure ThunkTableLibrary :
	string LibraryName,
	listnode<ThunkTableEntry> Functions,
	integer StartOffset,
	integer NameOffset

structure ThunkTable :
	listnode<ThunkTableLibrary> Libraries,
	integer DescriptorOffset,
	integer TotalSize,
	integer AddressTableSize
	




RoundUp : integer in -> integer out = ((in / 0x1000) + 1) * 0x1000			// TODO - this over-estimates if in is a perfect multiple of 0x1000
RoundUpFile : integer in -> integer out = ((in / 0x200) + 1) * 0x200		// TODO - this over-estimates if in is a perfect multiple of 0x200



MakeExe : EpochProject ref project
{
	IconDirectoryEntry dummydetails = 0, 0, 0, 0, 0
	IconReference dummyicon = "", 0, 0, 0, 0, dummydetails
	list<IconReference> dummyiconlist = dummyicon, nothing
	
	ManifestReference dummymanifest = "", 0
	list<ManifestReference> dummymanifestlist = dummymanifest, nothing

	list<MenuEntry> nomenuentries = MenuSentinel(0), nothing
	MenuResource emptymenu = 0, nomenuentries
	list<MenuResource> nomenus = emptymenu, nothing
	
	AcceleratorEntry nonaccel = 0, 0, 0
	list<AcceleratorEntry> accellist = nonaccel, nothing
	AcceleratorResource noaccel = 0, accellist
	list<AcceleratorResource> noaccels = noaccel, nothing

	ResourceDirectoryHeader resroot = 0, 0, 0, 0, nothing
	ResourceHandler res = resroot, 0, 0, dummyiconlist, dummymanifestlist, 0, nomenus, noaccels
	
	LoadResourceScripts(project.ResourceFiles, res)
	ComputeResourceOffsets(res)
	

	buffer codebinarybuffer = 0x100000		// TODO - this is a REALLY DUMB lazy hack, fix it by allocating a safe size for the code buffer
	EpochLLVMInitialize()
	LLVMContextHandle llvm = EpochLLVMContextCreate()
	EpochLLVMSetThunkCallback(llvm, ThunkLookupMapper)
	EpochLLVMSetStringCallback(llvm, StringLookupMapper)
	
	SetUpBuiltInLLVMThunks(llvm)
	
	integer globaloffsettracker = 0
	SetUpAllLLVMCode(llvm, globaloffsettracker)

	// This is a bad workaround for the fact that 0-length sections
	// cause the Windows loader to vomit. If the globals section is
	// going to be empty anyways, we just pad it out a few bytes so
	// that the loader will be happy.

	// TODO - dynamically remove .global section if globals unused?
	if(globaloffsettracker == 0)
	{
		globaloffsettracker = 42
	}

	integer virtualoffsetthunk   = 0x1000
	integer offsetthunk          = 0x400
	integer sizethunk            = ThunkTableGetCompleteSize(GlobalThunkTable)
		
	EmitAllFunctionsToLLVM(llvm, Functions)
	
	EpochLLVMPrepareBinaryObject(llvm)
	
	
	integer sizepdata = EpochLLVMSectionGetPDataSize(llvm)
	integer sizexdata = EpochLLVMSectionGetXDataSize(llvm)
	integer sizegc = EpochLLVMSectionGetGCSize(llvm)
	integer sizedebug = EpochLLVMSectionGetDebugSize(llvm)
	integer sizedebugreloc = EpochLLVMSectionGetDebugRelocSize(llvm)
	integer sizedebugsymbols = EpochLLVMSectionGetDebugSymbolSize(llvm)
	integer sizestrings = PreprocessStringPool(GlobalStringPool, GlobalStringOffsets)
	
	buffer pdata = sizepdata
	buffer xdata = sizexdata
	buffer gcdata = sizegc
	buffer debugdata = sizedebug
	buffer debugrelocdata = sizedebugreloc
	buffer debugsymboldata = sizedebugsymbols
	
	EpochLLVMSectionCopyPData(llvm, pdata)
	EpochLLVMSectionCopyXData(llvm, xdata)
	EpochLLVMSectionCopyGC(llvm, gcdata)
	EpochLLVMSectionCopyDebug(llvm, debugdata)
	EpochLLVMSectionCopyDebugReloc(llvm, debugrelocdata)
	integer symbolcount = EpochLLVMSectionCopyDebugSymbols(llvm, debugsymboldata)
	
	
	integer virtualoffsetrsrc    = RoundUp(virtualoffsetthunk + sizethunk)
	integer offsetrsrc           = RoundUpFile(offsetthunk + sizethunk)
	integer sizersrc             = res.DirectorySize + res.DataSize + 1
	
	integer virtualoffsetpdata   = RoundUp(virtualoffsetrsrc + sizersrc)
	integer offsetpdata			 = RoundUpFile(offsetrsrc + sizersrc)
	
	integer virtualoffsetxdata   = RoundUp(virtualoffsetpdata + sizepdata)
	integer offsetxdata			 = RoundUpFile(offsetpdata + sizepdata)
	
	integer virtualoffsetstrings = RoundUp(virtualoffsetxdata + sizexdata)
	integer offsetstrings        = RoundUpFile(offsetxdata + sizexdata)
		
	integer virtualoffsetgc      = RoundUp(virtualoffsetstrings + sizestrings)
	integer offsetgc             = RoundUpFile(offsetstrings + sizestrings)

	integer virtualoffsetdebug   = RoundUp(virtualoffsetgc + sizegc)
	integer offsetdebug          = RoundUpFile(offsetgc + sizegc)

	integer virtualoffsetglobals = RoundUp(virtualoffsetdebug + 0x200)			// TODO - hardcoded hack for .debug
	integer offsetglobals        = RoundUp(offsetdebug + 0x200)					// TODO - hardcoded hack for .debug

	integer virtualoffsetcode    = RoundUp(virtualoffsetglobals + globaloffsettracker)
	integer offsetcode           = RoundUpFile(offsetglobals + globaloffsettracker)

	integer sizecode = EpochLLVMEmitBinaryObject(llvm, codebinarybuffer, 0x100000, virtualoffsetcode + 0x0400000, virtualoffsetgc)		// TODO - also bad hacks

	integer totaldebugsize 		 = sizedebug + sizedebugreloc + sizedebugsymbols
	integer sizeimage            = RoundUp(virtualoffsetcode + sizecode)

	
	EpochLLVMContextDestroy(llvm)


	integer GENERIC_WRITE = 0x40000000
	integer CREATE_ALWAYS = 2

	Win32Handle filehandle = CreateFile(project.OutputFileName, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0)
	if(filehandle == -1)
	{
		print("Cannot open " ; project.OutputFileName ; " to emit .EXE!")
		return()
	}
	
	
	string objfilename = substring(project.OutputFileName, 0, length(project.OutputFileName) - 4) ; ".sym"
	string pdbfilename = substring(project.OutputFileName, 0, length(project.OutputFileName) - 4) ; ".pdb"
	string cvfilename = substring(project.OutputFileName, 0, length(project.OutputFileName) - 4) ; ".cv"
	string relocfilename = substring(project.OutputFileName, 0, length(project.OutputFileName) - 4) ; ".reloc"

	Win32Handle objfilehandle = CreateFile(objfilename, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0)
	if(objfilehandle == -1)
	{
		print("Cannot open " ; objfilename ; " to emit .SYM!")
		return()
	}
	

	integer16 subsystem = 2		// GUI
	if(project.UsesConsole)
	{
		subsystem = 3			// console
	}

	integer offsetcv = RoundUpFile(offsetcode + sizecode)

	integer written = 0
	integer position = 0
	position += WritePEHeader(filehandle, sizeimage, virtualoffsetdebug, sizedebug, virtualoffsetpdata, sizepdata, virtualoffsetxdata, sizexdata, virtualoffsetthunk + GlobalThunkTable.DescriptorOffset, sizethunk, virtualoffsetrsrc, sizersrc, subsystem, sizecode, virtualoffsetcode)

	position += WriteSectionHeader(filehandle, ".idata", offsetthunk, virtualoffsetthunk, sizethunk, sizethunk, 0xc0000040)
	position += WriteSectionHeader(filehandle, ".rsrc", offsetrsrc, virtualoffsetrsrc, sizersrc, sizersrc, 0x40000040)
	position += WriteSectionHeader(filehandle, ".pdata", offsetpdata, virtualoffsetpdata, sizepdata, sizepdata, 0x40000040)
	position += WriteSectionHeader(filehandle, ".xdata", offsetxdata, virtualoffsetxdata, sizexdata, sizexdata, 0x40000040)
	position += WriteSectionHeader(filehandle, ".data", offsetstrings, virtualoffsetstrings, sizestrings, sizestrings, 0x40000040)
	position += WriteSectionHeader(filehandle, ".gc", offsetgc, virtualoffsetgc, sizegc, sizegc, 0x40000040)
	position += WriteSectionHeader(filehandle, ".debug", offsetdebug, virtualoffsetdebug, 0x200, 0x200, 0x40000040)
	position += WriteSectionHeader(filehandle, ".global", offsetglobals, virtualoffsetglobals, globaloffsettracker, globaloffsettracker, 0xc0000040)		// TODO - characteristics of .global
	position += WriteSectionHeader(filehandle, ".text", offsetcode, virtualoffsetcode, sizecode, sizecode, 0x60000020)

	print("Writing thunk table...")
	position += WritePadding(filehandle, position, offsetthunk)
	position += WriteThunkTable(filehandle, virtualoffsetthunk)

	print("Writing resources...")
	position += WritePadding(filehandle, position, offsetrsrc)
	position += WriteResources(filehandle, res)

	print("Writing static data...")
	position += WritePadding(filehandle, position, offsetpdata)
	WriteFile(filehandle, pdata, sizepdata, written, 0)
	position += sizepdata
	
	position += WritePadding(filehandle, position, offsetxdata)
	WriteFile(filehandle, xdata, sizexdata, written, 0)
	position += sizexdata

	position += WritePadding(filehandle, position, offsetstrings)
	position += WriteStringTable(filehandle, sizestrings, GlobalStringOffsets)

	position += WritePadding(filehandle, position, offsetgc)
	WriteFile(filehandle, gcdata, sizegc, written, 0)
	position += sizegc

	position += WritePadding(filehandle, position, offsetdebug)

	position += WriteDebugStub(filehandle, "PDBTest.pdb", virtualoffsetdebug, offsetdebug)		// TODO - inherit name of project/.exe

	print("Writing globals...")
	position += WritePadding(filehandle, position, offsetglobals + globaloffsettracker)

	print("Writing code...")
	
	position += WritePadding(filehandle, position, offsetcode)

	WriteFile(filehandle, codebinarybuffer, sizecode, written, 0)
	position += sizecode

	position += WritePadding(filehandle, position, RoundUpFile(position))
	CloseHandle(filehandle)

	print("Emitting CodeView data...")
	WriteFile(objfilehandle, debugsymboldata, sizedebugsymbols, written, 0)
	CloseHandle(objfilehandle)


	Win32Handle cvfilehandle = CreateFile(cvfilename, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0)
	if(cvfilehandle == -1)
	{
		print("Cannot open " ; cvfilename ; " to emit .CV!")
		return()
	}
	WriteFile(cvfilehandle, debugdata, sizedebug, written, 0)
	CloseHandle(cvfilehandle)


	Win32Handle relocfilehandle = CreateFile(relocfilename, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0)
	if(relocfilehandle == -1)
	{
		print("Cannot open " ; relocfilename ; " to emit .RELOC!")
		return()
	}
	WriteFile(relocfilehandle, debugrelocdata, sizedebugreloc, written, 0)
	CloseHandle(relocfilehandle)
	
	
	print("Emitting PDB file...")
	GeneratePDB(pdbfilename, debugdata, sizedebug, virtualoffsetcode, sizecode, debugrelocdata, sizedebugreloc, debugsymboldata, sizedebugsymbols, symbolcount)


	print("Compilation complete.")
}



WriteDebugStub : Win32Handle filehandle, string pdbfilename, integer realaddress, integer fileoffset -> integer writtenbytes = 0
{
	buffer headerbuffer = 512
	integer headersize = 0
	
	ByteStreamEmitInteger(headerbuffer, headersize, 0)			// Characteristics
	ByteStreamEmitInteger(headerbuffer, headersize, 1)			// TimeDateStamp
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// MajorVersion
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// MinorVersion
	ByteStreamEmitInteger(headerbuffer, headersize, 2)			// Type
	ByteStreamEmitInteger(headerbuffer, headersize, 53 + length(pdbfilename))			// SizeOfData
	ByteStreamEmitInteger(headerbuffer, headersize, realaddress + 0x1c)			// AddressOfRawData			// TODO - evil
	ByteStreamEmitInteger(headerbuffer, headersize, fileoffset + 0x1c)			// PointerToRawData			// TODO - evil
	
	ByteStreamEmitInteger(headerbuffer, headersize, 0x53445352)	// "RSDS" signature

	// PDB GUID
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)
	ByteStreamEmitByte(headerbuffer, headersize, 0xf0)

	ByteStreamEmitInteger(headerbuffer, headersize, 1)			// "Age"
	
	
	integer count = 0

	while(count < length(pdbfilename))
	{
		string char = charat(pdbfilename, count)
		ByteStreamEmitSubstring(headerbuffer, headersize, char, 1)

		++count
	}
	
	ByteStreamEmitByte(headerbuffer, headersize, 0)


	integer written = 0
	WriteFile(filehandle, headerbuffer, headersize, written, 0)

	writtenbytes = headersize
}


WriteStringTable : Win32Handle filehandle, integer finalsize, BinaryTreeRoot<integer> ref offsets -> integer writtenbytes = 0
{
	buffer tablebuffer = finalsize + 1

	StringPoolOutputState state = offsets, tablebuffer
	BinaryTreeWalkAllNodesWithParam<string, StringPoolOutputState>(GlobalStringPool.LookupMap.RootNode, CopySingleStringToBuffer, state)

	integer written = 0
	WriteFile(filehandle, state.OutputBuffer, finalsize, written, 0)

	writtenbytes = finalsize
}

WriteThunkTable : Win32Handle filehandle, integer virtualoffsetthunk -> integer writtenbytes = 0
{
	writtenbytes = ThunkTableEmit(filehandle, GlobalThunkTable, virtualoffsetthunk)
}


WritePadding : Win32Handle filehandle, integer startpos, integer desiredpos -> integer writtenbytes = 0
{
	writtenbytes = desiredpos - startpos

    if(writtenbytes < 0)
    {
    	assertmsg(false, "INTERNAL ERROR - attempted to pad negative bytes " ; cast(string, writtenbytes))
	}

	buffer empty = writtenbytes
	integer written = 0
	WriteFile(filehandle, empty, writtenbytes, written, 0)
}


WriteGarbage : Win32Handle filehandle, integer startpos, integer desiredpos -> integer writtenbytes = 0
{
	writtenbytes = desiredpos - startpos

    if(writtenbytes < 0)
    {
    	assertmsg(false, "INTERNAL ERROR - attempted to junk negative bytes " ; cast(string, writtenbytes))
	}

	buffer empty = writtenbytes
	integer i = 0
	while(i < writtenbytes)
	{
		ByteStreamEmitByte(empty, i, 0xc0)
		++i
	}

	integer written = 0
	WriteFile(filehandle, empty, writtenbytes, written, 0)
}


WriteSectionHeader : Win32Handle filehandle, string sectionname, integer location, integer virtuallocation, integer sectionsize, integer sectionvirtualsize, integer flags -> integer writtenbytes = 0
{
	writtenbytes = WriteSectionHeader(filehandle, sectionname, location, virtuallocation, sectionsize, sectionvirtualsize, flags, 0, 0)
}

WriteSectionHeader : Win32Handle filehandle, string sectionname, integer location, integer virtuallocation, integer sectionsize, integer sectionvirtualsize, integer flags, integer relocoffset, integer reloccount -> integer writtenbytes = 0
{
	print("Writing header for section '" ; sectionname ; "'...")

	buffer headerbuffer = 256
	integer headersize = 0

	// This is a pitiful hack.

	integer count = 0
	assert(length(sectionname) < 9)

	while(count < length(sectionname))
	{
		string char = charat(sectionname, count)
		ByteStreamEmitSubstring(headerbuffer, headersize, char, 1)

		++count
	}

	while(count < 8)
	{
		ByteStreamEmitByte(headerbuffer, headersize, 0)
		++count
	}

	// End hack.

	ByteStreamEmitInteger(headerbuffer, headersize, sectionvirtualsize)
	ByteStreamEmitInteger(headerbuffer, headersize, virtuallocation)
	ByteStreamEmitInteger(headerbuffer, headersize, sectionsize)
	ByteStreamEmitInteger(headerbuffer, headersize, location)
	ByteStreamEmitInteger(headerbuffer, headersize, relocoffset)
	ByteStreamEmitInteger(headerbuffer, headersize, 0)
	ByteStreamEmitInteger16From32(headerbuffer, headersize, reloccount)
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)
	ByteStreamEmitInteger(headerbuffer, headersize, flags)

	integer written = 0
	WriteFile(filehandle, headerbuffer, headersize, written, 0)

	writtenbytes = headersize
}



WriteObjSectionHeader : Win32Handle filehandle, string sectionname, integer location, integer virtuallocation, integer sectionsize, integer sectionvirtualsize, integer flags -> integer writtenbytes = 0
{
	writtenbytes = WriteObjSectionHeader(filehandle, sectionname, location, virtuallocation, sectionsize, sectionvirtualsize, flags, 0, 0)
}

WriteObjSectionHeader : Win32Handle filehandle, string sectionname, integer location, integer virtuallocation, integer sectionsize, integer sectionvirtualsize, integer flags, integer relocoffset, integer reloccount -> integer writtenbytes = 0
{
	print("Writing COFF header for section '" ; sectionname ; "'...")

	buffer headerbuffer = 256
	integer headersize = 0

	// This is a pitiful hack.

	integer count = 0
	assert(length(sectionname) < 9)

	while(count < length(sectionname))
	{
		string char = charat(sectionname, count)
		ByteStreamEmitSubstring(headerbuffer, headersize, char, 1)

		++count
	}

	while(count < 8)
	{
		ByteStreamEmitByte(headerbuffer, headersize, 0)
		++count
	}

	// End hack.

	ByteStreamEmitInteger(headerbuffer, headersize, 0) //location)
	ByteStreamEmitInteger(headerbuffer, headersize, 0) //virtuallocation)
	ByteStreamEmitInteger(headerbuffer, headersize, sectionsize)
	ByteStreamEmitInteger(headerbuffer, headersize, location)
	ByteStreamEmitInteger(headerbuffer, headersize, relocoffset)
	ByteStreamEmitInteger(headerbuffer, headersize, 0)
	ByteStreamEmitInteger16From32(headerbuffer, headersize, reloccount)
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)
	ByteStreamEmitInteger(headerbuffer, headersize, flags)

	integer written = 0
	WriteFile(filehandle, headerbuffer, headersize, written, 0)

	writtenbytes = headersize
}



WritePEHeader : Win32Handle filehandle, integer imagesize, integer offsetdebug, integer sizedebug, integer offsetpdata, integer sizepdata, integer offsetxdata, integer sizexdata, integer offsetthunk, integer sizethunk, integer offsetrsrc, integer resourcesize, integer16 subsystem, integer sizecode, integer entrypointaddress -> integer writtenbytes = 0
{
	print("Writing PE headers...")

	buffer headerbuffer = 1024
	integer headersize = 0

	// Begin DOS header
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x5a4d)	// e_magic
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x90)		// e_cblp
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x03)		// e_cp
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_crlc
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x04)		// e_cparhdr
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_minalloc
	ByteStreamEmitInteger16(headerbuffer, headersize, 0xffff)	// e_maxalloc
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_ss
	ByteStreamEmitInteger16(headerbuffer, headersize, 0xb8)		// e_sp
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_csum
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_ip
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_cs
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x40)		// e_lfarlc
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_ovno

	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res[0]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res[1]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res[2]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res[3]

	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_oemid
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_oeminfo

	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[0]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[1]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[2]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[3]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[4]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[5]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[6]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[7]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[8]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[9]

	ByteStreamEmitInteger(headerbuffer, headersize, 0xb0)		// e_lfanew


	// Begin DOS stub
	ByteStreamEmitByte(headerbuffer, headersize, 0x0e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x1f)
	ByteStreamEmitByte(headerbuffer, headersize, 0xba)
	ByteStreamEmitByte(headerbuffer, headersize, 0x0e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x00)
	ByteStreamEmitByte(headerbuffer, headersize, 0xb4)
	ByteStreamEmitByte(headerbuffer, headersize, 0x09)
	ByteStreamEmitByte(headerbuffer, headersize, 0xcd)
	ByteStreamEmitByte(headerbuffer, headersize, 0x21)
	ByteStreamEmitByte(headerbuffer, headersize, 0xb8)
	ByteStreamEmitByte(headerbuffer, headersize, 0x01)
	ByteStreamEmitByte(headerbuffer, headersize, 0x4c)
	ByteStreamEmitByte(headerbuffer, headersize, 0xcd)
	ByteStreamEmitByte(headerbuffer, headersize, 0x21)

	ByteStreamEmitByte(headerbuffer, headersize, 0x54)
	ByteStreamEmitByte(headerbuffer, headersize, 0x68)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x73)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x70)
	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6f)
	ByteStreamEmitByte(headerbuffer, headersize, 0x67)
	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x61)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6d)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)

	ByteStreamEmitByte(headerbuffer, headersize, 0x73)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x66)
	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6f)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6d)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x74)
	ByteStreamEmitByte(headerbuffer, headersize, 0x68)
	ByteStreamEmitByte(headerbuffer, headersize, 0x65)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x66)
	ByteStreamEmitByte(headerbuffer, headersize, 0x75)
	ByteStreamEmitByte(headerbuffer, headersize, 0x74)

	ByteStreamEmitByte(headerbuffer, headersize, 0x75)
	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x65)
	ByteStreamEmitByte(headerbuffer, headersize, 0x2e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x0d)
	ByteStreamEmitByte(headerbuffer, headersize, 0x0a)
	ByteStreamEmitByte(headerbuffer, headersize, 0x49)
	ByteStreamEmitByte(headerbuffer, headersize, 0x74)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x77)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6c)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6c)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)

	ByteStreamEmitByte(headerbuffer, headersize, 0x6e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6f)
	ByteStreamEmitByte(headerbuffer, headersize, 0x74)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x75)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6f)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x79)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6f)
	ByteStreamEmitByte(headerbuffer, headersize, 0x75)

	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x70)
	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6d)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x74)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x76)
	ByteStreamEmitByte(headerbuffer, headersize, 0x65)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x63)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6f)

	ByteStreamEmitByte(headerbuffer, headersize, 0x6d)
	ByteStreamEmitByte(headerbuffer, headersize, 0x70)
	ByteStreamEmitByte(headerbuffer, headersize, 0x75)
	ByteStreamEmitByte(headerbuffer, headersize, 0x74)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x67)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x64)
	ByteStreamEmitByte(headerbuffer, headersize, 0x65)
	ByteStreamEmitByte(headerbuffer, headersize, 0x76)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x63)
	ByteStreamEmitByte(headerbuffer, headersize, 0x65)

	ByteStreamEmitByte(headerbuffer, headersize, 0x2e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x0d)
	ByteStreamEmitByte(headerbuffer, headersize, 0x0a)
	ByteStreamEmitByte(headerbuffer, headersize, 0x24)

	ByteStreamEmitPadding(headerbuffer, headersize, 0xb0)


	// Begin NT headers
	ByteStreamEmitInteger(headerbuffer, headersize, 0x00004550)
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x8664)						// Machine
	ByteStreamEmitInteger16(headerbuffer, headersize, 9)							// NumberOfSections
	ByteStreamEmitInteger(headerbuffer, headersize, 0x00000000)						// TimeDateStamp
	ByteStreamEmitInteger(headerbuffer, headersize, 0)								// PointerToSymbolTable
	ByteStreamEmitInteger(headerbuffer, headersize, 0)								// NumberOfSymbols
	ByteStreamEmitInteger16(headerbuffer, headersize, 0xf0)							// SizeOfOptionalHeader
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x0103)						// Characteristics

	ByteStreamEmitInteger16(headerbuffer, headersize, 0x020b)						// Magic
	ByteStreamEmitByte(headerbuffer, headersize, 0x02)								// MajorLinkerVersion
	ByteStreamEmitByte(headerbuffer, headersize, 0x00)								// MinorLinkerVersion

	ByteStreamEmitInteger(headerbuffer, headersize, RoundUp(sizecode))				// SizeOfCode
	ByteStreamEmitInteger(headerbuffer, headersize, 0x1000)							// SizeOfInitializedData		// TODO - real data section size
	ByteStreamEmitInteger(headerbuffer, headersize, 0)								// SizeOfUninitializedData
	ByteStreamEmitInteger(headerbuffer, headersize, entrypointaddress)				// AddressOfEntryPoint
	ByteStreamEmitInteger(headerbuffer, headersize, 0x1000)							// BaseOfCode

	ByteStreamEmitInteger(headerbuffer, headersize, 0x400000)						// ImageBase
	ByteStreamEmitInteger(headerbuffer, headersize, 0)								// ImageBase upper 32 bits
	ByteStreamEmitInteger(headerbuffer, headersize, 0x1000)							// SectionAlignment
	ByteStreamEmitInteger(headerbuffer, headersize, 0x200)							// FileAlignment

	ByteStreamEmitInteger16(headerbuffer, headersize, 0x04)							// MajorOperatingSystemVersion
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x00)							// MinorOperatingSystemVersion
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)							// MajorImageVersion
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)							// MinorImageVersion
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x04)							// MajorSubsystemVersion
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x00)							// MinorSubsystemVersion

	ByteStreamEmitInteger(headerbuffer, headersize, 0)								// Win32VersionValue
	ByteStreamEmitInteger(headerbuffer, headersize, imagesize)						// SizeOfImage
	ByteStreamEmitInteger(headerbuffer, headersize, 0x400)							// SizeOfHeaders
	ByteStreamEmitInteger(headerbuffer, headersize, 0xf00d)							// Checksum

	ByteStreamEmitInteger16(headerbuffer, headersize, subsystem)					// Subsystem
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)							// DllCharacteristics

	ByteStreamEmitInteger(headerbuffer, headersize, 0x800000)						// SizeOfStackReserve
	ByteStreamEmitInteger(headerbuffer, headersize, 0)							// SizeOfStackReserve upper 32 bits
	ByteStreamEmitInteger(headerbuffer, headersize, 0x80000)						// SizeOfStackCommit
	ByteStreamEmitInteger(headerbuffer, headersize, 0)							// SizeOfStackCommit upper 32 bits
	ByteStreamEmitInteger(headerbuffer, headersize, 0x500000)						// SizeOfHeapReserve
	ByteStreamEmitInteger(headerbuffer, headersize, 0)							// SizeOfHeapReserve upper 32 bits
	ByteStreamEmitInteger(headerbuffer, headersize, 0x50000)						// SizeOfHeapCommit
	ByteStreamEmitInteger(headerbuffer, headersize, 0)							// SizeOfHeapCommit upper 32 bits
	ByteStreamEmitInteger(headerbuffer, headersize, 0)								// LoaderFlags
	ByteStreamEmitInteger(headerbuffer, headersize, 0x10)							// NumberOfRvaAndSizes

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 1
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size
	
	ByteStreamEmitInteger(headerbuffer, headersize, offsetthunk) 		// RVA virtual address 2
	ByteStreamEmitInteger(headerbuffer, headersize, sizethunk)			// Size

	ByteStreamEmitInteger(headerbuffer, headersize, offsetrsrc)			// RVA virtual address 3
	ByteStreamEmitInteger(headerbuffer, headersize, resourcesize)		// Size

	ByteStreamEmitInteger(headerbuffer, headersize, offsetpdata)		// RVA virtual address 4
	ByteStreamEmitInteger(headerbuffer, headersize, sizepdata)			// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 5
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 6
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, offsetdebug)		// RVA virtual address 7
	ByteStreamEmitInteger(headerbuffer, headersize, 0x1c)				// Size of directories array (NOT size of complete section!)

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 8
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 9
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 10
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 11
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 12
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 13
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 14
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 15
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 16
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size


	integer written = 0
	WriteFile(filehandle, headerbuffer, headersize, written, 0)

	writtenbytes = headersize
}


structure StringPoolPreprocessState :
	BinaryTreeRoot<integer> ref Offsets,
	integer CurrentOffset
	
structure StringPoolOutputState :
	BinaryTreeRoot<integer> ref Offsets,
	buffer OutputBuffer

PreprocessStringPool : StringPool ref pool, BinaryTreeRoot<integer> ref outoffsets -> integer totallength = 0
{
	StringPoolPreprocessState state = outoffsets, 0
	BinaryTreeWalkAllNodesWithParam<string, StringPoolPreprocessState>(pool.LookupMap.RootNode, PreprocessSingleString, state)
	
	totallength = state.CurrentOffset
}

PreprocessSingleString : integer handle, string ref strpayload, StringPoolPreprocessState ref state -> boolean ret = true
{
	BinaryTreeCreateOrInsert<integer>(state.Offsets, handle, state.CurrentOffset)
	state.CurrentOffset = state.CurrentOffset + length(strpayload) + 1
}


CopySingleStringToBuffer : integer handle, string ref strpayload, StringPoolOutputState ref state -> boolean ret = true
{
	integer offset = 0
	boolean found = BinaryTreeCopyPayload<integer>(state.Offsets.RootNode, handle, offset)
	if(!found)
	{
		
	}
	
	integer len = length(strpayload)
	integer counter = offset
	
	while(counter < offset + len)
	{
		integer value = subchar(strpayload, counter - offset)
		writebuffer(state.OutputBuffer, counter, (value) & 0xff)
		
		++counter
	}
	
	writebuffer(state.OutputBuffer, counter, 0x00)
}




ThunkTableGetCompleteSize : ThunkTable ref table -> integer totalsize = 0
{
	table.TotalSize = 0
	ThunkTableLibrariesWalkForSize(table.Libraries, table.TotalSize)
	
	integer initialsize = table.TotalSize
	integer namelistsize = table.TotalSize
	ThunkTableLibrariesWalkForAddressHolders(table.Libraries, namelistsize)
	integer addresstablesize = namelistsize - initialsize
	namelistsize += 8
	ThunkTableLibrariesWalkForAddressCopyHolders(table.Libraries, namelistsize)
	
	totalsize = RoundUpFile(namelistsize)
	table.DescriptorOffset = RoundUpFile(namelistsize)
	
	ThunkAddressesWalkLibrariesForOffsets(table.Libraries, totalsize)
	
	table.AddressTableSize = addresstablesize
}

ThunkTableLibrariesWalkForSize : list<ThunkTableLibrary> ref libraries, integer ref startoffset
{
	libraries.value.StartOffset = startoffset
	ThunkTableFunctionsWalkForSize(libraries.value.Functions, startoffset)
	
	libraries.value.NameOffset = startoffset
	
	startoffset += length(libraries.value.LibraryName) + 1				// NULL terminator
	
	ThunkTableLibrariesWalkForSize(libraries.next, startoffset)
}

ThunkTableLibrariesWalkForSize : nothing, integer ref startoffset


ThunkTableFunctionsWalkForSize : list<ThunkTableEntry> ref functions, integer ref startoffset
{
	integer funclength = length(functions.value.FunctionName) + 3		// NULL terminator plus the 16-bit hint word
	functions.value.ThunkTableOffset = startoffset
	
	startoffset += funclength
	
	ThunkTableFunctionsWalkForSize(functions.next, startoffset)
}

ThunkTableFunctionsWalkForSize : nothing, integer ref startoffset


ThunkAddressesWalkLibrariesForOffsets : list<ThunkTableLibrary> ref libraries, integer ref startoffset
{
	startoffset += 20
	ThunkAddressesWalkLibrariesForOffsets(libraries.next, startoffset)
}

ThunkAddressesWalkLibrariesForOffsets : nothing, integer ref startoffset
{
	startoffset += 20			// Final "null" import descriptor
}



ThunkTableLibrariesWalkForAddressHolders : list<ThunkTableLibrary> ref libraries, integer ref offset
{
	ThunkTableFunctionsWalkForAddressHolders(libraries.value.Functions, offset)
	ThunkTableLibrariesWalkForAddressHolders(libraries.next, offset)
}

ThunkTableLibrariesWalkForAddressHolders : nothing, integer ref offset


ThunkTableFunctionsWalkForAddressHolders : list<ThunkTableEntry> ref functions, integer ref offset
{
	functions.value.ThunkAddressOffset = offset
	offset += 8

	ThunkTableFunctionsWalkForAddressHolders(functions.next, offset)
}

ThunkTableFunctionsWalkForAddressHolders : nothing, integer ref offset
{
	offset += 8
}



ThunkTableLibrariesWalkForAddressCopyHolders : list<ThunkTableLibrary> ref libraries, integer ref offset
{
	ThunkTableFunctionsWalkForAddressCopyHolders(libraries.value.Functions, offset)
	ThunkTableLibrariesWalkForAddressCopyHolders(libraries.next, offset)
}

ThunkTableLibrariesWalkForAddressCopyHolders : nothing, integer ref offset


ThunkTableFunctionsWalkForAddressCopyHolders : list<ThunkTableEntry> ref functions, integer ref offset
{
	functions.value.ThunkAddressCopyOffset = offset
	offset += 8

	ThunkTableFunctionsWalkForAddressCopyHolders(functions.next, offset)
}

ThunkTableFunctionsWalkForAddressCopyHolders : nothing, integer ref offset
{
	offset += 8
}



ThunkTableEmit : Win32Handle filehandle, ThunkTable ref table, integer virtualbase -> integer byteswritten = 0
{
	byteswritten += ThunkTableEmitLibraries(filehandle, table.Libraries)
	byteswritten += ThunkTableEmitThunkHolders(filehandle, table.Libraries, virtualbase)
	byteswritten += WritePadding(filehandle, 0, 8)
	byteswritten += ThunkTableEmitThunkHolders(filehandle, table.Libraries, virtualbase)		// Second (copy) holders	
	byteswritten += WritePadding(filehandle, byteswritten, table.DescriptorOffset)
	byteswritten += ThunkTableEmitDescriptors(filehandle, table.Libraries, virtualbase)
}

ThunkTableEmitLibraries : Win32Handle filehandle, list<ThunkTableLibrary> ref libraries -> integer byteswritten = 0
{
	byteswritten += ThunkTableEmitFunctions(filehandle, libraries.value.Functions)
	
	buffer libname = narrowstring(libraries.value.LibraryName)
	integer written = 0
	WriteFile(filehandle, libname, length(libraries.value.LibraryName) + 1, written, 0)
	
	byteswritten += written
	

	byteswritten += ThunkTableEmitLibraries(filehandle, libraries.next)
}

ThunkTableEmitLibraries : Win32Handle filehandle, nothing -> 0


ThunkTableEmitFunctions : Win32Handle filehandle, list<ThunkTableEntry> ref functions -> integer byteswritten = 0
{
	integer zerooffset = 0
	buffer dummy16 = 2
	
	zerooffset = 0
	ByteStreamEmitInteger16(dummy16, zerooffset, 0x0000)
	
	integer written = 0
	WriteFile(filehandle, dummy16, 2, written, 0)
	byteswritten += written
	
	written = 0
	buffer funcname = narrowstring(functions.value.FunctionName)
	WriteFile(filehandle, funcname, length(functions.value.FunctionName) + 1, written, 0)
	byteswritten += written	
	

	byteswritten += ThunkTableEmitFunctions(filehandle, functions.next)
}

ThunkTableEmitFunctions : Win32Handle filehandle, nothing -> integer byteswritten = 0


ThunkTableEmitThunkHolders : Win32Handle filehandle, list<ThunkTableLibrary> ref libraries, integer virtualbase -> integer byteswritten = 0
{
	byteswritten = ThunkTableEmitThunkHoldersPerFunction(filehandle, libraries.value.Functions, virtualbase)

	byteswritten += ThunkTableEmitThunkHolders(filehandle, libraries.next, virtualbase)
}

ThunkTableEmitThunkHolders : Win32Handle filehandle, nothing, integer virtualbase -> 0


ThunkTableEmitThunkHoldersPerFunction : Win32Handle filehandle, list<ThunkTableEntry> ref functions, integer virtualbase -> integer byteswritten = 0
{
	buffer thunkbuffer = 16
	integer thunksize = 0
	
	ByteStreamEmitInteger(thunkbuffer, thunksize, functions.value.ThunkTableOffset + virtualbase)
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)

	integer written = 0
	WriteFile(filehandle, thunkbuffer, thunksize, written, 0)
	
	byteswritten = written
	byteswritten += ThunkTableEmitThunkHoldersPerFunction(filehandle, functions.next, virtualbase)
}

ThunkTableEmitThunkHoldersPerFunction : Win32Handle filehandle, nothing, integer virtualbase -> integer byteswritten = 0
{
	byteswritten += WritePadding(filehandle, 0, 8)
}



ThunkTableEmitDescriptors : Win32Handle filehandle, list<ThunkTableLibrary> ref libraries, integer virtualbase -> integer byteswritten = 0
{
	buffer thunkbuffer = 128
	integer thunksize = 0
		
	ByteStreamEmitInteger(thunkbuffer, thunksize, virtualbase + ThunkTableGetLibFirstThunkOffset(libraries.value))
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	ByteStreamEmitInteger(thunkbuffer, thunksize, virtualbase + libraries.value.NameOffset)
	ByteStreamEmitInteger(thunkbuffer, thunksize, virtualbase + ThunkTableGetLibFirstThunkCopyOffset(libraries.value))	
	
	integer written = 0
	WriteFile(filehandle, thunkbuffer, thunksize, written, 0)

	byteswritten = thunksize
	

	byteswritten += ThunkTableEmitDescriptors(filehandle, libraries.next, virtualbase)
}

ThunkTableEmitDescriptors : Win32Handle filehandle, nothing, integer virtualbase -> integer byteswritten = 0
{
	buffer thunkbuffer = 128
	integer thunksize = 0
	
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	
	integer written = 0
	WriteFile(filehandle, thunkbuffer, thunksize, written, 0)

	byteswritten = thunksize
}


ThunkTableGetLibFirstThunkOffset : ThunkTableLibrary ref lib -> integer offset = ThunkTableEntryGetFirstThunkOffset(lib.Functions)
ThunkTableEntryGetFirstThunkOffset : list<ThunkTableEntry> ref functions -> integer offset = functions.value.ThunkAddressOffset

ThunkTableGetLibFirstThunkCopyOffset : ThunkTableLibrary ref lib -> integer offset = ThunkTableEntryGetFirstThunkCopyOffset(lib.Functions)
ThunkTableEntryGetFirstThunkCopyOffset : list<ThunkTableEntry> ref functions -> integer offset = functions.value.ThunkAddressCopyOffset



ThunkLookupMapper : string funcname -> integer thunkoffset = 0
{
	// TODO - don't hard code base address
	integer baseaddress = 0x401000
	integer baseaddressglobals = 0x408000
	
	thunkoffset = baseaddress + SearchThunkTableForFunctionOffset(GlobalThunkTable.Libraries, funcname)
	
	if(thunkoffset < baseaddress)
	{
		integer pooledhandle = PoolString(funcname)
		GlobalMetadata meta = 0, 0, 0
		boolean found = BinaryTreeCopyPayload<GlobalMetadata>(LLVMGlobalVariables.RootNode, pooledhandle, meta)
		if(found)
		{
			thunkoffset = baseaddressglobals + meta.Offset
		}
		else
		{
			print("WARNING: unknown thunk " ; funcname)
			thunkoffset = 0
		}
	}
}

SearchThunkTableForFunctionOffset : list<ThunkTableLibrary> ref libraries, string funcname -> integer offset = -1
{
	offset = SearchThunkLibForFunctionOffset(libraries.value.Functions, funcname)
	if(offset < 0)
	{
		offset = SearchThunkTableForFunctionOffset(libraries.next, funcname)
	}
}

SearchThunkTableForFunctionOffset : nothing, string funcname -> integer offset = -1

SearchThunkLibForFunctionOffset : list<ThunkTableEntry> ref functions, string funcname -> integer offset = -1
{
	if(functions.value.FunctionName == funcname)
	{
		offset = functions.value.ThunkAddressCopyOffset
	}
	else
	{
		offset = SearchThunkLibForFunctionOffset(functions.next, funcname)
	}
}

SearchThunkLibForFunctionOffset : nothing, string funcname -> integer offset = -1


StringLookupMapper : integer stringhandle -> integer offset = 0
{
	// TODO - don't hard code base address
	integer baseaddress = 0x405000
	
	BinaryTreeCopyPayload<integer>(GlobalStringOffsets.RootNode, stringhandle, offset)
	
	offset += baseaddress
}



ThunkTableAddEntry : ThunkTable ref table, string libname, string funcname
{
	ThunkTableAddFunctionToLibrary(table, table.Libraries, libname, funcname)
}

ThunkTableAddFunctionToLibrary : ThunkTable ref table, list<ThunkTableLibrary> ref libraries, string libname, string funcname
{
	if(libraries.value.LibraryName == libname)
	{
		ThunkTableAddFunctionToList(libraries.value, libraries.value.Functions, funcname)
	}
	else
	{
		ThunkTableAddFunctionToLibrary(table, libraries.next, libname, funcname)
	}
}

ThunkTableAddFunctionToLibrary : ThunkTable ref table, nothing, string libname, string funcname
{
	ThunkTableEntry entry = funcname, 0, 0, 0
	list<ThunkTableEntry> entrylist = entry, nothing
	listnode<ThunkTableEntry> entrynode = entrylist
	
	ThunkTableLibrary rtlib = libname, entrynode, 0, 0
	ListPrependOrCreate<ThunkTableLibrary>(table.Libraries, rtlib)
}

ThunkTableAddFunctionToList : ThunkTableLibrary ref library, list<ThunkTableEntry> ref functions, string funcname
{
	if(functions.value.FunctionName == funcname)
	{
		// Function already exists, can bail safely
	}
	else
	{
		ThunkTableAddFunctionToList(library, functions.next, funcname)
	}
}

ThunkTableAddFunctionToList : ThunkTableLibrary ref library, nothing, string funcname
{
	ThunkTableEntry entry = funcname, 0, 0, 0
	ListPrependOrCreate<ThunkTableEntry>(library.Functions, entry)
}



GeneratePDB : string pdbfilename, buffer ref symboldata, integer symbolsize, integer codesectionstart, integer codesize, buffer ref relocdata, integer relocsize, buffer ref symbollist, integer symbollistbytes, integer symbolcount
{
	CodeViewLinePair dummypair = -1, -1
	list<CodeViewLinePair> pairlist = dummypair, nothing

	CodeViewLineInfoRaw lineinforaw = 0, 0, 0, 0, 0, 0
	CodeViewLineInfo lineinfo = lineinforaw, pairlist
	list<CodeViewLineInfo> lines = lineinfo, nothing
	
	SymbolSection sectionsymbol = 9, 0, codesize, 0x60000020, ".text"	
	list<PDBSymbol> symbollistinternal = sectionsymbol, nothing

	//SymbolBlockEnd sectionend = 0
	//PDBSymbol sectionendsymbol = sectionend
	//append<PDBSymbol>(symbollistinternal, sectionendsymbol)

	SectionContribution initsc = 9, 0, 65, 0x60001020, 0, 0, 0
	list<SectionContribution> contriblist = initsc, nothing
	
	TransferSymbols(symbollistinternal, symboldata, symbolsize, relocdata, relocsize, symbollist, contriblist, lines)
	
	print("First canary")

	DBIModule testmodule = "D:\Test.epoch", "D:\Test.obj", 0, symbollistinternal, contriblist
	
	ComputeSymbolSize(testmodule)
	
	list<DBIModule> modulelist = testmodule, nothing
	
	integer dbimodinfolen = 64 + length(testmodule.SourceFile) + 1 + length(testmodule.ObjectFile) + 1
	while((dbimodinfolen & 3) != 0)
	{
		++dbimodinfolen
	}

	integer sectionmapsize = 9 * 20 + 4 // TODO - dynamic section map
	integer dbicontribslen = 4 + (28 * 4)		// TODO - compute dynamic contributions length (don't forget version signature +4)
	integer dbifileslen = 32			// TODO - real data here
	integer dbilineslen = 0 //48		// TODO - dynamic lines
	
	DBISection dbisection = dbimodinfolen, dbicontribslen, sectionmapsize, modulelist, lines

	print("Pre-stream setup canary")
	
	PDBStream directoryhint = simplelist<integer>(3, nothing), 0
	PDBStream directorystream = simplelist<integer>(4, nothing), 84		// + (128 * 4)
	
	PDBStream msf = simplelist<integer>(5, nothing), 1					// Placeholder; 0 is invalid but we have nothing to put here
	PDBStream pdb = simplelist<integer>(6, nothing), 128  				// TODO - pull real PDB stream size [was 48]
	PDBStream tpi = simplelist<integer>(7, nothing), 56					// TODO - real TPI stream
	PDBStream dbi = simplelist<integer>(8, nothing), 64 + dbimodinfolen + dbicontribslen + sectionmapsize + dbilineslen + dbifileslen // TODO - real DBI stream
	PDBStream ipi = simplelist<integer>(9, nothing), 56					// TODO - real IPI stream (?)
	PDBStream globals = simplelist<integer>(10, nothing), 44 + 516		// TODO - real globals stream
	PDBStream publics = simplelist<integer>(11, nothing), 44 + 516		// TODO - real publics stream
	PDBStream symbols = simplelist<integer>(12, nothing), 28			// TODO - real symbol records size
	
	simplelist<integer> hackblocks = 13, nothing

	PDBStream hackstream = hackblocks, testmodule.SymbolSize + 8 + 168	// TODO - real stream
	list<PDBStream> hackstreamlist = hackstream, nothing
	
	simplelist<integer> stringblocks = 14, nothing
	PDBStream stringstream = stringblocks, 28							// TODO - real stream
	append<PDBStream>(hackstreamlist, stringstream)
	
	PDBDirectory pdbdir = 10, msf, pdb, tpi, dbi, ipi, globals, publics, symbols, hackstreamlist

	
	Win32Handle invalidhandle = -1
	PDBFileLayout layout = 1024, 15, directoryhint, directorystream, pdbdir
	PDBOutputStream stream = pdbfilename, invalidhandle, 0, layout, dbisection

	print("Final canary before we write PDB")

	WritePDB(stream, codesectionstart, codesize, symbollist, symbollistbytes)
}

