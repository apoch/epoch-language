
structure ThunkTableEntry :
	string FunctionName,
	integer ThunkTableOffset,
	integer ThunkAddressOffset,
	integer ThunkAddressCopyOffset

structure ThunkTableLibrary :
	string LibraryName,
	listnode<ThunkTableEntry> Functions,
	integer StartOffset,
	integer NameOffset

structure ThunkTable :
	listnode<ThunkTableLibrary> Libraries,
	integer DescriptorOffset,
	integer TotalSize,
	integer AddressTableSize
	


global
{
	integer foo = add(40, 2)


	StringPool GlobalStringPool =
		BinaryTreeRoot<string>(nothing),
		Trie(0, nothing, 0),
		0


	ThunkTable GlobalThunkTable = nothing, 0, 0, 0

}



structure StringPool :
	BinaryTreeRoot<string> LookupMap,
	Trie LookupTrie,
	integer CurrentStringHandle



add : integer a, integer b -> a + b


type simplelistnode<type T> : simplelist<T> | nothing

structure simplelist<type T> :
	T value,
	simplelistnode<T> next


type listnode<type T> : list<T> | nothing

structure list<type T> :
	T ref value,
	listnode<T> next


entrypoint :
{
	if(foo == 42)
	{
		print("Happy!")
	}
	else
	{
		print("Sad.")
	}

	simplelist<string> test = "foo", nothing
	simple_append<string>(test, "bar")
	simple_append<string>(test, "baz")


	StringTableRegisterString(1, "+")
	StringTableRegisterString(2, "-")
	StringTableRegisterString(3, "*")

	ThunkTableAddEntry(GlobalThunkTable, "Kernel32.dll", "ExitProcess")
	ThunkTableAddEntry(GlobalThunkTable, "Kernel32.dll", "lstrlenA")
	ThunkTableAddEntry(GlobalThunkTable, "EpochRT.dll", "ERT_assert")
	ThunkTableAddEntry(GlobalThunkTable, "EpochRT.dll", "ERT_buffer_alloc")


	print("Done")
}





simple_append<type T> : simplelist<T> ref thelist, T value
{
	simple_append_recurse<T>(thelist, thelist.next, value)
}

simple_append_recurse<type T> : simplelist<T> ref thelist, nothing, T value
{
	simplelist<T> newlist = new value, nothing
	thelist.next = newlist
}

simple_append_recurse<type T> : simplelist<T> ref thelist, simplelist<T> ref tail, T value
{
	simple_append_recurse<T>(tail, tail.next, value)
}




//
// Structure representing a node in a trie
//
// Each node has an associated character value, an associated
// integer handle, and an optional list of child nodes that
// represent subsequent characters in other key strings.
//

structure Trie :
	integer Character,
	listnode<Trie> Children,
	integer Handle


//
// Store a string-integer mapping in a given trie structure
//
// Expected to run in O(n) time in n characters in the key string.
//
// May allocate up to n nodes to store the appropriate data within
// the trie itself.
//
PlaceDataInTrie : Trie ref trie, string data, integer handle
{
	integer datalen = length(data)
	if(datalen == 0)
	{
		trie.Handle = handle
		return()
	}

	PlaceDataInTrieChild(trie.Children, trie, subchar(data, 0), data, 1, datalen, handle)
}

PlaceDataInTrieRecurse : Trie ref trie, string data, integer offset, integer datalen, integer handle
{
	if(datalen == offset)
	{
		trie.Handle = handle
		return()
	}

	PlaceDataInTrieChild(trie.Children, trie, subchar(data, offset), data, offset + 1, datalen, handle)
}

PlaceDataInTrieChild : list<Trie> ref children, Trie ref originaltrie, integer character, string alldata, integer offset, integer datalen, integer handle
{
	if(children.value.Character == character)
	{
		PlaceDataInTrieRecurse(children.value, alldata, offset, datalen, handle)
	}
	else
	{
		PlaceDataInTrieChild(children.next, originaltrie, character, alldata, offset, datalen, handle)
	}
}

PlaceDataInTrieChild : nothing, Trie ref originaltrie, integer character, string alldata, integer offset, integer datalen, integer handle
{
	Trie newtrie = new character, nothing, 0
	PlaceDataInTrieRecurse(newtrie, alldata, offset, datalen, handle)

	list<Trie> newtrielist = new newtrie, originaltrie.Children
	originaltrie.Children = newtrielist
}


//
// Given a string key, retrieve the mapped integer value from a trie.
//
// Expected to run in O(n) time for n characters in the key.
// Must not allocate memory.
//
FindHandleInTrie : Trie ref trie, string data -> integer handle = 0
{
	if(length(data) == 0)
	{
		handle = trie.Handle
		return()
	}

	handle = FindHandleInTrieChildren(trie.Children, subchar(data, 0), data, 1, length(data))
}

FindHandleInTrieChildren : list<Trie> ref triechildren, integer character, string alldata, integer offset, integer datalength -> integer handle = 0
{
	if(triechildren.value.Character == character)
	{
		if(datalength == offset)
		{
			handle = triechildren.value.Handle
			return()
		}

		handle = FindHandleInTrieChildren(triechildren.value.Children, subchar(alldata, offset), alldata, offset + 1, datalength)
		return()
	}

	handle = FindHandleInTrieChildren(triechildren.next, character, alldata, offset, datalength)
}

FindHandleInTrieChildren : nothing, integer character, string alldata, integer offset, integer datalength -> integer handle = 0



StringTableRegisterString : integer handle, string contents
{
	BinaryTreeCreateOrInsert<string>(GlobalStringPool.LookupMap, handle, contents)
	PlaceDataInTrie(GlobalStringPool.LookupTrie, contents, handle)
}





type BinaryTreeNode<type T> : BinaryTree<T> | nothing

structure BTPayloadWrap<type T> :
	T ref Payload

structure BinaryTree<type T> :
	integer Value,
	BTPayloadWrap<T> Payload,
	BinaryTreeNode<T> Left,
	BinaryTreeNode<T> Right,
	integer Height
	
structure BinaryTreeRoot<type T> :
	BinaryTreeNode<T> RootNode
	
	
BinaryTreeCreateOrInsert<type T> : BinaryTreeRoot<T> ref root, integer value, T ref payload
{
	if(!InsertIntoBinaryTree<T>(root.RootNode, value, payload))
	{
		BTPayloadWrap<T> wrap = payload
		BinaryTree<T> newtree = new value, wrap, nothing, nothing, 0
		root.RootNode = newtree
	}
}


InsertIntoBinaryTree<type T> : BinaryTree<T> ref tree, integer value, T ref payload -> boolean ret = true
{
	if(tree.Value > value)
	{
		if(!InsertIntoBinaryTree<T>(tree.Left, value, payload))
		{
			BTPayloadWrap<T> wrap = payload
			BinaryTree<T> newtree = new value, wrap, nothing, nothing, 0
			tree.Left = newtree
		}
	}
	elseif(tree.Value < value)
	{
		if(!InsertIntoBinaryTree<T>(tree.Right, value, payload))
		{
			BTPayloadWrap<T> wrap = payload
			BinaryTree<T> newtree = new value, wrap, nothing, nothing, 0
			tree.Right = newtree
		}
	}
	else
	{
		return()
	}

	integer balance = ComputeBalance<T>(tree)
	if(balance > 1)
	{
		tree.Height = RecomputeTreeDepth<T>(tree)
		if(ComputeBalance<T>(tree.Left) > 0)
		{
			RotateLL<T>(tree)
		}
		else
		{
			RotateLR<T>(tree)
		}
	}
	elseif(balance < -1)
	{
		tree.Height = RecomputeTreeDepth<T>(tree)
		if(ComputeBalance<T>(tree.Right) < 0)
		{
			RotateRR<T>(tree)
		}
		else
		{
			RotateRL<T>(tree)
		}
	}
}

InsertIntoBinaryTree<type T> : nothing, integer value, T ref payload -> boolean ret = false

RotateLL<type T> : BinaryTree<T> ref tree
{
	BinaryTreeNode<T> temp = tree.Right
	tree.Right = tree.Left
	tree.Left = GetLeft<T>(tree.Right)

	BinaryTreeNode<T> newnode = GetRight<T>(tree.Right)
	SetNodeLeft<T>(tree.Right, newnode)
	SetNodeRight<T>(tree.Right, temp)

	integer tempvalue = tree.Value
	tree.Value = GetNodeValue<T>(tree.Right)
	SetNodeValue<T>(tree.Right, tempvalue)

	SwapNodePayload<T>(tree, tree.Right)

	SetHeight<T>(tree.Right, RecomputeTreeDepth<T>(tree.Right))
	tree.Height = RecomputeTreeDepth<T>(tree)
}

GetLeft<type T> : BinaryTree<T> ref tree -> BinaryTreeNode<T> ret = tree.Left
GetLeft<type T> : nothing -> BinaryTreeNode<T> ret = nothing

GetRight<type T> : BinaryTree<T> ref tree -> BinaryTreeNode<T> ret = tree.Right
GetRight<type T> : nothing -> BinaryTreeNode<T> ret = nothing

SetNodeLeft<type T> : BinaryTree<T> ref tree, BinaryTreeNode<T> newleft
{
	tree.Left = newleft
}

SetNodeRight<type T> : BinaryTree<T> ref tree, BinaryTreeNode<T> newright
{
	tree.Right = newright
}

RotateRR<type T> : BinaryTree<T> ref tree
{
	BinaryTreeNode<T> temp = tree.Left
	tree.Left = tree.Right
	tree.Right = GetRight<T>(tree.Left)

	BinaryTreeNode<T> newnode = GetLeft<T>(tree.Left)
	SetNodeRight<T>(tree.Left, newnode)
	SetNodeLeft<T>(tree.Left, temp)

	integer tempvalue = tree.Value
	tree.Value = GetNodeValue<T>(tree.Left)
	SetNodeValue<T>(tree.Left, tempvalue)

	SwapNodePayload<T>(tree, tree.Left)

	SetHeight<T>(tree.Left, RecomputeTreeDepth<T>(tree.Left))
	tree.Height = RecomputeTreeDepth<T>(tree)
}

RotateLR<type T> : BinaryTree<T> ref tree
{
	RotateRR<T>(tree.Left)
	RotateLL<T>(tree)
}

RotateRL<type T> : BinaryTree<T> ref tree
{
	RotateLL<T>(tree.Right)
	RotateRR<T>(tree)
}


TreeDepth<type T> : BinaryTree<T> ref tree -> integer depth = tree.Height
TreeDepth<type T> : nothing -> 0


HasNode<type T> : BinaryTree<T> ref tree -> true
HasNode<type T> : nothing -> false

ComputeBalance<type T> : BinaryTree<T> ref tree -> integer balance = 0
{
	integer leftdepth = TreeDepth<T>(tree.Left)
	integer rightdepth = TreeDepth<T>(tree.Right)

	balance = leftdepth - rightdepth
}

ComputeBalance<type T> : nothing -> 0


RecomputeTreeDepth<type T> : BinaryTree<T> ref tree -> integer depth = 1
{
	integer ldepth = TreeDepth<T>(tree.Left)
	integer rdepth = TreeDepth<T>(tree.Right)

	if(ldepth > rdepth)
	{
		depth += ldepth
	}
	else
	{
		depth += rdepth
	}
}

SetHeight<type T> : BinaryTree<T> ref tree, integer newheight
{
	tree.Height = newheight
}


SearchBinaryTree<type T> : BinaryTree<T> ref tree, integer target -> boolean found = false
{
	if(tree.Value == target)
	{
		found = true
		return()
	}
	elseif(target < tree.Value)
	{
		found = SearchBinaryTree<T>(tree.Left, target)
	}
	else
	{
		found = SearchBinaryTree<T>(tree.Right, target)
	}
}

SearchBinaryTree<type T> : nothing, integer target -> boolean found = false


SearchBinaryTreeForPayload<type T> : BinaryTree<T> ref tree, integer target, ContextNode<T> ref out -> boolean found = false
{
	if(tree.Value == target)
	{
		found = true
		ContextNode<T> outwrap = tree.Payload.Payload
		out = outwrap
		return()
	}
	elseif(target < tree.Value)
	{
		found = SearchBinaryTreeForPayload<T>(tree.Left, target, out)
	}
	else
	{
		found = SearchBinaryTreeForPayload<T>(tree.Right, target, out)
	}
}

SearchBinaryTreeForPayload<type T> : nothing, integer target, ContextNode<T> ref out -> boolean found = false


BinaryTreeCopyPayload<type T> : BinaryTree<T> ref tree, integer target, T ref out -> boolean found = false
{
	if(tree.Value == target)
	{
		found = true
		out = tree.Payload.Payload
		return()
	}
	elseif(target < tree.Value)
	{
		found = BinaryTreeCopyPayload<T>(tree.Left, target, out)
	}
	else
	{
		found = BinaryTreeCopyPayload<T>(tree.Right, target, out)
	}
}

BinaryTreeCopyPayload<type T> : nothing, integer target, T ref out -> boolean found = false



GetNodeValue<type T> : BinaryTree<T> ref node -> integer ret = node.Value

SetNodeValue<type T> : BinaryTree<T> ref node, integer value
{
	node.Value = value
}

SwapNodePayload<type T> : BinaryTree<T> ref a, BinaryTree<T> ref b
{
	BTPayloadWrap<T> p = a.Payload.Payload
	a.Payload = b.Payload
	b.Payload = p
}



BinaryTreeWalkAllNodes<type T> : BinaryTree<T> ref tree, (func : integer, T ref -> boolean) -> boolean ret = true
{
	if(!func(tree.Value, tree.Payload.Payload))
	{
		ret = false
	}

	if(!BinaryTreeWalkAllNodes<T>(tree.Left, func))
	{
		ret = false
	}

	if(!BinaryTreeWalkAllNodes<T>(tree.Right, func))
	{
		ret = false
	}
}

BinaryTreeWalkAllNodes<type T> : nothing, (func : integer, T ref -> boolean) -> boolean ret = true



BinaryTreeWalkAllNodesWithParam<type T, type ParamT> : BinaryTree<T> ref tree, (func : integer, T ref, ParamT ref -> boolean), ParamT ref param -> boolean ret = true
{
	if(!func(tree.Value, tree.Payload.Payload, param))
	{
		ret = false
	}

	if(!BinaryTreeWalkAllNodesWithParam<T, ParamT>(tree.Left, func, param))
	{
		ret = false
	}

	if(!BinaryTreeWalkAllNodesWithParam<T, ParamT>(tree.Right, func, param))
	{
		ret = false
	}
}

BinaryTreeWalkAllNodesWithParam<type T, type ParamT> : nothing, (func : integer, T ref, ParamT ref -> boolean), ParamT ref param -> boolean ret = true



ListPrependOrCreate<type T> : listnode<T> ref node, T ref value
{
	list<T> newlist = new value, node
	listnode<T> wrap = newlist
	node = wrap
}


ThunkTableAddEntry : ThunkTable ref table, string libname, string funcname
{
	ThunkTableAddFunctionToLibrary(table, table.Libraries, libname, funcname)
}

ThunkTableAddFunctionToLibrary : ThunkTable ref table, list<ThunkTableLibrary> ref libraries, string libname, string funcname
{
	if(libraries.value.LibraryName == libname)
	{
		ThunkTableAddFunctionToList(libraries.value, libraries.value.Functions, funcname)
	}
	else
	{
		ThunkTableAddFunctionToLibrary(table, libraries.next, libname, funcname)
	}
}

ThunkTableAddFunctionToLibrary : ThunkTable ref table, nothing, string libname, string funcname
{
	ThunkTableEntry entry = new funcname, 0, 0, 0
	list<ThunkTableEntry> entrylist = new entry, nothing
	listnode<ThunkTableEntry> entrynode = entrylist
	
	ThunkTableLibrary rtlib = new libname, entrynode, 0, 0
	ListPrependOrCreate<ThunkTableLibrary>(table.Libraries, rtlib)
}

ThunkTableAddFunctionToList : ThunkTableLibrary ref library, list<ThunkTableEntry> ref functions, string funcname
{
	if(functions.value.FunctionName == funcname)
	{
		// Function already exists, can bail safely
	}
	else
	{
		ThunkTableAddFunctionToList(library, functions.next, funcname)
	}
}

ThunkTableAddFunctionToList : ThunkTableLibrary ref library, nothing, string funcname
{
	ThunkTableEntry entry = new funcname, 0, 0, 0
	ListPrependOrCreate<ThunkTableEntry>(library.Functions, entry)
}



