# Overview #

Since Release 10, Epoch has been compiled to an intermediate bytecode representation. Until Release 14 this representation was executed by a virtual machine, but in more recent iterations of the language runtime, the VM has been completely removed and the bytecode is JIT compiled to native code via LLVM. In future iterations, JIT compilation to other types of hardware is planned.

One of the fundamental building blocks of this architecture is the _entity system_. Rather than define things like functions, flow control primitives, and execution context selectors within the language specification itself, we provide a rich framework wherein each of the above concepts is expressed in terms of _entities_.

An entity at its core is simply a mapping of some (optional) parameters onto an (optional) return value, via the execution of a block of code. This definition is flexible and general enough to fully encompass functions as well as flow control primitives as generally seen in imperative and functional programming languages. Moreover, entities can define things like lexical closures, directives to the compiler or runtime environment, and execution context selectors.


# Dynamic Parsing #

One of the central technologies enabling the flexibility and configurability of Epoch's entity system is a modifiable parser, which is "taught" how to recognize various types of entity by the standard library implementation at compile time.

This approach permits the compiler to remain generalized and unaware of specific control flow primitives and other directives; the entity implementation is capable of emitting correct code for each type of entity in isolation from the compiler itself. As of Release 14, this code generation occurs during the JIT compilation phase on program load.


# Functions as Entities #

The most general form of an entity permits the mapping of input values onto output values, as well as the execution of a sequence of code to accomplish that mapping. Note that there is not necessarily a requirement for the executed code to perform its work by the means of side effects; this means that entities are fundamentally agnostic of the difference between imperative-style and purely functional-style programming. As an interesting corollary to this property, we can _tag_ an entity (usually a function) as being imperative or purely functional, which can aid in performing certain types of automatic compile-time or even run-time optimizations.

Functions are in fact the only type of entity with direct support within the core implementation of the Epoch language; all remaining entity types are implemented via the standard library. The rationale for this decision is largely pragmatic (i.e. it was necessary to bootstrap the entity system in this manner for optimal productivity) but includes the distinct benefit that the core compiler and JIT code generator are capable of some special optimizations for making function calls as efficient as possible.

Like any other entity, a function entity is permitted to have no return value, in which case it is referred to as a _void function_ or more generally a _void entity_. Functions are fairly unique in that their signatures are configurable at compile time, i.e. the programmer can specify his own sets of parameters and return values for each individual function. This flexibility is another motivating factor for implementing functions as a special type of entity within the toolchain.


# Flow Control Primitives #

In the Epoch architecture, all flow control primitives are expressed in terms of entities. This means that conditionals, loops, exception handling, continuations, and closures are all implemented via the entity system in one form or another. Moreover, since these are specified in the standard library versus the core language itself, it is possible for the programmer to selectively choose which flow control options to use for writing a given piece of software.

Conditionals and loops are implemented as void entities with attached meta-control code. This code is generated by the JIT engine whenever the entity is encountered in code instruction stream. By separating the meta-control code from the actual compiled bytecode stream, we can allow entities to perform rich behavior to influence the execution of the attached Epoch code block.

For instance, `foreach` style loops can be implemented trivially in the Epoch framework by setting up the meta-control code to select each value in the range being iterated over, construct an internal variable referring to the value in question, and repeatedly invoking the attached Epoch code block until no elements remain in the range. Additionally, the flexibility afforded by the dynamic parser allows the implementer of such a looping construct to specify his own syntax for the construct itself, thereby making the code feel as natural and expressive as possible without influencing the base specification of the language itself.


# Execution Context Selectors #

Due to the implementation of entities, it is possible to use entities themselves to accomplish things like preprocessing directives, or runtime directives for controlling where and how code is executed. For instance an entity could be configured to selectively offload code execution onto alternative hardware execution units such as a GPU, or to intelligently fork worker threads to execute the code itself, and so on.

Given Epoch's heavy emphasis on efficient parallel computing, this architecture offers a massive advantage over other technologies. Any library for the language can define its own entities and even its own syntactic extensions to the language, meaning that adding support for new computation models is radically simplified over other languages. A library is sufficient for such experimental models, versus having to completely build in support for the execution model to the core language itself.


# Conclusion #

By retaining a minimalist core to the Epoch language and defining virtually all of its features in terms of entity extensions, we can provide a powerful platform upon which to construct a truly unlimited range of software solutions. Moreover, we can guarantee a minimum of effort to explore new computation or processing models within the Epoch framework itself, making the language ideal for ongoing research into parallel processing and concurrent techniques in general.

Thanks to the dynamic parser and the open-endedness of the entity definition itself, Epoch is poised to provide a remarkably configurable foundation for software engineering of all kinds.