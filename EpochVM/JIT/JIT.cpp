//
// The Epoch Language Project
// EPOCHVM Virtual Machine
//
// Just-in-time native code generation for Epoch
//
// The Epoch JIT engine is basically a thin translation layer that converts Epoch bytecode
// into LLVM bitcode instructions. Once the applicable conversions have been made, including
// relevant transformations of operations into SSA form (insofar as we can do that here),
// the LLVM bitcode is optimized and converted to native machine code on the fly. This occurs
// during the image load process prior to the execution of the Epoch entrypoint task.
//
// We rely extremely heavily on certain LLVM optimization passes to make efficient code out
// of our comparatively sloppy Epoch bytecode. There are also a large number of redundant
// operations and other expensive processing performed in the Epoch VM which can be converted
// to faster forms or even eliminated entirely post-LLVM optimizations. As such, it is the
// general case that we do not bother doing much optimization of Epoch bytecode. As it stands,
// Epoch bytecode is a high-level and expressive form which is easy to emit from the compiler.
// LLVM bitcode can be generated relatively easily from this form, and the resulting bitcode
// can be optimized into very efficient machine code without any additional effort from us.
//
// Low-level optimizations are almost entirely handled as well as can be expected by LLVM.
// For the time being, the primary means of improving native machine code generated by an
// Epoch program is to observe LLVM's behavior when handed the sorts of idioms that Epoch
// bytecode tends to generate. We can tweak the optimization pass order and sequence at the
// JIT layer, which gives us a powerful way to ensure that LLVM can cleanly produce machine
// code from our inputs, and yet does not necessitate writing custom passes or doing any
// specific magic at a higher level.
//
// That said, the potential for adding high-level algorithmic type optimizations to the
// Epoch compiler is considerable. Given the type system richness of Epoch (especially as
// compared to LLVM) and the general high availability of metadata in the Epoch bytecode
// stream, it should be practical to annotate the LLVM bitcode in certain ways which further
// improve that layer's ability to generate optimal machine code.
//

#include "pch.h"

#include "Bytecode/Instructions.h"

#include "Libraries/Library.h"

#include "Virtual Machine/VirtualMachine.h"
#include "Virtual Machine/Marshaling.h"

#include "Metadata/ScopeDescription.h"
#include "Metadata/TypeInfo.h"

#include "Utility/Strings.h"

#include <llvm/Intrinsics.h>
#include <llvm/Support/CrashRecoveryContext.h>
#include <llvm/Transforms/Vectorize.h>

#pragma warning(push)
#pragma warning(disable: 4146)
#include <llvm/ADT/Statistic.h>
#pragma warning(pop)

#include <sstream>
#include <map>
#include <stack>


// We heavily use this namespace so may as well import it
using namespace llvm;



//
// Internal implementation helpers
//
namespace JIT
{
	namespace impl
	{

		//
		// The JIT operations maintain a lot of state and other data
		// which is useful to sort and centralize in some manner. We
		// collect a large part of this data in the following struct
		// in order to share state between assorted JIT helper code.
		//
		struct LLVMData
		{
			LLVMData();

			LLVMContext& Context;

			Module* CurrentModule;

			Type* VMTypeIDType;
			Type* VMBufferHandleType;
			Type* VMStructureHandleType;
			Type* VMNothingType;
			
			std::map<JITFunctionID, Function*> BuiltInFunctions;

			std::map<std::string, Function*> GeneratedFunctions;
			std::map<std::string, Function*> GeneratedNativeTypeMatchers;
			std::map<StringHandle, Function*> GeneratedNameToFunctionMap;

			std::map<Metadata::EpochTypeID, StructType*> SumTypeCache;

			std::map<size_t, Value*> GlobalVariableMap;
			std::map<size_t, size_t> GlobalVariableOffsetToIndexMap;
			std::map<StringHandle, size_t> GlobalVariableNameToIndexMap;

			Function* EntryPoint;
			Function* GlobalInit;

		// Non-copyable
		private:
			LLVMData(const LLVMData&);
			LLVMData& operator = (const LLVMData&);
		};

		//
		// Yet more JIT state is maintained on a per-function level.
		// This helper class holds that state during the JIT process
		// for each individual function for which we generate native
		// code. It also provides organized implementations of logic
		// for handling various Epoch bytecode instructions.
		//
		class FunctionJITHelper
		{
		// Construction
		public:
			explicit FunctionJITHelper(NativeCodeGenerator& generator);

		// Non-copyable
		private:
			FunctionJITHelper(const FunctionJITHelper&);
			FunctionJITHelper& operator = (const FunctionJITHelper&);

		// Function JIT interface
		public:
			void DoFunction(size_t beginoffset, size_t endoffset, StringHandle alias);

		// Global init JIT interface
		public:
			void DoGlobalInit(size_t beginoffset);

		// Instruction handlers
		private:
			void BeginEntity(size_t& offset);
			void EndEntity(size_t& offset);

			void BeginChain(size_t& offset);
			void EndChain(size_t& offset);

			void Read(size_t& offset);
			void ReadStackLocal(size_t& offset);
			void ReadParameter(size_t& offset);

			void BindReference(size_t& offset);
			void ReadRef(size_t& offset);
			void ReadRefAnnotated(size_t& offset);

			void Assign(size_t& offset);
			void AssignSumType(size_t& offset);
			void ConstructSumType(size_t& offset);

			void SetRetValue(size_t& offset);
			void Return(size_t& offset);
			void Halt(size_t& offset);

			void Push(size_t& offset);
			void Pop(size_t& offset);

			void AllocStructure(size_t& offset);
			void CopyToStructure(size_t& offset);
			void CopyStructure(size_t& offset);
			void BindMemberRef(size_t& offset);

			void Invoke(size_t& offset);
			void InvokeOffset(size_t& offset);
			void InvokeNative(size_t& offset);
			void InvokeIndirect(size_t& offset);

			void TypeMatch(size_t& offset);
			void PatternMatch(size_t& offset);

			void CopyBuffer(size_t& offset);

		// Internal tracking
		private:
			NativeCodeGenerator& Generator;
			const Bytecode::Instruction* Bytecode;

			IRBuilder<>& Builder;
			LLVMContext& Context;

			JITContext LibJITContext;

			BasicBlock* InnerExitBlock;
			BasicBlock* NativeMatchBlock;
			BasicBlock* PatternMatchBlock;

			size_t BeginOffset;
			size_t EndOffset;

			const ScopeDescription* CurrentScope;

			unsigned NumParameters;
			unsigned NumParameterBytes;
			unsigned NumReturns;

			Metadata::EpochTypeID HackStructType;		// TODO - clean this up

			std::stack<Metadata::EpochTypeID> TypeAnnotations;
			std::map<size_t, size_t> LocalOffsetToIndexMap;
			std::map<size_t, size_t> ParameterOffsetToIndexMap;

			typedef void (FunctionJITHelper::* InstructionJITHelper)(size_t& offset);
			std::map<Bytecode::Instruction, InstructionJITHelper> InstructionJITHelpers;
		};

		//
		// Construct and initialize an LLVM data wrapper object
		//
		LLVMData::LLVMData() :
			Context(getGlobalContext())
		{
			CurrentModule = new Module("EpochJIT", Context);

			VMTypeIDType = Type::getInt32Ty(Context);
			VMBufferHandleType = Type::getInt32Ty(Context);
			VMStructureHandleType = Type::getInt8PtrTy(Context);
			VMNothingType = Type::getInt32Ty(Context);

			// Set up various VM interop functions
			{
				FunctionType* ftype = FunctionType::get(Type::getVoidTy(Context), false);
				BuiltInFunctions[JITFunc_VM_Break] = Function::Create(ftype, Function::ExternalLinkage, "VMBreak", CurrentModule);
			}

			{
				FunctionType* ftype = FunctionType::get(Type::getVoidTy(Context), false);
				BuiltInFunctions[JITFunc_VM_Halt] = Function::Create(ftype, Function::ExternalLinkage, "VMHalt", CurrentModule);
			}

			{
				std::vector<Type*> args;
				args.push_back(VMTypeIDType);
				FunctionType* ftype = FunctionType::get(VMStructureHandleType, args, false);

				BuiltInFunctions[JITFunc_VM_AllocStruct] = Function::Create(ftype, Function::ExternalLinkage, "VMAllocStruct", CurrentModule);
			}

			{
				std::vector<Type*> args;
				args.push_back(VMStructureHandleType);
				FunctionType* ftype = FunctionType::get(VMStructureHandleType, args, false);

				BuiltInFunctions[JITFunc_VM_CopyStruct] = Function::Create(ftype, Function::ExternalLinkage, "VMCopyStruct", CurrentModule);
			}

			{
				std::vector<Type*> args;
				args.push_back(VMBufferHandleType);
				FunctionType* ftype = FunctionType::get(Type::getInt8PtrTy(Context), args, false);

				BuiltInFunctions[JITFunc_VM_GetBuffer] = Function::Create(ftype, Function::ExternalLinkage, "VMGetBuffer", CurrentModule);
			}

			{
				std::vector<Type*> args;
				args.push_back(Type::getInt32Ty(Context));
				FunctionType* ftype = FunctionType::get(Type::getInt8PtrTy(Context), args, false);

				BuiltInFunctions[JITFunc_VM_GetString] = Function::Create(ftype, Function::ExternalLinkage, "VMGetString", CurrentModule);
			}

			{
				std::vector<Type*> args;
				args.push_back(Type::getInt32Ty(Context));
				FunctionType* ftype = FunctionType::get(Type::getInt32Ty(Context), args, false);

				BuiltInFunctions[JITFunc_VM_AllocBuffer] = Function::Create(ftype, Function::ExternalLinkage, "VMAllocBuffer", CurrentModule);
			}

			{
				std::vector<Type*> args;
				args.push_back(Type::getInt32Ty(Context));
				FunctionType* ftype = FunctionType::get(Type::getInt32Ty(Context), args, false);

				BuiltInFunctions[JITFunc_VM_CopyBuffer] = Function::Create(ftype, Function::ExternalLinkage, "VMCopyBuffer", CurrentModule);
			}

			{
				std::vector<Type*> args;
				args.push_back(Type::getInt8PtrTy(Context));
				FunctionType* ftype = FunctionType::get(Type::getInt8PtrTy(Context), args, false);

				BuiltInFunctions[JITFunc_Marshal_ConvertStructure] = Function::Create(ftype, Function::ExternalLinkage, "MarshalConvertStructure", CurrentModule);
			}

			{
				std::vector<Type*> args;
				args.push_back(Type::getInt8PtrTy(Context));
				args.push_back(Type::getInt8PtrTy(Context));
				FunctionType* ftype = FunctionType::get(Type::getVoidTy(Context), args, false);

				BuiltInFunctions[JITFunc_Marshal_FixupStructure] = Function::Create(ftype, Function::ExternalLinkage, "MarshalFixupStructure", CurrentModule);
			}

			{
				std::vector<Type*> args;
				args.push_back(Type::getInt8PtrTy(Context));
				FunctionType* ftype = FunctionType::get(Type::getVoidTy(Context), args, false);

				BuiltInFunctions[JITFunc_Marshal_Cleanup] = Function::Create(ftype, Function::ExternalLinkage, "MarshalCleanup", CurrentModule);
			}

			// Set up intrinsics
			{
				std::vector<Type*> args;
				args.push_back(Type::getFloatTy(Context));
				FunctionType* ftype = FunctionType::get(Type::getFloatTy(Context), args, false);
				BuiltInFunctions[JITFunc_Intrinsic_Sqrt] = Function::Create(ftype, Function::ExternalLinkage, "llvm.sqrt.f32", CurrentModule);
			}

			{
				std::vector<Type*> args;
				args.push_back(Type::getInt8PtrTy(Context));
				FunctionType* ftype = FunctionType::get(Type::getVoidTy(Context), args, false);
				BuiltInFunctions[JITFunc_Intrinsic_VAStart] = Function::Create(ftype, Function::ExternalLinkage, "llvm.va_start", CurrentModule);
			}
			{
				std::vector<Type*> args;
				args.push_back(Type::getInt8PtrTy(Context));
				FunctionType* ftype = FunctionType::get(Type::getVoidTy(Context), args, false);
				BuiltInFunctions[JITFunc_Intrinsic_VAEnd] = Function::Create(ftype, Function::ExternalLinkage, "llvm.va_end", CurrentModule);
			}
		}

	}
}


//
// Additional internal helpers
//
namespace
{

	template <typename T>
	T Fetch(const Bytecode::Instruction* bytecode, size_t& InstructionOffset)
	{
		const T* data = reinterpret_cast<const T*>(&bytecode[InstructionOffset]);
		InstructionOffset += sizeof(T);
		return static_cast<T>(*data);
	}

}


// Namespace shortcuts
using namespace JIT;
using namespace JIT::impl;


//
// Construct and initialize a native code generation wrapper
//
NativeCodeGenerator::NativeCodeGenerator(VM::VirtualMachine& ownervm, const Bytecode::Instruction* bytecode)
	: OwnerVM(ownervm),
	  Bytecode(bytecode),
	  Data(new LLVMData),
	  Builder(Data->Context)
{
	InitializeNativeTarget();
}

//
// Destruct and clean up a native code generation wrapper
//
NativeCodeGenerator::~NativeCodeGenerator()
{
	delete Data;
}


//
// Retrieve (or create if necessary) a generated function
//
Function* NativeCodeGenerator::GetGeneratedFunction(StringHandle funcname, size_t beginoffset)
{
	std::ostringstream name;
	name << "JITFuncInner_" << beginoffset;

	Function* targetinnerfunc = NULL;
	FunctionType* targetinnerfunctype = GetLLVMFunctionType(funcname);
	if(!Data->GeneratedFunctions[name.str()])
	{
		targetinnerfunc = Function::Create(targetinnerfunctype, Function::ExternalLinkage, name.str().c_str(), Data->CurrentModule);
		Data->GeneratedFunctions[name.str()] = targetinnerfunc;
	}
	else
		targetinnerfunc = Data->GeneratedFunctions[name.str()];

	return targetinnerfunc;
}

//
// Retrieve (or create if necessary) a generated type matcher
//
Function* NativeCodeGenerator::GetGeneratedTypeMatcher(StringHandle funcname, size_t beginoffset)
{
	std::ostringstream matchername;
	matchername << "JITMatcher_" << beginoffset;

	Function* nativetypematcher = Data->GeneratedNativeTypeMatchers[matchername.str()];
	if(!nativetypematcher)
	{
		std::vector<Type*> matchargtypes;
		for(size_t i = 0; i < OwnerVM.TypeMatcherParamCount.find(funcname)->second; ++i)
		{
			matchargtypes.push_back(Data->VMTypeIDType);					// type annotation
			matchargtypes.push_back(Type::getInt8PtrTy(Data->Context));		// pointer to payload
		}

		Type* retty = Type::getVoidTy(Data->Context);
		if(OwnerVM.TypeMatcherRetType.find(funcname)->second != Metadata::EpochType_Error)
			retty = GetLLVMType(OwnerVM.TypeMatcherRetType.find(funcname)->second);
		FunctionType* matchfunctype = FunctionType::get(retty, matchargtypes, false);

		nativetypematcher = Function::Create(matchfunctype, Function::ExternalLinkage, matchername.str().c_str(), Data->CurrentModule);
		Data->GeneratedNativeTypeMatchers[matchername.str()] = nativetypematcher;
	}

	return nativetypematcher;
}

//
// Retrieve (or create if necessary) a generated pattern matcher
//
Function* NativeCodeGenerator::GetGeneratedPatternMatcher(StringHandle funcname, size_t beginoffset)
{
	std::ostringstream matchername;
	matchername << "JITMatcher_" << beginoffset;

	Function* nativematcher = Data->GeneratedNativeTypeMatchers[matchername.str()];
	if(!nativematcher)
	{
		StringHandle hint = OwnerVM.PatternMatcherDispatchHint.find(funcname)->second;
		FunctionType* matchfunctype = GetLLVMFunctionType(hint);

		nativematcher = Function::Create(matchfunctype, Function::ExternalLinkage, matchername.str().c_str(), Data->CurrentModule);
		Data->GeneratedNativeTypeMatchers[matchername.str()] = nativematcher;
	}

	return nativematcher;
}

//
// Retrieve (or create if necessary) a generated global initializer
//
Function* NativeCodeGenerator::GetGeneratedGlobalInit(StringHandle entityname)
{
	std::ostringstream name;
	name << "GlobalEntry_" << entityname;

	Function* targetinnerfunc = NULL;
	FunctionType* targetinnerfunctype = FunctionType::get(Type::getVoidTy(Data->Context), false);
	if(!Data->GeneratedFunctions[name.str()])
	{
		targetinnerfunc = Function::Create(targetinnerfunctype, Function::ExternalLinkage, name.str().c_str(), Data->CurrentModule);
		Data->GeneratedFunctions[name.str()] = targetinnerfunc;
	}
	else
		targetinnerfunc = Data->GeneratedFunctions[name.str()];

	return targetinnerfunc;
}

//
// Map Epoch types to LLVM types
//
Type* NativeCodeGenerator::GetLLVMType(Metadata::EpochTypeID type, bool flatten)
{
	Metadata::EpochTypeFamily family = Metadata::GetTypeFamily(type);
	switch(type)
	{
	case Metadata::EpochType_Void:
		return Type::getVoidTy(Data->Context);

	case Metadata::EpochType_Integer:
	case Metadata::EpochType_String:
	case Metadata::EpochType_Buffer:
		return Type::getInt32Ty(Data->Context);

	case Metadata::EpochType_Real:
		return Type::getFloatTy(Data->Context);

	case Metadata::EpochType_Boolean:
		return Type::getInt1Ty(Data->Context);

	case Metadata::EpochType_Integer16:
		return Type::getInt16Ty(Data->Context);

	case Metadata::EpochType_Identifier:
		// STUPID LAME HACK - we only use Identifier params for constructors, so assume this is an aggregate constructor param
		return Data->VMStructureHandleType;

	default:
		if(family == Metadata::EpochTypeFamily_Function)
			return GetLLVMFunctionTypeFromEpochType(type)->getPointerTo();

		if(family == Metadata::EpochTypeFamily_SumType)
			return GetLLVMSumType(type, flatten);

		if(family == Metadata::EpochTypeFamily_Structure || family == Metadata::EpochTypeFamily_TemplateInstance)
			return Data->VMStructureHandleType;

		throw NotImplementedException("Unsupported type for native code generation");
	}
}

//
// Map Epoch types to LLVM types suitable for C-ABI function invocation
//
Type* NativeCodeGenerator::GetExternalType(Metadata::EpochTypeID type)
{
	Metadata::EpochTypeFamily family = Metadata::GetTypeFamily(type);
	switch(type)
	{
	case Metadata::EpochType_Void:
		return Type::getVoidTy(Data->Context);

	case Metadata::EpochType_Integer:
		return Type::getInt32Ty(Data->Context);

	case Metadata::EpochType_String:
	case Metadata::EpochType_Buffer:
		return Type::getInt8PtrTy(Data->Context);

	case Metadata::EpochType_Real:
		return Type::getFloatTy(Data->Context);

	case Metadata::EpochType_Boolean:
		return Type::getInt32Ty(Data->Context);

	case Metadata::EpochType_Integer16:
		return Type::getInt16Ty(Data->Context);

	default:
		if(family == Metadata::EpochTypeFamily_Structure || family == Metadata::EpochTypeFamily_TemplateInstance)
			return Data->VMStructureHandleType;

		if(family == Metadata::EpochTypeFamily_Function)
			return Type::getInt8PtrTy(Data->Context);

		throw NotImplementedException("Unsupported type for marshaling to external functions");
	}
}


//
// Create tagged structures to hold Epoch unions in LLVM structs
//
// Since LLVM does not support unions, we need to fake this by creating
// a field of the largest necesary bit width and doing a lot of pointer
// casting when reading/writing the union payload.
//
Type* NativeCodeGenerator::GetLLVMSumType(Metadata::EpochTypeID type, bool flatten)
{
	StructType* taggedtype = Data->SumTypeCache[type];
	if(!taggedtype && !flatten)
	{
		const VariantDefinition& def = OwnerVM.VariantDefinitions.find(type)->second;
		const std::set<Metadata::EpochTypeID>& types = def.GetBaseTypes();

		Type* rettype = NULL;
		size_t maxsize = 0;

		for(std::set<Metadata::EpochTypeID>::const_iterator iter = types.begin(); iter != types.end(); ++iter)
		{
			size_t size = Metadata::GetStorageSize(*iter);
			if(size > maxsize)
			{
				maxsize = size;
				rettype = GetLLVMType(*iter, true);
			}
		}

		if(flatten)
			return rettype;

		std::ostringstream name;
		name << "SumTypeTag_" << type;

		std::vector<Type*> elemtypes;
		elemtypes.push_back(Data->VMTypeIDType);
		elemtypes.push_back(rettype);
		taggedtype = StructType::create(elemtypes, name.str());
		Data->SumTypeCache[type] = taggedtype;
	}

	return taggedtype;
}

//
// Synthesize the LLVM function type signature for a given Epoch function
//
FunctionType* NativeCodeGenerator::GetLLVMFunctionType(StringHandle epochfunc)
{
	bool hassumtypeparam = false;
	bool isautogenconstructor = (OwnerVM.AutoGeneratedConstructors.count(epochfunc) > 0);
	Type* rettype = Type::getVoidTy(Data->Context);

	if(OwnerVM.PatternMatcherParamCount.find(epochfunc) != OwnerVM.PatternMatcherParamCount.end())
		epochfunc = OwnerVM.PatternMatcherDispatchHint[epochfunc];

	std::vector<Type*> args;

	const ScopeDescription& scope = OwnerVM.GetScopeDescription(epochfunc);
	for(size_t i = 0; i < scope.GetVariableCount(); ++i)
	{
		if(scope.GetVariableOrigin(i) == VARIABLE_ORIGIN_PARAMETER)
		{
			Metadata::EpochTypeID vartype = scope.GetVariableTypeByIndex(i);

			if(vartype == Metadata::EpochType_Nothing)
			{
				args.push_back(Data->VMNothingType);
			}
			else
			{
				Type* type = GetLLVMType(vartype);
				if(scope.IsReference(i))
					args.push_back(type->getPointerTo());
				else
					args.push_back(type);

				if(Metadata::GetTypeFamily(vartype) == Metadata::EpochTypeFamily_SumType)
					hassumtypeparam = true;
			}
		}
		else if(scope.GetVariableOrigin(i) == VARIABLE_ORIGIN_RETURN)
			rettype = GetLLVMType(scope.GetVariableTypeByIndex(i));
	}

	if(hassumtypeparam && isautogenconstructor)
		return FunctionType::get(rettype, std::vector<Type*>(), true);
	
	return FunctionType::get(rettype, args, false);
}

//
// Synthesize the LLVM function type signature for a given external C-ABI function
//
FunctionType* NativeCodeGenerator::GetExternalFunctionType(StringHandle epochfunc)
{
	Type* rettype = Type::getVoidTy(Data->Context);

	std::vector<Type*> args;

	const ScopeDescription& scope = OwnerVM.GetScopeDescription(epochfunc);
	for(size_t i = 0; i < scope.GetVariableCount(); ++i)
	{
		if(scope.GetVariableOrigin(i) == VARIABLE_ORIGIN_PARAMETER)
		{
			Metadata::EpochTypeID vartype = scope.GetVariableTypeByIndex(i);
			args.push_back(GetExternalType(vartype));
		}
		else if(scope.GetVariableOrigin(i) == VARIABLE_ORIGIN_RETURN)
			rettype = GetExternalType(scope.GetVariableTypeByIndex(i));
	}

	return FunctionType::get(rettype, args, false);
}

//
// Synthesize the LLVM function type signature for a given library function
//
llvm::FunctionType* NativeCodeGenerator::GetLLVMFunctionTypeFromSignature(StringHandle libraryfunc)
{
	FunctionSignatureSet::const_iterator iter = OwnerVM.LibraryFunctionSignatures.find(libraryfunc);
	if(iter == OwnerVM.LibraryFunctionSignatures.end())
		throw FatalException("Invalid library function");

	return GetLLVMFunctionTypeFromSignature(iter->second);
}

llvm::FunctionType* NativeCodeGenerator::GetLLVMFunctionTypeFromSignature(const FunctionSignature& sig)
{
	Type* rettype = GetLLVMType(sig.GetReturnType());

	std::vector<Type*> args;
	for(size_t i = 0; i < sig.GetNumParameters(); ++i)
	{
		const CompileTimeParameter& param = sig.GetParameter(i);
		if(param.HasPayload)
			continue;

		Type* argtype = GetLLVMType(param.Type);
		if(param.IsReference)
			argtype = argtype->getPointerTo();

		args.push_back(argtype);
	}

	return FunctionType::get(rettype, args, false);
}

llvm::FunctionType* NativeCodeGenerator::GetLLVMFunctionTypeFromEpochType(Metadata::EpochTypeID type)
{
	return GetLLVMFunctionTypeFromSignature(OwnerVM.GetFunctionSignatureByType(type));
}

//
// Add a standard Epoch function implementation to the JIT module
//
void NativeCodeGenerator::AddFunction(size_t beginoffset, size_t endoffset, StringHandle alias)
{
	FunctionJITHelper jithelper(*this);
	jithelper.DoFunction(beginoffset, endoffset, alias);
}

//
// Add a global initialization entity to the JIT module
//
void NativeCodeGenerator::AddGlobalEntity(size_t beginoffset)
{
	FunctionJITHelper jithelper(*this);
	jithelper.DoGlobalInit(beginoffset);
}

EPOCHVM void NativeCodeGenerator::ExternalInvoke(JIT::JITContext& context, StringHandle alias)
{
	Function* func = GetExternalFunction(alias);

	Function::arg_iterator argiter = context.InnerFunction->arg_begin();
	std::vector<Value*> args;

	Metadata::EpochTypeID rettype = Metadata::EpochType_Void;

	const ScopeDescription& scope = OwnerVM.GetScopeDescription(alias);
	for(size_t i = 0; i < scope.GetVariableCount(); ++i)
	{
		if(scope.GetVariableOrigin(i) == VARIABLE_ORIGIN_PARAMETER)
		{
			Value* arg = (Argument*)(argiter);
			if(scope.IsReference(i))
				arg = Builder.CreateLoad(arg);

			Metadata::EpochTypeID vartype = scope.GetVariableTypeByIndex(i);
			args.push_back(MarshalArgument(arg, vartype));
			++argiter;
		}
		else if(scope.GetVariableOrigin(i) == VARIABLE_ORIGIN_RETURN)
			rettype = scope.GetVariableTypeByIndex(i);
	}

	CallInst* ret = Builder.CreateCall(func, args);
	ret->setCallingConv(func->getCallingConv());
	if(func->getFunctionType()->getReturnType() != Type::getVoidTy(Data->Context))
		Builder.CreateStore(MarshalReturn(ret, rettype), context.InnerRetVal);

	size_t index = 0;
	for(size_t i = 0; i < scope.GetVariableCount(); ++i)
	{
		if(scope.GetVariableOrigin(i) == VARIABLE_ORIGIN_PARAMETER)
		{
			Metadata::EpochTypeID vartype = scope.GetVariableTypeByIndex(i);
			if(scope.IsReference(i))
				MarshalReferencePostCall(args[index], context.VariableMap[i], vartype);

			MarshalCleanup(args[index], vartype);

			++index;
		}
	}
}

//
// Optimize LLVM bitcode and generate final native machine code
//
void NativeCodeGenerator::Generate()
{
	for(std::map<Value*, Function*>::const_iterator iter = GeneratedCallbackWrappers.begin(); iter != GeneratedCallbackWrappers.end(); ++iter)
	{
		BasicBlock* block = BasicBlock::Create(Data->Context, "wrap", iter->second);
		Builder.SetInsertPoint(block);

		std::vector<Value*> args;
		Function::arg_iterator argiter = iter->second->arg_begin();
		for(size_t i = 0; i < iter->second->getFunctionType()->getNumParams(); ++i)
		{
			args.push_back((Argument*)(argiter));
			++argiter;
		}

		if(iter->second->getFunctionType()->getReturnType() == Type::getVoidTy(Data->Context))
		{
			Builder.CreateCall(iter->first, args);
			Builder.CreateRetVoid();
		}
		else
			Builder.CreateRet(Builder.CreateCall(Builder.CreateLoad(iter->first), args));
	}

	// This dump can come in handy if verification fails or we otherwise
	// need to check up on the bitcode being generated by the JIT engine
	//Data->CurrentModule->dump();

	// Always verify - it is useful for catching JIT bugs
	verifyModule(*Data->CurrentModule, AbortProcessAction);

#ifdef _DEBUG
	//EnableStatistics();
#endif

	std::string ErrStr;

	TargetOptions opts;
	opts.AllowFPOpFusion = FPOpFusion::Standard;
	opts.DisableTailCalls = false;
	opts.EnableFastISel = false;
	opts.EnableSegmentedStacks = false;
	opts.GuaranteedTailCallOpt = true;

	// Turning off frame pointer elimination can make debugging a LOT smoother...
	opts.NoFramePointerElim = false;
	opts.NoFramePointerElimNonLeaf = false;

	EngineBuilder eb(Data->CurrentModule);
	eb.setEngineKind(EngineKind::JIT);
	eb.setErrorStr(&ErrStr);
	eb.setRelocationModel(Reloc::Default);
	eb.setCodeModel(CodeModel::JITDefault);
	eb.setAllocateGVsWithCode(true);
	eb.setOptLevel(CodeGenOpt::Aggressive);
	eb.setTargetOptions(opts);

	TargetMachine* machine = eb.selectTarget();

	ExecutionEngine* ee = EngineBuilder(Data->CurrentModule).setErrorStr(&ErrStr).create(machine);
	if(!ee)
		return;
	
	FunctionPassManager fpm(Data->CurrentModule);

	fpm.add(new DataLayout(*ee->getDataLayout()));
	fpm.add(createTypeBasedAliasAnalysisPass());
	fpm.add(createBasicAliasAnalysisPass());
	fpm.add(createCFGSimplificationPass());
	fpm.add(createScalarReplAggregatesPass());
	fpm.add(createEarlyCSEPass());
	fpm.add(createLowerExpectIntrinsicPass());

	VectorizeConfig vcfg;
	vcfg.ReqChainDepth = 2;
	vcfg.MaxIter = 500;
	fpm.add(createBBVectorizePass(vcfg));

	fpm.doInitialization();

	for(std::map<std::string, Function*>::const_iterator iter = Data->GeneratedFunctions.begin(); iter != Data->GeneratedFunctions.end(); ++iter)
		fpm.run(*iter->second);

	PassManager mpm;
	mpm.add(new DataLayout(*ee->getDataLayout()));
	mpm.add(createTypeBasedAliasAnalysisPass());
	mpm.add(createBasicAliasAnalysisPass());
	mpm.add(createGlobalOptimizerPass());
	mpm.add(createPromoteMemoryToRegisterPass());
	mpm.add(createIPSCCPPass());
	mpm.add(createDeadArgEliminationPass());
	mpm.add(createInstructionCombiningPass());
	mpm.add(createCFGSimplificationPass());
	mpm.add(createPruneEHPass());
	mpm.add(createFunctionAttrsPass());
	mpm.add(createFunctionInliningPass());
	mpm.add(createArgumentPromotionPass());
	mpm.add(createScalarReplAggregatesPass(-1, false));
	mpm.add(createEarlyCSEPass());
	mpm.add(createSimplifyLibCallsPass());
	mpm.add(createJumpThreadingPass());
	mpm.add(createCorrelatedValuePropagationPass());
	mpm.add(createCFGSimplificationPass());
	mpm.add(createInstructionCombiningPass());
	mpm.add(createTailCallEliminationPass());
	mpm.add(createCFGSimplificationPass());
	mpm.add(createReassociatePass());
	mpm.add(createLoopRotatePass());
	mpm.add(createLICMPass());
	mpm.add(createLoopUnswitchPass(false));
	mpm.add(createInstructionCombiningPass());
	mpm.add(createIndVarSimplifyPass());
	mpm.add(createLoopIdiomPass());
	mpm.add(createLoopDeletionPass());
	mpm.add(createLoopUnrollPass());
	mpm.add(createGVNPass());
	mpm.add(createMemCpyOptPass());
	mpm.add(createSCCPPass());
	mpm.add(createInstructionCombiningPass());
	mpm.add(createJumpThreadingPass());
	mpm.add(createCorrelatedValuePropagationPass());
	mpm.add(createDeadStoreEliminationPass());
	mpm.add(createAggressiveDCEPass());
	mpm.add(createCFGSimplificationPass());
	mpm.add(createInstructionCombiningPass());
	mpm.add(createFunctionInliningPass());

	mpm.run(*Data->CurrentModule);

	// This dump is useful for observing the optimized LLVM bitcode
	//Data->CurrentModule->dump();

	VM::PopulateWeakLinkages(ExternalFunctions, ee);

	// Perform actual native code generation and link the created
	// pages of machine code back to the VM for execution
	for(std::map<std::string, Function*>::const_iterator iter = Data->GeneratedFunctions.begin(); iter != Data->GeneratedFunctions.end(); ++iter)
	{
		void* p = ee->getPointerToFunction(iter->second);
		if(iter->second == Data->EntryPoint)
			OwnerVM.EntryPointFunc = p;
		else if(iter->second == Data->GlobalInit)
			OwnerVM.GlobalInitFunc = p;
	}

	// This is a no-op unless we enabled stats above
	// The numbers are very handy for A/B testing optimization passes
	PrintStatistics();
}

Function* NativeCodeGenerator::GetExternalFunction(StringHandle alias)
{
	Function* func = ExternalFunctions[alias];
	if(!func)
	{
		const VM::DLLInvocationInfo& invokeinfo = VM::GetMarshaledExternalFunction(alias);
		std::string name = narrow(invokeinfo.DLLName) + "_" + narrow(invokeinfo.FunctionName);

		FunctionType* ftype = GetExternalFunctionType(alias);
		func = Function::Create(ftype, GlobalValue::ExternalWeakLinkage, name, Data->CurrentModule);

		if(invokeinfo.CallingConvention == L"stdcall")
			func->setCallingConv(CallingConv::X86_StdCall);

		ExternalFunctions[alias] = func;
	}

	return func;
}



//
// Construct and initialize a function JIT helper object
//
FunctionJITHelper::FunctionJITHelper(NativeCodeGenerator& generator)
	: Generator(generator),
	  Builder(generator.Builder),
	  Context(generator.Data->Context),
	  Bytecode(generator.Bytecode)
{
	InstructionJITHelpers[Bytecode::Instructions::BeginEntity] = &FunctionJITHelper::BeginEntity;
	InstructionJITHelpers[Bytecode::Instructions::EndEntity] = &FunctionJITHelper::EndEntity;

	InstructionJITHelpers[Bytecode::Instructions::BeginChain] = &FunctionJITHelper::BeginChain;
	InstructionJITHelpers[Bytecode::Instructions::EndChain] = &FunctionJITHelper::EndChain;

	InstructionJITHelpers[Bytecode::Instructions::Read] = &FunctionJITHelper::Read;
	InstructionJITHelpers[Bytecode::Instructions::ReadStack] = &FunctionJITHelper::ReadStackLocal;
	InstructionJITHelpers[Bytecode::Instructions::ReadParam] = &FunctionJITHelper::ReadParameter;

	InstructionJITHelpers[Bytecode::Instructions::BindRef] = &FunctionJITHelper::BindReference;
	InstructionJITHelpers[Bytecode::Instructions::ReadRef] = &FunctionJITHelper::ReadRef;
	InstructionJITHelpers[Bytecode::Instructions::ReadRefAnnotated] = &FunctionJITHelper::ReadRefAnnotated;

	InstructionJITHelpers[Bytecode::Instructions::Assign] = &FunctionJITHelper::Assign;
	InstructionJITHelpers[Bytecode::Instructions::AssignSumType] = &FunctionJITHelper::AssignSumType;
	InstructionJITHelpers[Bytecode::Instructions::ConstructSumType] = &FunctionJITHelper::ConstructSumType;

	InstructionJITHelpers[Bytecode::Instructions::SetRetVal] = &FunctionJITHelper::SetRetValue;
	InstructionJITHelpers[Bytecode::Instructions::Return] = &FunctionJITHelper::Return;
	InstructionJITHelpers[Bytecode::Instructions::Halt] = &FunctionJITHelper::Halt;

	InstructionJITHelpers[Bytecode::Instructions::Push] = &FunctionJITHelper::Push;
	InstructionJITHelpers[Bytecode::Instructions::Pop] = &FunctionJITHelper::Pop;

	InstructionJITHelpers[Bytecode::Instructions::AllocStructure] = &FunctionJITHelper::AllocStructure;
	InstructionJITHelpers[Bytecode::Instructions::CopyToStructure] = &FunctionJITHelper::CopyToStructure;
	InstructionJITHelpers[Bytecode::Instructions::CopyStructure] = &FunctionJITHelper::CopyStructure;
	InstructionJITHelpers[Bytecode::Instructions::BindMemberRef] = &FunctionJITHelper::BindMemberRef;

	InstructionJITHelpers[Bytecode::Instructions::Invoke] = &FunctionJITHelper::Invoke;
	InstructionJITHelpers[Bytecode::Instructions::InvokeOffset] = &FunctionJITHelper::InvokeOffset;
	InstructionJITHelpers[Bytecode::Instructions::InvokeNative] = &FunctionJITHelper::InvokeNative;
	InstructionJITHelpers[Bytecode::Instructions::InvokeIndirect] = &FunctionJITHelper::InvokeIndirect;

	InstructionJITHelpers[Bytecode::Instructions::TypeMatch] = &FunctionJITHelper::TypeMatch;
	InstructionJITHelpers[Bytecode::Instructions::PatternMatch] = &FunctionJITHelper::PatternMatch;

	InstructionJITHelpers[Bytecode::Instructions::CopyBuffer] = &FunctionJITHelper::CopyBuffer;
}


//
// JIT a function
//
void FunctionJITHelper::DoFunction(size_t beginoffset, size_t endoffset, StringHandle alias)
{
	// Set up context for external libraries that we need to interact with
	// TODO - clean up JITContext a bit
	LibJITContext.Builder = &Builder;
	LibJITContext.Context = &Context;
	LibJITContext.MyModule = Generator.Data->CurrentModule;
	LibJITContext.InnerFunction = NULL;
	LibJITContext.VarArgList = NULL;
	LibJITContext.Generator = &Generator;
	LibJITContext.FunctionAlias = alias;

	LibJITContext.BuiltInFunctions = &Generator.Data->BuiltInFunctions;

	// Merge in globals
	for(std::map<StringHandle, size_t>::const_iterator iter = Generator.Data->GlobalVariableNameToIndexMap.begin(); iter != Generator.Data->GlobalVariableNameToIndexMap.end(); ++iter)
	{
		size_t index = iter->second + 0xf0000000;
		LibJITContext.VariableMap[index] = Generator.Data->GlobalVariableMap[iter->second];
		LibJITContext.NameToIndexMap[iter->first] = index;
	}

	// Initialize tracking for JIT operations
	CurrentScope = NULL;

	NumParameters = 0;
	NumParameterBytes = 0;
	NumReturns = 0;

	HackStructType = 0;

	BeginOffset = beginoffset;
	EndOffset = endoffset;


	// Initialize block pointers that are lazily populated
	InnerExitBlock = NULL;
	NativeMatchBlock = NULL;
	PatternMatchBlock = NULL;

	// Initialize values used during JIT procedures
	LibJITContext.InnerRetVal = NULL;

	// Now process each instruction in the Epoch bytecode and produce the LLVM bitcode output
	for(size_t offset = beginoffset; offset <= endoffset; )
	{
		Bytecode::Instruction instruction = Bytecode[offset++];

		if(InstructionJITHelpers.find(instruction) == InstructionJITHelpers.end())
			throw FatalException("Invalid instruction for native code generation");

		InstructionJITHelper helper = InstructionJITHelpers[instruction];
		(this->*helper)(offset);
	}
	
	if(LibJITContext.InnerFunction)
	{
		Builder.SetInsertPoint(InnerExitBlock);

		if(LibJITContext.VarArgList)
			Builder.CreateCall(Generator.Data->BuiltInFunctions[JITFunc_Intrinsic_VAEnd], Builder.CreatePointerCast(LibJITContext.VarArgList, Type::getInt8PtrTy(Context)));

		if(LibJITContext.InnerRetVal)
		{
			Value* ret = Builder.CreateLoad(LibJITContext.InnerRetVal);
			Builder.CreateRet(ret);
		}
		else
			Builder.CreateRetVoid();

		// TODO - this is kind of hacky
		if(Generator.OwnerVM.GetPooledString(alias) == L"entrypoint")
			Generator.Data->EntryPoint = LibJITContext.InnerFunction;

		Generator.Data->GeneratedNameToFunctionMap[alias] = LibJITContext.InnerFunction;
	}

	if(NativeMatchBlock)
	{
		Builder.SetInsertPoint(NativeMatchBlock);
		Generator.AddNativeTypeMatcher(beginoffset, endoffset);
	}
	else if(PatternMatchBlock)
	{
		Builder.SetInsertPoint(PatternMatchBlock);
		Generator.AddNativePatternMatcher(beginoffset, endoffset);
	}
}

//
// Process a global variable initialization block
//
void FunctionJITHelper::DoGlobalInit(size_t beginoffset)
{
	LibJITContext.Builder = &Builder;
	LibJITContext.Context = &Context;
	LibJITContext.MyModule = Generator.Data->CurrentModule;
	LibJITContext.InnerFunction = NULL;
	LibJITContext.VarArgList = NULL;
	LibJITContext.Generator = &Generator;
	LibJITContext.FunctionAlias = 0;

	LibJITContext.BuiltInFunctions = &Generator.Data->BuiltInFunctions;

	// Initialize tracking for JIT operations
	CurrentScope = NULL;

	NumParameters = 0;
	NumParameterBytes = 0;
	NumReturns = 0;

	HackStructType = 0;

	// Initialize block pointers that are lazily populated
	InnerExitBlock = NULL;
	NativeMatchBlock = NULL;
	PatternMatchBlock = NULL;

	// Initialize values used during JIT procedures
	LibJITContext.InnerRetVal = NULL;

	// Now process each instruction in the Epoch bytecode and produce the LLVM bitcode output
	size_t offset = beginoffset;
	for(;;)
	{
		Bytecode::Instruction instruction = Bytecode[offset++];
		if(instruction == Bytecode::Instructions::Halt)
			break;

		if(InstructionJITHelpers.find(instruction) == InstructionJITHelpers.end())
			throw FatalException("Invalid instruction for native code generation");

		InstructionJITHelper helper = InstructionJITHelpers[instruction];
		(this->*helper)(offset);
	}
	
	if(LibJITContext.InnerFunction)
	{
		Builder.CreateBr(InnerExitBlock);
		Builder.SetInsertPoint(InnerExitBlock);
		Builder.CreateRetVoid();

		Generator.Data->GlobalInit = LibJITContext.InnerFunction;
	}
}

//
// Convert the Epoch instruction for entering an entity into LLVM bitcode
//
// The significance of Epoch entities vis-a-vis LLVM basic blocks is interesting.
// Both concepts are similar in many respects, with the principal distinction lying
// in the fact that Epoch entities and entity chains can attach arbitrary meta-control
// logic to the execution flow of the entity bodies themselves. In order to allow the
// Epoch standard library entities (and potentially third-party entities) to behave
// correctly in JITted native code, we offer a helper interface which shells out to
// the library implementation to emit meta-control code that mimics the Epoch entity
// behavior. This structure allows us to maintain the flexibility and expressive power
// potential of the entity system without compromising the JIT engine's functionality.
//
void FunctionJITHelper::BeginEntity(size_t& offset)
{
	Bytecode::EntityTag entitytype = Fetch<Integer32>(Bytecode, offset);
	LibJITContext.EntityTypes.push(entitytype);

	StringHandle entityname = Fetch<StringHandle>(Bytecode, offset);

	if(entitytype == Bytecode::EntityTags::Function)
	{
		Type* rettype = Type::getVoidTy(Context);
		Type* type = NULL;

		std::set<size_t> locals;
		std::set<size_t> parameters;

		size_t localoffsetbytes = 0;

		size_t retindex = static_cast<size_t>(-1);

		const ScopeDescription& scope = Generator.OwnerVM.GetScopeDescription(entityname);
		CurrentScope = &scope;
		for(size_t i = scope.GetVariableCount(); i-- > 0; )
		{
			Metadata::EpochTypeID vartype = scope.GetVariableTypeByIndex(i);

			if(vartype == Metadata::EpochType_Nothing)
			{
				if(scope.GetVariableOrigin(i) == VARIABLE_ORIGIN_PARAMETER)
				{
					parameters.insert(i);
					++NumParameters;
				}
				continue;
			}

			type = Generator.GetLLVMType(vartype);

			switch(scope.GetVariableOrigin(i))
			{
			case VARIABLE_ORIGIN_RETURN:
				++NumReturns;
				retindex = i;
				rettype = type;
				// Deliberate fallthrough

			case VARIABLE_ORIGIN_LOCAL:
				locals.insert(i);
				break;

			case VARIABLE_ORIGIN_PARAMETER:
				{
					ParameterOffsetToIndexMap[NumParameterBytes] = i;
					parameters.insert(i);
					++NumParameters;

					if(scope.IsReference(i))
						NumParameterBytes += sizeof(void*) + sizeof(Metadata::EpochTypeID);
					else
					{
						if(Metadata::GetTypeFamily(vartype) == Metadata::EpochTypeFamily_SumType)
							NumParameterBytes += Generator.OwnerVM.VariantDefinitions.find(vartype)->second.GetMaxSize();
						else
							NumParameterBytes += Metadata::GetStorageSize(vartype);
					}
				}
				break;
			}

			LibJITContext.NameToIndexMap[scope.GetVariableNameHandle(i)] = i;
		}

		LibJITContext.InnerFunction = Generator.GetGeneratedFunction(entityname, BeginOffset);

		BasicBlock* innerentryblock = BasicBlock::Create(Context, "innerentry", LibJITContext.InnerFunction);
		Builder.SetInsertPoint(innerentryblock);

		InnerExitBlock = BasicBlock::Create(Context, "innerexit", LibJITContext.InnerFunction);

		if(NumReturns)
			LibJITContext.InnerRetVal = Builder.CreateAlloca(rettype);

		size_t i = 0;
		Function::ArgumentListType& args = LibJITContext.InnerFunction->getArgumentList();
		for(Function::ArgumentListType::iterator argiter = args.begin(); argiter != args.end(); ++argiter)
		{
			if(CurrentScope->IsReference(i))
			{
				LibJITContext.VariableMap[i++] = ((Argument*)argiter);
				continue;
			}

			Value* slot = Builder.CreateAlloca(((Argument*)argiter)->getType());
			Builder.CreateStore(((Argument*)argiter), slot);
			LibJITContext.VariableMap[i++] = slot;
		}

		if(NumReturns)
			LibJITContext.VariableMap[retindex] = LibJITContext.InnerRetVal;

		localoffsetbytes = 0;
		for(std::set<size_t>::const_iterator localiter = locals.begin(); localiter != locals.end(); ++localiter)
		{
			Metadata::EpochTypeID localtype = scope.GetVariableTypeByIndex(*localiter);
			Type* type = Generator.GetLLVMType(localtype);

			if(*localiter != retindex)
				LibJITContext.VariableMap[*localiter] = Builder.CreateAlloca(type, NULL, narrow(Generator.OwnerVM.GetPooledString(scope.GetVariableNameHandle(*localiter))));

			LocalOffsetToIndexMap[localoffsetbytes] = *localiter;

			if(Metadata::GetTypeFamily(localtype) == Metadata::EpochTypeFamily_SumType)
				localoffsetbytes += Generator.OwnerVM.VariantDefinitions.find(localtype)->second.GetMaxSize();
			else
				localoffsetbytes += Metadata::GetStorageSize(localtype);
		}
	}
	else if(entitytype == Bytecode::EntityTags::TypeResolver)
	{
		Function* nativetypematcher = Generator.GetGeneratedTypeMatcher(entityname, BeginOffset);
		NativeMatchBlock = BasicBlock::Create(Context, "nativematchentry", nativetypematcher);
	}
	else if(entitytype == Bytecode::EntityTags::PatternMatchingResolver)
	{
		Function* nativematcher = Generator.GetGeneratedPatternMatcher(entityname, BeginOffset);
		PatternMatchBlock = BasicBlock::Create(Context, "nativepatternmatchentry", nativematcher);
	}
	else if(entitytype == Bytecode::EntityTags::Globals)
	{
		const ScopeDescription& scope = Generator.OwnerVM.GetScopeDescription(entityname);

		// Sanity check
		for(size_t i = scope.GetVariableCount(); i-- > 0; )
		{
			switch(scope.GetVariableOrigin(i))
			{
			case VARIABLE_ORIGIN_PARAMETER:
			case VARIABLE_ORIGIN_RETURN:
				throw FatalException("Global scope cannot contain parameters or return values");
			}
		}

		LibJITContext.InnerFunction = Generator.GetGeneratedGlobalInit(entityname);

		BasicBlock* innerentryblock = BasicBlock::Create(Context, "innerentry", LibJITContext.InnerFunction);
		Builder.SetInsertPoint(innerentryblock);

		InnerExitBlock = BasicBlock::Create(Context, "innerexit", LibJITContext.InnerFunction);

		size_t localoffsetbytes = 0;
		for(size_t i = 0; i < scope.GetVariableCount(); ++i)
		{
			Metadata::EpochTypeID localtype = scope.GetVariableTypeByIndex(i);
			Type* type = Generator.GetLLVMType(localtype);

			Constant* init = NULL;

			switch(localtype)
			{
			case Metadata::EpochType_Integer:
				init = ConstantInt::get(Type::getInt32Ty(Context), 0); 
				break;

			default:
				throw NotImplementedException("Unsupported global variable type");
			}

			Generator.Data->GlobalVariableMap[i] = new GlobalVariable(*Generator.Data->CurrentModule, type, false, GlobalValue::InternalLinkage, init, narrow(Generator.OwnerVM.GetPooledString(scope.GetVariableNameHandle(i))));
			Generator.Data->GlobalVariableOffsetToIndexMap[localoffsetbytes] = i;
			Generator.Data->GlobalVariableNameToIndexMap[scope.GetVariableNameHandle(i)] = i;

			if(Metadata::GetTypeFamily(localtype) == Metadata::EpochTypeFamily_SumType)
				localoffsetbytes += Generator.OwnerVM.VariantDefinitions.find(localtype)->second.GetMaxSize();
			else
				localoffsetbytes += Metadata::GetStorageSize(localtype);
		}

		for(std::map<StringHandle, size_t>::const_iterator iter = Generator.Data->GlobalVariableNameToIndexMap.begin(); iter != Generator.Data->GlobalVariableNameToIndexMap.end(); ++iter)
		{
			size_t index = iter->second + 0xf0000000;
			LibJITContext.VariableMap[index] = Generator.Data->GlobalVariableMap[iter->second];
			LibJITContext.NameToIndexMap[iter->first] = index;
		}
	}
	else
	{
		std::map<StringHandle, JIT::JITHelper>::const_iterator helperiter = Generator.OwnerVM.JITHelpers.EntityHelpers.find(entitytype);
		if(helperiter == Generator.OwnerVM.JITHelpers.EntityHelpers.end())
			throw FatalException("Cannot JIT this type of entity");
					
		helperiter->second(LibJITContext, true);
	}
}

//
// Convert the Epoch instruction for exiting an entity into LLVM bitcode
//
void FunctionJITHelper::EndEntity(size_t&)
{
	Bytecode::EntityTag tag = LibJITContext.EntityTypes.top();
	LibJITContext.EntityTypes.pop();

	if(tag != Bytecode::EntityTags::Function && tag != Bytecode::EntityTags::TypeResolver && tag != Bytecode::EntityTags::PatternMatchingResolver)
		Generator.OwnerVM.JITHelpers.EntityHelpers.find(tag)->second(LibJITContext, false);
}

//
// Convert the Epoch instruction for entering an entity chain into LLVM bitcode
//
void FunctionJITHelper::BeginChain(size_t&)
{
	LibJITContext.EntityChecks.push(BasicBlock::Create(Context, "", LibJITContext.InnerFunction));
	LibJITContext.EntityChains.push(BasicBlock::Create(Context, "", LibJITContext.InnerFunction));
	LibJITContext.EntityChainExits.push(BasicBlock::Create(Context, "", LibJITContext.InnerFunction));
	Builder.CreateBr(LibJITContext.EntityChecks.top());
	Builder.SetInsertPoint(LibJITContext.EntityChecks.top());
}

//
// Convert the Epoch instruction for exiting an entity chain into LLVM bitcode
//
void FunctionJITHelper::EndChain(size_t&)
{
	if(LibJITContext.EntityChains.top()->empty())
	{
		Builder.SetInsertPoint(LibJITContext.EntityChains.top());
		Builder.CreateBr(LibJITContext.EntityChainExits.top());
	}

	LibJITContext.EntityChecks.pop();
	LibJITContext.EntityChains.pop();
	Builder.SetInsertPoint(LibJITContext.EntityChainExits.top());
	LibJITContext.EntityChainExits.pop();
}

//
// Generate LLVM bitcode to read a named variable onto the stack
//
// Note that we do not literally push things onto the machine stack as a
// result of processing this instruction; instead, the JIT engine maintains
// a "virtual stack" which tracks what values would be on the stack if we
// pushed/popped them all individually the same way that the Epoch VM works.
//
// The virtual stack can be very handy in eliminating redundant loads and
// stores, because we don't need to stack-shuffle every single value we want
// to operate on the way the Epoch VM does.
//
void FunctionJITHelper::Read(size_t& offset)
{
	StringHandle varname = Fetch<StringHandle>(Bytecode, offset);
	size_t index = LibJITContext.NameToIndexMap[varname];

	if(Builder.GetInsertBlock()->getParent()->isVarArg() && (CurrentScope->GetVariableOrigin(index) != VARIABLE_ORIGIN_RETURN))
	{
		Metadata::EpochTypeID vartype = CurrentScope->GetVariableTypeByIndex(index);
		if(Metadata::GetTypeFamily(vartype) == Metadata::EpochTypeFamily_SumType)
		{
			Value* payload = Builder.CreateVAArg(LibJITContext.VarArgList, Generator.GetLLVMSumType(vartype, true)->getContainedType(1));
			Value* typesignature = Builder.CreateVAArg(LibJITContext.VarArgList, Generator.Data->VMTypeIDType);

			Value* sumtypeholder = Builder.CreateAlloca(Generator.GetLLVMSumType(vartype, true));

			std::vector<Value*> gepindices;
			gepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
			gepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
			Value* typeholder = Builder.CreateGEP(sumtypeholder, gepindices);

			std::vector<Value*> payloadgepindices;
			payloadgepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
			payloadgepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 1));
			Value* payloadholder = Builder.CreateGEP(sumtypeholder, payloadgepindices);
			
			Builder.CreateStore(typesignature, typeholder);
			Builder.CreateStore(payload, payloadholder);

			Value* ptr = Builder.CreateLoad(sumtypeholder);
			LibJITContext.ValuesOnStack.push(ptr);
			LibJITContext.VariableMap[index] = ptr;
		}
		else
		{
			Type* type = Generator.GetLLVMType(vartype);
			Value* ptr = Builder.CreateVAArg(LibJITContext.VarArgList, type);
			LibJITContext.ValuesOnStack.push(ptr);
			LibJITContext.VariableMap[index] = ptr;
		}
	}
	else
	{
		Value* v = Builder.CreateLoad(LibJITContext.VariableMap[index]);
		//if(CurrentScope->IsReferenceByID(varname))
		//	v = Builder.CreateLoad(v);

		LibJITContext.ValuesOnStack.push(v);
	}
}

//
// Handle the EpochVM special instruction for reading local variables
// onto the Epoch execution stack. Similar to the Read instruction, this
// is handled by using the virtual value stack instead of generating an
// actual stack shuffle on the machine stack.
//
void FunctionJITHelper::ReadStackLocal(size_t& offset)
{
	size_t frames = Fetch<size_t>(Bytecode, offset);
	size_t stackoffset = Fetch<size_t>(Bytecode, offset);
	Fetch<size_t>(Bytecode, offset);		// stack size is irrelevant

	if((frames != 0) && (frames != (unsigned)(-1)))		// TODO - this is an ugly hardcoded hack
		throw NotImplementedException("Scope is not flat!");

	Metadata::EpochTypeID type = Metadata::EpochType_Error;
	Value* v = NULL;
	
	if (frames == 0)
	{
		size_t index = LocalOffsetToIndexMap[stackoffset];
		type = CurrentScope->GetVariableTypeByIndex(index);
		v = LibJITContext.VariableMap[index];
	}
	else
	{
		const ScopeDescription* scope = CurrentScope;
		while(scope->ParentScope)
			scope = scope->ParentScope;

		size_t index = Generator.Data->GlobalVariableOffsetToIndexMap[stackoffset];
		type = scope->GetVariableTypeByIndex(index);
		v = Generator.Data->GlobalVariableMap[index]; 
	}

	if(Metadata::GetTypeFamily(type) == Metadata::EpochTypeFamily_SumType)
	{
		std::vector<Value*> gepindices;
		gepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
		gepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
		Value* typeholder = Builder.CreateLoad(Builder.CreateGEP(v, gepindices));

		std::vector<Value*> payloadgepindices;
		payloadgepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
		payloadgepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 1));
		Value* payload = Builder.CreateLoad(Builder.CreateGEP(v, payloadgepindices));

		LibJITContext.ValuesOnStack.push(payload);
		LibJITContext.ValuesOnStack.push(typeholder);
	}
	else
	{
		Value* val = Builder.CreateLoad(v);
		LibJITContext.ValuesOnStack.push(val);
	}
}

//
// Handle another Read instruction variant targeted at function
// parameters. The main quirk here is that we automatically dereference
// values which were passed to the function by ref.
//
void FunctionJITHelper::ReadParameter(size_t& offset)
{
	size_t frames = Fetch<size_t>(Bytecode, offset);
	size_t stackoffset = Fetch<size_t>(Bytecode, offset);
	Fetch<size_t>(Bytecode, offset);		// stack size is irrelevant

	if(frames != 0)
		throw NotImplementedException("Scope is not flat!");
				
	size_t idx = ParameterOffsetToIndexMap[stackoffset];
	Value* val = Builder.CreateLoad(LibJITContext.VariableMap[idx]);
	//if(CurrentScope->IsReference(idx))
	//	val = Builder.CreateLoad(val);
	LibJITContext.ValuesOnStack.push(val);
}

//
// In the Epoch VM, we bind references to things by placing a pointer
// and a type annotation onto the Epoch stack. In the JIT engine, we
// convert this to simply storing a raw pointer (discarding type safety
// since in theory the compiler already ensures that for us) and track
// the type annotation in a virtual stack. This again eliminates a lot
// of load/store activity on the machine stack.
//
void FunctionJITHelper::BindReference(size_t& offset)
{
	size_t frames = Fetch<size_t>(Bytecode, offset);
	size_t index = Fetch<size_t>(Bytecode, offset);

	if(frames > 0)
		throw NotImplementedException("Scope is not flat!");

	Metadata::EpochTypeID vartype = CurrentScope->GetVariableTypeByIndex(index);

	if(Builder.GetInsertBlock()->getParent()->isVarArg() && (CurrentScope->GetVariableOrigin(index) != VARIABLE_ORIGIN_RETURN))
	{
		Value* ptr = Builder.CreateVAArg(LibJITContext.VarArgList, Generator.GetLLVMType(vartype)->getPointerTo());
		LibJITContext.ValuesOnStack.push(ptr);

		LibJITContext.VariableMap[index] = ptr;
	}
	else
	{
		Value* ptr = LibJITContext.VariableMap[index];
		//if(CurrentScope->IsReference(index))
		//	ptr = Builder.CreateLoad(ptr);

		LibJITContext.ValuesOnStack.push(ptr);
	}

	TypeAnnotations.push(vartype);
}

//
// The Epoch VM uses this instruction to dereference a ref on the stack
// into a value which replaces it on the stack. We do this entire process
// at JIT time using the virtual stack and thereby eliminate a load/store
// pair on the machine stack.
//
void FunctionJITHelper::ReadRef(size_t&)
{
	Value* derefvalue = Builder.CreateLoad(LibJITContext.ValuesOnStack.top());
	LibJITContext.ValuesOnStack.pop();
	LibJITContext.ValuesOnStack.push(derefvalue);
	TypeAnnotations.pop();
}

//
// When invoking type matchers, we often need to place a value and its type
// annotation on to the virtual stack in order to pass along that information
// to the dispatch routine. This instruction is used to accomplish that.
//
void FunctionJITHelper::ReadRefAnnotated(size_t&)
{
	std::vector<Value*> gepindices;
	gepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
	gepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
	Value* annotationgep = Builder.CreateGEP(LibJITContext.ValuesOnStack.top(), gepindices);

	std::vector<Value*> derefindices;
	derefindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
	derefindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 1));
	Value* derefgep = Builder.CreateLoad(Builder.CreateGEP(LibJITContext.ValuesOnStack.top(), derefindices));

	Value* annotationvalue = Builder.CreateLoad(annotationgep);
	LibJITContext.ValuesOnStack.pop();
	LibJITContext.ValuesOnStack.push(derefgep);
	LibJITContext.ValuesOnStack.push(annotationvalue);
	TypeAnnotations.pop();
}

//
// The Epoch VM pops a reference and a value off the Epoch stack
// and uses it to perform a store; we can eliminate a couple of
// steps here using the virtual stack and emit just a direct store.
//
void FunctionJITHelper::Assign(size_t&)
{
	Value* reftarget = LibJITContext.ValuesOnStack.top();
	LibJITContext.ValuesOnStack.pop();
	Value* v = LibJITContext.ValuesOnStack.top();
	LibJITContext.ValuesOnStack.pop();

	if(reftarget->getType() == v->getType()->getPointerTo()->getPointerTo())
		reftarget = Builder.CreateLoad(reftarget);

	Builder.CreateStore(v, reftarget);
}

//
// Assign a value into a reference from the virtual stack, but do
// the additional housekeeping necessary to tag the value of a sum
// typed variable as having the appropriate type.
//
void FunctionJITHelper::AssignSumType(size_t&)
{
	Value* reftarget = LibJITContext.ValuesOnStack.top();
	LibJITContext.ValuesOnStack.pop();
	Value* actualtype = LibJITContext.ValuesOnStack.top();
	LibJITContext.ValuesOnStack.pop();

	Value* typeholder = Builder.CreatePointerCast(reftarget, Type::getInt32PtrTy(Context));
	if(actualtype->getType()->getNumContainedTypes() == 1)
	{
		LoadInst* load = dyn_cast<LoadInst>(actualtype);

		std::vector<Value*> gepindices;
		gepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
		gepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
		Builder.CreateStore(Builder.CreateLoad(Builder.CreateGEP(load->getOperand(0), gepindices)), typeholder);

		std::vector<Value*> payloadgepindices;
		payloadgepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
		payloadgepindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 1));
		Value* payloadgep = Builder.CreateGEP(load->getOperand(0), payloadgepindices);
		Value* payload = Builder.CreateLoad(payloadgep);

		Value* target = Builder.CreateGEP(Builder.CreatePointerCast(reftarget, Type::getInt8PtrTy(Context)), ConstantInt::get(Type::getInt32Ty(Context), sizeof(Metadata::EpochTypeID)));
		Value* casttarget = Builder.CreatePointerCast(target, payload->getType()->getPointerTo());
		Builder.CreateStore(payload, casttarget);
	}
	else if(actualtype->getType()->getNumContainedTypes() == 2)
	{
		Builder.CreateStore(actualtype, reftarget);
	}
	else
	{
		Builder.CreateStore(actualtype, typeholder);

		Value* target = Builder.CreateGEP(Builder.CreatePointerCast(reftarget, Type::getInt8PtrTy(Context)), ConstantInt::get(Type::getInt32Ty(Context), sizeof(Metadata::EpochTypeID)));
		Value* casttarget = Builder.CreatePointerCast(target, LibJITContext.ValuesOnStack.top()->getType()->getPointerTo());
		Builder.CreateStore(LibJITContext.ValuesOnStack.top(), casttarget);

		LibJITContext.ValuesOnStack.pop();
	}
}

//
// Variant of assigning to a sum-typed variable that is used
// exclusively during construction. Since the circumstances
// are a little different, we can simplify the code a touch.
//
void FunctionJITHelper::ConstructSumType(size_t&)
{
	Value* vartype = LibJITContext.ValuesOnStack.top();
	LibJITContext.ValuesOnStack.pop();


	if(vartype->getType()->getNumContainedTypes() == 2)			// TODO - hackish?
	{
		Value* targetid = LibJITContext.ValuesOnStack.top();
		LibJITContext.ValuesOnStack.pop();

		ConstantInt* cint = dyn_cast<ConstantInt>(targetid);
		size_t vartarget = static_cast<size_t>(cint->getValue().getLimitedValue());

		Value* storagetarget = LibJITContext.VariableMap[LibJITContext.NameToIndexMap[vartarget]];

		Builder.CreateStore(vartype, storagetarget);

		return;
	}


	Value* value = LibJITContext.ValuesOnStack.top();
	LibJITContext.ValuesOnStack.pop();

	Value* targetid = LibJITContext.ValuesOnStack.top();
	LibJITContext.ValuesOnStack.pop();


	bool typeisnothing = false;
	ConstantInt* ctype = dyn_cast<ConstantInt>(vartype);
	if(ctype != NULL)
	{
		if(ctype->getValue().getLimitedValue() == Metadata::EpochType_Nothing)
			typeisnothing = true;
	}

	ConstantInt* cint = dyn_cast<ConstantInt>(targetid);
	size_t vartarget = static_cast<size_t>(cint->getValue().getLimitedValue());

	Value* storagetarget = LibJITContext.VariableMap[LibJITContext.NameToIndexMap[vartarget]];

	if(!typeisnothing)
	{
		// Set contents
		std::vector<Value*> memberindices;
		memberindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
		memberindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 1));
		Value* valueholder = Builder.CreateGEP(storagetarget, memberindices);
		Builder.CreateStore(value, valueholder);
	}

	// Set type annotation
	{
		std::vector<Value*> memberindices;
		memberindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
		memberindices.push_back(ConstantInt::get(Type::getInt32Ty(Context), 0));
		Value* typeholder = Builder.CreateGEP(storagetarget, memberindices);
		Builder.CreateStore(vartype, typeholder);
	}
}

//
// Epoch's semantics for function return values need a little bit
// of tweaking to apply to the format generally supported by LLVM.
// This routine handles the conversion process.
//
void FunctionJITHelper::SetRetValue(size_t& offset)
{
	size_t index = Fetch<size_t>(Bytecode, offset);
	Builder.CreateStore(Builder.CreateLoad(LibJITContext.VariableMap[index]), LibJITContext.InnerRetVal);
}

//
// Handle the Epoch function return instruction. We do not convert
// this directly into an LLVM return instruction because the function
// may need to do some epilog work prior to actually returning to the
// caller on the machine level; garbage collection, deterministic
// destruction, and so on are handled in this manner.
//
void FunctionJITHelper::Return(size_t&)
{
	Builder.CreateBr(InnerExitBlock);
}

//
// Utility instruction for halting program execution.
//
void FunctionJITHelper::Halt(size_t&)
{
	Builder.CreateCall(Generator.Data->BuiltInFunctions[JITFunc_VM_Halt]);
	Builder.CreateUnreachable();
}

//
// Push a literal immediate value from the Epoch bytecode stream
// onto the virtual stack so it can be operated on later.
//
void FunctionJITHelper::Push(size_t& offset)
{
	Metadata::EpochTypeID type = Fetch<Metadata::EpochTypeID>(Bytecode, offset);
	Constant* valueval;

	switch(type)
	{
	case Metadata::EpochType_Integer:
		{
			Integer32 value = Fetch<Integer32>(Bytecode, offset);
			valueval = ConstantInt::get(Type::getInt32Ty(Context), value);
		}
		break;

	case Metadata::EpochType_Identifier:
	case Metadata::EpochType_String:
		{
			StringHandle value = Fetch<StringHandle>(Bytecode, offset);
			valueval = ConstantInt::get(Type::getInt32Ty(Context), value);
		}
		break;

	case Metadata::EpochType_Real:
		{
			Real32 value = Fetch<Real32>(Bytecode, offset);
			valueval = ConstantFP::get(Type::getFloatTy(Context), value);
		}
		break;

	case Metadata::EpochType_Boolean:
		{
			bool value = Fetch<bool>(Bytecode, offset);
			valueval = ConstantInt::get(Type::getInt1Ty(Context), value);
		}
		break;

	case Metadata::EpochType_Integer16:
		{
			Integer16 value = Fetch<Integer16>(Bytecode, offset);
			valueval = ConstantInt::get(Type::getInt16Ty(Context), value);
		}
		break;

	case Metadata::EpochTypeFamily_Function:		// We only emit generic family, not the actual signature type. This is kind of hacky.
		{
			StringHandle funcname = Fetch<StringHandle>(Bytecode, offset);
			size_t offset = Generator.OwnerVM.GetFunctionInstructionOffsetNoThrow(funcname);
			
			if(offset)
				valueval = Generator.GetGeneratedFunction(funcname, offset);
			else
			{
				std::map<StringHandle, const char*>::const_iterator libiter = Generator.OwnerVM.JITHelpers.LibraryExports.find(funcname);
				if(libiter == Generator.OwnerVM.JITHelpers.LibraryExports.end())
					throw NotImplementedException("Invalid higher order function target");

				llvm::FunctionType* ftype = Generator.GetLLVMFunctionTypeFromSignature(funcname);
				llvm::Function* func = Generator.LibraryFunctionCache[libiter->second];

				if(!func)
					func = Generator.LibraryFunctionCache[libiter->second] = Function::Create(ftype, Function::ExternalLinkage, libiter->second, Generator.Data->CurrentModule);

				valueval = func;
			}
		}
		break;

	case Metadata::EpochType_Buffer:
	default:
		throw FatalException("Unsupported type for JIT compilation");
	}

	LibJITContext.ValuesOnStack.push(valueval);
}

//
// Pop the virtual stack; this is useful for eliminating return
// values that have been ignored in the source program.
//
void FunctionJITHelper::Pop(size_t& offset)
{
	Fetch<size_t>(Bytecode, offset);
	LibJITContext.ValuesOnStack.pop();
}

//
// Shell out to the VM infrastructure to allocate some structure-typed memory
//
void FunctionJITHelper::AllocStructure(size_t& offset)
{
	Metadata::EpochTypeID type = Fetch<Metadata::EpochTypeID>(Bytecode, offset);
	Value* typeconst = ConstantInt::get(Type::getInt32Ty(Context), type);
	Value* handle = Builder.CreateCall(Generator.Data->BuiltInFunctions[JITFunc_VM_AllocStruct], typeconst);
	LibJITContext.ValuesOnStack.push(handle);

	HackStructType = type;

	// TODO - more hack
	LibJITContext.VarArgList = Builder.CreateAlloca(Type::getInt8PtrTy(Context));
	Value* castlist = Builder.CreatePointerCast(LibJITContext.VarArgList, Type::getInt8PtrTy(Context));
	Builder.CreateCall(Generator.Data->BuiltInFunctions[JITFunc_Intrinsic_VAStart], castlist);
}

//
// Copy a value into a structure object's memory space
//
void FunctionJITHelper::CopyToStructure(size_t& offset)
{

	// TODO - if the member is a sum type, we need to copy the full sum type data over.
	// This may not require code changes *here* but it will require code changes to the
	// signature of the generated constructor. I need to carefully consider what tweaks
	// to make to the signature, e.g. using varargs, to make this work best.

	StringHandle variablename = Fetch<StringHandle>(Bytecode, offset);
	StringHandle actualmember = Fetch<StringHandle>(Bytecode, offset);

	Value* v = LibJITContext.VariableMap[LibJITContext.NameToIndexMap[variablename]];
	Value* structptr = Builder.CreateLoad(v);

	const StructureDefinition& def = Generator.OwnerVM.GetStructureDefinition(HackStructType);
	size_t memberindex = def.FindMember(actualmember);
	size_t memberoffset = def.GetMemberOffset(memberindex);
	Metadata::EpochTypeID membertype = def.GetMemberType(memberindex);

	Value* memberptr = Builder.CreateGEP(structptr, ConstantInt::get(Type::getInt32Ty(Context), memberoffset));
	Value* castmemberptr = Builder.CreatePointerCast(memberptr, Generator.GetLLVMType(membertype)->getPointerTo());

	Builder.CreateStore(LibJITContext.ValuesOnStack.top(), castmemberptr);

	LibJITContext.ValuesOnStack.pop();
}

//
// Request a deep copy of a structure object from the VM
//
void FunctionJITHelper::CopyStructure(size_t&)
{
	Value* structureptr = LibJITContext.ValuesOnStack.top();
	LibJITContext.ValuesOnStack.pop();
	Value* copyptr = Builder.CreateCall(Generator.Data->BuiltInFunctions[JITFunc_VM_CopyStruct], structureptr);
	Value* castptr = Builder.CreatePointerCast(copyptr, Type::getInt8PtrTy(Context));
	LibJITContext.ValuesOnStack.push(castptr);
}

//
// Bind reference to a structure member variable
//
void FunctionJITHelper::BindMemberRef(size_t& offset)
{
	Metadata::EpochTypeID membertype = Fetch<Metadata::EpochTypeID>(Bytecode, offset);
	size_t memberoffset = Fetch<size_t>(Bytecode, offset);

	Value* voidstructptr = LibJITContext.ValuesOnStack.top();
	if(voidstructptr->getType() == Type::getInt8PtrTy(Context)->getPointerTo())
		voidstructptr = Builder.CreateLoad(voidstructptr);
	else if(voidstructptr->getType() == Type::getInt8PtrTy(Context)->getPointerTo()->getPointerTo())
		voidstructptr = Builder.CreateLoad(Builder.CreateLoad(voidstructptr));
	Value* bytestructptr = Builder.CreatePointerCast(voidstructptr, Type::getInt8PtrTy(Context));
	Value* voidmemberptr = Builder.CreateGEP(bytestructptr, ConstantInt::get(Type::getInt32Ty(Context), memberoffset));
	Value* memberptr = Builder.CreatePointerCast(voidmemberptr, Generator.GetLLVMType(membertype)->getPointerTo());

	LibJITContext.ValuesOnStack.pop();
	LibJITContext.ValuesOnStack.push(memberptr);
	TypeAnnotations.push(membertype);
}

//
// Handle the trivial case of invoking library code from an Epoch program
//
void FunctionJITHelper::Invoke(size_t& offset)
{
	StringHandle target = Fetch<StringHandle>(Bytecode, offset);
	std::map<StringHandle, JIT::JITHelper>::const_iterator iter = Generator.OwnerVM.JITHelpers.InvokeHelpers.find(target);
	if(iter == Generator.OwnerVM.JITHelpers.InvokeHelpers.end())
	{
		std::map<StringHandle, const char*>::const_iterator libiter = Generator.OwnerVM.JITHelpers.LibraryExports.find(target);
		if(libiter == Generator.OwnerVM.JITHelpers.LibraryExports.end())
			throw FatalException("Cannot invoke this function, no native code support!");

		llvm::FunctionType* ftype = Generator.GetLLVMFunctionTypeFromSignature(target);
		llvm::Function* func = Generator.LibraryFunctionCache[libiter->second];

		if(!func)
			func = Generator.LibraryFunctionCache[libiter->second] = Function::Create(ftype, Function::ExternalLinkage, libiter->second, Generator.Data->CurrentModule);

		std::vector<llvm::Value*> args;
		for(size_t i = 0; i < ftype->getNumParams(); ++i)
		{
			args.push_back(LibJITContext.ValuesOnStack.top());
			LibJITContext.ValuesOnStack.pop();
		}

		Value* v = Builder.CreateCall(func, args);

		if(func->getReturnType() != Type::getVoidTy(Generator.Data->Context))
			LibJITContext.ValuesOnStack.push(v);

		return;
	}

	iter->second(LibJITContext, true);
}

//
// Handle the edge case of invoking a JITted type matcher from an Epoch program
//
void FunctionJITHelper::InvokeOffset(size_t& offset)
{
	StringHandle functionname = Fetch<StringHandle>(Bytecode, offset);
	size_t internaloffset = Fetch<size_t>(Bytecode, offset);

	Function* nativematcher = NULL;
	size_t numparams = 0;
	std::vector<Value*> matchervarargs;

	// Handle vanilla pattern matchers
	if(Generator.OwnerVM.PatternMatcherParamCount.find(functionname) != Generator.OwnerVM.PatternMatcherParamCount.end())
	{
		nativematcher = Generator.GetGeneratedPatternMatcher(functionname, internaloffset);
		numparams = Generator.OwnerVM.PatternMatcherParamCount.find(functionname)->second;

		for(size_t i = 0; i < numparams; ++i)
		{
			Value* v = LibJITContext.ValuesOnStack.top();
			LibJITContext.ValuesOnStack.pop();

			matchervarargs.push_back(v);
		}
	}
	else
	{
		if(Generator.OwnerVM.TypeMatcherParamCount.find(functionname) == Generator.OwnerVM.TypeMatcherParamCount.end())
			throw FatalException("Cannot invoke VM code from native code");

		nativematcher = Generator.GetGeneratedTypeMatcher(functionname, internaloffset);
		numparams = Generator.OwnerVM.TypeMatcherParamCount.find(functionname)->second;

		for(size_t i = 0; i < numparams; ++i)
		{
			Value* v1 = LibJITContext.ValuesOnStack.top();
			LibJITContext.ValuesOnStack.pop();

			Value* v2 = LibJITContext.ValuesOnStack.top();
			LibJITContext.ValuesOnStack.pop();

			if(v2->getType()->isPointerTy())
			{
				Metadata::EpochTypeID paramepochtype = TypeAnnotations.top();
				Value* annotation = ConstantInt::get(Type::getInt32Ty(Context), paramepochtype);
				TypeAnnotations.pop();

				matchervarargs.push_back(annotation);
				matchervarargs.push_back(Builder.CreatePointerCast(v2, Type::getInt8PtrTy(Context)));
			}
			else
			{
				LoadInst* load = dyn_cast<LoadInst>(v2);
				if(load)
				{
					matchervarargs.push_back(v1);
					matchervarargs.push_back(Builder.CreatePointerCast(load->getOperand(0), Type::getInt8PtrTy(Context)));
				}
				else
				{
					Value* stacktemp = Builder.CreateAlloca(v2->getType());
					Builder.CreateStore(v2, stacktemp);

					matchervarargs.push_back(v1);
					matchervarargs.push_back(Builder.CreatePointerCast(stacktemp, Type::getInt8PtrTy(Context)));
				}
			}
		}
	}

	Value* v = Builder.CreateCall(nativematcher, matchervarargs);
	if(v->getType() != Type::getVoidTy(Context))
		LibJITContext.ValuesOnStack.push(v);
}

//
// Handle the common case of Epoch function calls from one native routine to another
//
void FunctionJITHelper::InvokeNative(size_t& offset)
{
	StringHandle target = Fetch<StringHandle>(Bytecode, offset);
	Fetch<size_t>(Bytecode, offset);		// skip dummy offset
	std::map<StringHandle, JIT::JITHelper>::const_iterator iter = Generator.OwnerVM.JITHelpers.InvokeHelpers.find(target);
	if(iter != Generator.OwnerVM.JITHelpers.InvokeHelpers.end())
		iter->second(LibJITContext, true);
	else
	{
		Function* targetfunc = Generator.GetGeneratedFunction(target, Generator.OwnerVM.GetFunctionInstructionOffsetNoThrow(target));

		size_t paramcount = 0;
		
		const ScopeDescription& desc = Generator.OwnerVM.GetScopeDescription(target);
		for(size_t i = 0; i < desc.GetVariableCount(); ++i)
		{
			if(desc.GetVariableOrigin(i) == VARIABLE_ORIGIN_PARAMETER)
			{
				++paramcount;

				// Add type signature param if need be
				if(Metadata::GetTypeFamily(desc.GetVariableTypeByIndex(i)) == Metadata::EpochTypeFamily_SumType)
					++paramcount;
			}
		}

		std::vector<Value*> targetargs;
		for(size_t i = 0; i < paramcount; ++i)
		{
			Value* p = LibJITContext.ValuesOnStack.top();
			LibJITContext.ValuesOnStack.pop();
			targetargs.push_back(p);
		}
		std::reverse(targetargs.begin(), targetargs.end());

		Value* v = Builder.CreateCall(targetfunc, targetargs);
		if(v->getType() != Type::getVoidTy(Context))
			LibJITContext.ValuesOnStack.push(v);
	}
}

//
// Generate LLVM bitcode for indirect function invocation (i.e. function pointer)
//
void FunctionJITHelper::InvokeIndirect(size_t& offset)
{
	StringHandle funcnameholder = Fetch<StringHandle>(Bytecode, offset);
	Value* func = Builder.CreateLoad(LibJITContext.VariableMap[LibJITContext.NameToIndexMap[funcnameholder]]);

	FunctionType* ftype = dyn_cast<FunctionType>(func->getType()->getContainedType(0));

	std::vector<Value*> args;
	for(size_t i = 0; i < ftype->getNumParams(); ++i)
	{
		args.push_back(LibJITContext.ValuesOnStack.top());
		LibJITContext.ValuesOnStack.pop();
	}

	if(ftype->getReturnType() != Type::getVoidTy(Context))
		LibJITContext.ValuesOnStack.push(Builder.CreateCall(func, args));
	else
		Builder.CreateCall(func, args);
}

//
// Generate type matching dispatcher prolog code for a given Epoch function set
//
void FunctionJITHelper::TypeMatch(size_t& offset)
{
	offset = EndOffset;
}

void FunctionJITHelper::PatternMatch(size_t& offset)
{
	offset = EndOffset;
}

void FunctionJITHelper::CopyBuffer(size_t&)
{
	Value* buffer = LibJITContext.ValuesOnStack.top();
	LibJITContext.ValuesOnStack.pop();
	
	Value* clone = Builder.CreateCall(Generator.Data->BuiltInFunctions[JITFunc_VM_CopyBuffer], buffer);
	LibJITContext.ValuesOnStack.push(clone);
}

//
// Generate native code for type matching/dispatch when called from
// a parent routine which is already JIT compiled. This is not to be
// confused with calling a native routine from a non-native parent
// which is running in the Epoch VM.
//
void NativeCodeGenerator::AddNativeTypeMatcher(size_t beginoffset, size_t endoffset)
{
	Function* matcherfunction = Builder.GetInsertBlock()->getParent();

	std::vector<Value*> reftypes;
	std::vector<Value*> reftargets;

	std::vector<std::vector<Value*> > parampayloadptrs;
	std::vector<std::vector<Value*> > providedtypeholders;

	unsigned typematchindex = 0;
	StringHandle entityname = 0;

	// The purpose of this loop is to hoist all stack allocations from the inner
	// type matching basic blocks out to the entry block. This allows the LLVM
	// optimizer to convert the allocas to registers, which eliminates dynamic
	// stack resizing during the type match process - a solid performance win.
	for(size_t offset = beginoffset; offset <= endoffset; )
	{
		Bytecode::Instruction instruction = Bytecode[offset++];
		switch(instruction)
		{
		// Need to handle this so we can skip through the byte stream correctly
		case Bytecode::Instructions::BeginEntity:
			Fetch<Integer32>(Bytecode, offset);
			Fetch<StringHandle>(Bytecode, offset);
			break;

		// Ignore these for now
		case Bytecode::Instructions::EndEntity:
		case Bytecode::Instructions::Halt:
			break;

		case Bytecode::Instructions::TypeMatch:
			{
				parampayloadptrs.push_back(std::vector<Value*>());
				providedtypeholders.push_back(std::vector<Value*>());

				Fetch<StringHandle>(Bytecode, offset);
				Fetch<size_t>(Bytecode, offset);
				size_t paramcount = Fetch<size_t>(Bytecode, offset);

				for(size_t i = 0; i < paramcount; ++i)
				{
					Fetch<bool>(Bytecode, offset);
					Fetch<Metadata::EpochTypeID>(Bytecode, offset);

					parampayloadptrs.back().push_back(Builder.CreateAlloca(Type::getInt8PtrTy(Data->Context)));
					providedtypeholders.back().push_back(Builder.CreateAlloca(Type::getInt32Ty(Data->Context)));
				}
			}
			break;

		default:
			throw FatalException("Invalid opcode in native type matcher");
		}
	}


	for(size_t offset = beginoffset; offset <= endoffset; )
	{
		Bytecode::Instruction instruction = Bytecode[offset++];
		switch(instruction)
		{
		case Bytecode::Instructions::BeginEntity:
			Fetch<Integer32>(Bytecode, offset);
			entityname = Fetch<StringHandle>(Bytecode, offset);
			break;

		case Bytecode::Instructions::EndEntity:
			break;

		case Bytecode::Instructions::Halt:
			Builder.CreateCall(Data->BuiltInFunctions[JITFunc_VM_Halt]);
			Builder.CreateUnreachable();
			break;

		case Bytecode::Instructions::TypeMatch:
			{
				StringHandle funcname = Fetch<StringHandle>(Bytecode, offset);
				size_t matchoffset = Fetch<size_t>(Bytecode, offset);
				size_t paramcount = Fetch<size_t>(Bytecode, offset);

				std::vector<Value*> actualparams;
				BasicBlock* nexttypematcher = BasicBlock::Create(Data->Context, "nexttypematcher", matcherfunction);

				Function::arg_iterator argiter = matcherfunction->arg_begin();

				if(reftypes.empty())
				{
					for(size_t i = 0; i < paramcount; ++i)
					{
						Value* reftype = argiter;
						++argiter;
						Value* reftarget = argiter;
						++argiter;

						reftypes.push_back(reftype);
						reftargets.push_back(reftarget);
					}
				}

				for(size_t i = 0; i < paramcount; ++i)
				{
					bool expectref = Fetch<bool>(Bytecode, offset);
					Metadata::EpochTypeID expecttype = Fetch<Metadata::EpochTypeID>(Bytecode, offset);

					BasicBlock* checkmatchblock = BasicBlock::Create(Data->Context, "checkmatch", matcherfunction);

					Builder.CreateStore(reftypes[i], providedtypeholders[typematchindex][i]);

					BasicBlock* setnothingrefflagblock = BasicBlock::Create(Data->Context, "setnothingrefflag", matcherfunction);
					BasicBlock* skipblock = BasicBlock::Create(Data->Context, "skip", matcherfunction);

					Value* providednothingflag = Builder.CreateICmpEQ(reftypes[i], ConstantInt::get(Type::getInt32Ty(Data->Context), Metadata::EpochType_Nothing));
					Builder.CreateCondBr(providednothingflag, setnothingrefflagblock, skipblock);

					Builder.SetInsertPoint(setnothingrefflagblock);
					Builder.CreateBr(skipblock);

					Builder.SetInsertPoint(skipblock);
					Builder.CreateStore(reftargets[i], parampayloadptrs[typematchindex][i]);


					BasicBlock* handlesumtypeblock = BasicBlock::Create(Data->Context, "handlesumtype", matcherfunction);

					Value* providedtypefamily = Builder.CreateAnd(Builder.CreateLoad(providedtypeholders[typematchindex][i]), 0xff000000);
					Value* issumtype = Builder.CreateICmpEQ(providedtypefamily, ConstantInt::get(Type::getInt32Ty(Data->Context), Metadata::EpochTypeFamily_SumType));
					Builder.CreateCondBr(issumtype, handlesumtypeblock, checkmatchblock);

					Builder.SetInsertPoint(handlesumtypeblock);

					Value* rt = Builder.CreateLoad(Builder.CreatePointerCast(reftargets[i], Type::getInt32PtrTy(Data->Context)));
					Builder.CreateStore(rt, providedtypeholders[typematchindex][i]);

					if(Metadata::GetTypeFamily(expecttype) == Metadata::EpochTypeFamily_SumType)
					{
						Builder.CreateStore(reftargets[i], parampayloadptrs[typematchindex][i]);
					}
					else
					{
						Value* gep = Builder.CreateGEP(reftargets[i], ConstantInt::get(Type::getInt32Ty(Data->Context), sizeof(Metadata::EpochTypeID)));
						Builder.CreateStore(gep, parampayloadptrs[typematchindex][i]);
					}
					Builder.CreateBr(checkmatchblock);

					Builder.SetInsertPoint(checkmatchblock);

					Value* nomatch = Builder.CreateICmpNE(Builder.CreateLoad(providedtypeholders[typematchindex][i]), ConstantInt::get(Type::getInt32Ty(Data->Context), expecttype));
					Value* notexpectsumtype = ConstantInt::get(Type::getInt1Ty(Data->Context), Metadata::GetTypeFamily(expecttype) != Metadata::EpochTypeFamily_SumType);

					BasicBlock* nextparamblock = BasicBlock::Create(Data->Context, "nextparam", matcherfunction);

					Value* bailflag = Builder.CreateAnd(nomatch, notexpectsumtype);
					Builder.CreateCondBr(bailflag, nexttypematcher, nextparamblock);

					Builder.SetInsertPoint(nextparamblock);

					if(expecttype != Metadata::EpochType_Nothing)
					{
						Value* v = Builder.CreatePointerCast(parampayloadptrs[typematchindex][i], GetLLVMType(expecttype)->getPointerTo()->getPointerTo());
						v = Builder.CreateLoad(v);

						if(!expectref)
							v = Builder.CreateLoad(v);

						actualparams.push_back(v);
					}
					else
					{
						actualparams.push_back(ConstantInt::get(Type::getInt32Ty(Data->Context), 0xbaadf00d));
					}
				}

				Function* targetinnerfunc = GetGeneratedFunction(funcname, matchoffset);

				std::vector<Value*> resolvedargs;
				for(std::vector<Value*>::const_iterator argiter = actualparams.begin(); argiter != actualparams.end(); ++argiter)
					resolvedargs.push_back(*argiter);
				std::reverse(resolvedargs.begin(), resolvedargs.end());

				if(targetinnerfunc->getReturnType() != Type::getVoidTy(Data->Context))
				{
					CallInst* typematchret = Builder.CreateCall(targetinnerfunc, resolvedargs);
					Builder.CreateRet(typematchret);
				}
				else
				{
					Builder.CreateCall(targetinnerfunc, resolvedargs);
					Builder.CreateRetVoid();
				}

				Builder.SetInsertPoint(nexttypematcher);
			}

			++typematchindex;
			break;

		default:
			throw FatalException("Invalid instruction in type matcher");
		}
	}
}



void NativeCodeGenerator::AddNativePatternMatcher(size_t beginoffset, size_t endoffset)
{
	Function* matcherfunction = Builder.GetInsertBlock()->getParent();
	std::vector<Value*> argholders;

	unsigned matchindex = 0;
	StringHandle entityname = 0;

	for(size_t offset = beginoffset; offset <= endoffset; )
	{
		Bytecode::Instruction instruction = Bytecode[offset++];
		switch(instruction)
		{
		case Bytecode::Instructions::BeginEntity:
			Fetch<Integer32>(Bytecode, offset);
			entityname = Fetch<StringHandle>(Bytecode, offset);
			break;

		case Bytecode::Instructions::EndEntity:
			break;

		case Bytecode::Instructions::Halt:
			Builder.CreateCall(Data->BuiltInFunctions[JITFunc_VM_Halt]);
			Builder.CreateUnreachable();
			break;

		case Bytecode::Instructions::PatternMatch:
			{
				StringHandle targetfunc = Fetch<StringHandle>(Bytecode, offset);
				size_t internaloffset = Fetch<size_t>(Bytecode, offset);
				size_t paramcount = Fetch<size_t>(Bytecode, offset);

				std::vector<Value*> actualparams;
				BasicBlock* nextmatcher = BasicBlock::Create(Data->Context, "nextmatcher", matcherfunction);

				Function::arg_iterator argiter = matcherfunction->arg_begin();

				if(argholders.empty())
				{
					for(size_t i = 0; i < paramcount; ++i)
					{
						Value* argument = argiter;
						++argiter;

						argholders.push_back(argument);
					}
				}

				for(size_t i = 0; i < paramcount; ++i)
				{
					Metadata::EpochTypeID paramtype = Fetch<Metadata::EpochTypeID>(Bytecode, offset);
					Byte needsmatch = Fetch<Byte>(Bytecode, offset);

					BasicBlock* nextparamblock = BasicBlock::Create(Data->Context, "nextparam", matcherfunction);
					
					if(needsmatch)
					{
						Value* eq = NULL;

						switch(paramtype)
						{
						case Metadata::EpochType_Integer:
							{
								Integer32 value = Fetch<Integer32>(Bytecode, offset);
								Value* constval = ConstantInt::get(Type::getInt32Ty(Data->Context), value);
								eq = Builder.CreateICmpEQ(constval, argholders[i]);
							}
							break;

						default:
							throw NotImplementedException("Cannot JIT pattern matcher of this type");
						}

						Builder.CreateCondBr(eq, nextparamblock, nextmatcher);
					}
					else
					{
						actualparams.push_back(argholders[i]);
						Builder.CreateBr(nextparamblock);						
					}

					Builder.SetInsertPoint(nextparamblock);
				}

				Function* targetinnerfunc = GetGeneratedFunction(targetfunc, internaloffset);

				std::vector<Value*> resolvedargs;
				for(std::vector<Value*>::const_reverse_iterator argiter = actualparams.rbegin(); argiter != actualparams.rend(); ++argiter)
					resolvedargs.push_back(*argiter);

				if(targetinnerfunc->getReturnType() != Type::getVoidTy(Data->Context))
				{
					CallInst* matchret = Builder.CreateCall(targetinnerfunc, resolvedargs);
					Builder.CreateRet(matchret);
				}
				else
				{
					Builder.CreateCall(targetinnerfunc, resolvedargs);
					Builder.CreateRetVoid();
				}

				Builder.SetInsertPoint(nextmatcher);
			}

			++matchindex;
			break;

		default:
			throw FatalException("Invalid instruction in pattern matcher");
		}
	}
}


Value* NativeCodeGenerator::MarshalArgument(Value* arg, Metadata::EpochTypeID type)
{
	switch(type)
	{
	case Metadata::EpochType_Boolean:
		return Builder.CreateCast(Instruction::SExt, arg, Type::getInt32Ty(Data->Context));

	case Metadata::EpochType_Buffer:
		return Builder.CreateCall(Data->BuiltInFunctions[JITFunc_VM_GetBuffer], arg);

	case Metadata::EpochType_Integer:
	case Metadata::EpochType_Integer16:
	case Metadata::EpochType_Real:
		return arg;

	case Metadata::EpochType_String:
		return Builder.CreateCall(Data->BuiltInFunctions[JITFunc_VM_GetString], arg);
	}

	Metadata::EpochTypeFamily family = Metadata::GetTypeFamily(type);
	if(family == Metadata::EpochTypeFamily_Structure || family == Metadata::EpochTypeFamily_TemplateInstance)
		return Builder.CreateCall(Data->BuiltInFunctions[JITFunc_Marshal_ConvertStructure], arg);

	if(family == Metadata::EpochTypeFamily_Function)
		return Builder.CreatePointerCast(GetCallbackWrapper(arg), Type::getInt8PtrTy(Data->Context));

	throw NotImplementedException("Cannot marshal parameter of this type to an external function");
}

Value* NativeCodeGenerator::MarshalReturn(Value* ret, Metadata::EpochTypeID type)
{
	switch(type)
	{
	case Metadata::EpochType_Boolean:
		return Builder.CreateCast(Instruction::Trunc, ret, Type::getInt1Ty(Data->Context));

	case Metadata::EpochType_Buffer:
		// TODO
		break;

	case Metadata::EpochType_Integer:
	case Metadata::EpochType_Integer16:
	case Metadata::EpochType_Real:
		return ret;

	case Metadata::EpochType_String:
		// TODO
		break;
	}

	throw NotImplementedException("Cannot marshal parameter of this type to an external function");
}

void NativeCodeGenerator::MarshalReferencePostCall(Value* ref, Value* fixuptarget, Metadata::EpochTypeID type)
{
	Metadata::EpochTypeFamily family = Metadata::GetTypeFamily(type);

	switch(type)
	{
	case Metadata::EpochType_Boolean:
	case Metadata::EpochType_Integer:
	case Metadata::EpochType_Integer16:
	case Metadata::EpochType_Real:
	case Metadata::EpochType_Buffer:
	case Metadata::EpochType_String:
		return;
	}

	if(family == Metadata::EpochTypeFamily_Structure || family == Metadata::EpochTypeFamily_TemplateInstance)
	{
		Builder.CreateCall2(Data->BuiltInFunctions[JITFunc_Marshal_FixupStructure], ref, Builder.CreateLoad(fixuptarget));
		return;
	}

	throw NotImplementedException("Cannot marshal reference of this type back from an external function");
}

void NativeCodeGenerator::MarshalCleanup(Value* val, Metadata::EpochTypeID type)
{
	Metadata::EpochTypeFamily family = Metadata::GetTypeFamily(type);

	switch(type)
	{
	case Metadata::EpochType_Boolean:
	case Metadata::EpochType_Integer:
	case Metadata::EpochType_Integer16:
	case Metadata::EpochType_Real:
	case Metadata::EpochType_Buffer:
	case Metadata::EpochType_String:
		return;
	}

	if(family == Metadata::EpochTypeFamily_Structure || family == Metadata::EpochTypeFamily_TemplateInstance)
	{
		Builder.CreateCall(Data->BuiltInFunctions[JITFunc_Marshal_Cleanup], val);
		return;
	}

	if(family == Metadata::EpochTypeFamily_Function)
		return;

	throw NotImplementedException("Cannot clean up result of marshaling this type back from an external function");
}

Value* NativeCodeGenerator::GetCallbackWrapper(Value* funcptr)
{
	Type* ptrtype = funcptr->getType();
	PointerType* casttype = dyn_cast<PointerType>(ptrtype);
	FunctionType* ftype = dyn_cast<FunctionType>(casttype->getElementType());

	// TODO - marshal in and out of callbacks in the wrapper?
	std::vector<Type*> argtypes;
	for(size_t i = 0; i < ftype->getNumParams(); ++i)
		argtypes.push_back(ftype->getParamType(i));

	FunctionType* wraptype = FunctionType::get(ftype->getReturnType(), argtypes, false);

	Function* ret = Function::Create(wraptype, Function::ExternalLinkage, "CallbackWrapper", Data->CurrentModule);
	ret->setCallingConv(CallingConv::X86_StdCall);

	Constant* constnull = ConstantPointerNull::get(casttype);
	Value* globalfuncptr = new GlobalVariable(*Data->CurrentModule, funcptr->getType(), false, GlobalVariable::InternalLinkage, constnull);
	Builder.CreateStore(funcptr, globalfuncptr);
	GeneratedCallbackWrappers[globalfuncptr] = ret;
	return ret;
}

