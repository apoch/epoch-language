//
// The Epoch Language Project
// Epoch Development Tools - Compiler Core
//
// LLVM.EPOCH
// Link between Epoch compiler and LLVM bindings
//
// This module contains the logic for invoking the LLVM
// bindings in EpochLLVM.DLL. These APIs are configured
// to allow Epoch code to generate LLVM bitcode, invoke
// optimization passes, and of course emit machine code
// for compiled binaries.
//


type LLVMContextHandle : integer
type LLVMFunctionRef : integer
type LLVMFunctionType : integer
type LLVMType : integer
type LLVMBasicBlock : integer
type LLVMGlobalVar : integer
type LLVMAlloca : integer
type LLVMGEP : integer


structure LLVMBuildContext :
	LLVMContextHandle          Context,
	LLVMFunctionRef            EmittingFunction,
	BinaryTreeRoot<LLVMAlloca> LocalVariables




EpochLLVMInitialize : 																								[external("EpochLLVM.dll", "EpochLLVMInitialize")]

EpochLLVMContextCreate : -> LLVMContextHandle ret = 0 																[external("EpochLLVM.dll", "EpochLLVMContextCreate")]
EpochLLVMContextDestroy : LLVMContextHandle handle																	[external("EpochLLVM.dll", "EpochLLVMContextDestroy")]

EpochLLVMFunctionTypePush : LLVMContextHandle context																[external("EpochLLVM.dll", "EpochLLVMFunctionTypePush")]
EpochLLVMFunctionTypeCreate : LLVMContextHandle context, LLVMType rettype -> LLVMFunctionType ret = 0				[external("EpochLLVM.dll", "EpochLLVMFunctionTypeCreate")]

EpochLLVMFunctionCreate :
	LLVMContextHandle handle,
	string funcname,
	LLVMFunctionType functype
  ->
	LLVMFunctionRef ret = 0
  [external("EpochLLVM.dll", "EpochLLVMFunctionCreate")]

// TODO - this should return LLVMGlobalVar
EpochLLVMFunctionCreateThunk : LLVMContextHandle context, string name, LLVMFunctionType ty -> integer v = 0			[external("EpochLLVM.dll", "EpochLLVMFunctionCreateThunk")]

EpochLLVMFunctionQueueParamType : LLVMContextHandle context, LLVMType t												[external("EpochLLVM.dll", "EpochLLVMFunctionQueueParamType")]

EpochLLVMFunctionFinalize : LLVMContextHandle context																[external("EpochLLVM.dll", "EpochLLVMFunctionFinalize")]
EpochLLVMFunctionSetEntry : LLVMContextHandle context, LLVMFunctionRef func											[external("EpochLLVM.dll", "EpochLLVMFunctionSetEntry")]


EpochLLVMStructureQueueMemberType : LLVMContextHandle context, LLVMType t											[external("EpochLLVM.dll", "EpochLLVMStructureQueueMemberType")]
EpochLLVMStructureTypeCreate : LLVMContextHandle context, string structurename -> LLVMType t = 0					[external("EpochLLVM.dll", "EpochLLVMStructureTypeCreate")]


EpochLLVMTypeGetBoolean : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetBoolean")]
EpochLLVMTypeGetInteger : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetInteger")]
EpochLLVMTypeGetInteger16 : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetInteger16")]
EpochLLVMTypeGetInteger64 : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetInteger64")]
EpochLLVMTypeGetPointerTo : LLVMContextHandle context, LLVMType raw -> LLVMType t = 0								[external("EpochLLVM.dll", "EpochLLVMTypeGetPointerTo")]
EpochLLVMTypeGetPointerTo : LLVMContextHandle context, LLVMFunctionType raw -> LLVMType t = 0						[external("EpochLLVM.dll", "EpochLLVMTypeGetPointerTo")]
EpochLLVMTypeGetReal : LLVMContextHandle context -> LLVMType t = 0													[external("EpochLLVM.dll", "EpochLLVMTypeGetReal")]
EpochLLVMTypeGetString : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetString")]
EpochLLVMTypeGetVoid : LLVMContextHandle context -> LLVMType t = 0													[external("EpochLLVM.dll", "EpochLLVMTypeGetVoid")]

EpochLLVMEmitBinaryObject : LLVMContextHandle handle, buffer ref outbuffer, integer maxsize -> integer written = 0 	[external("EpochLLVM.dll", "EpochLLVMEmitBinaryObject")]

EpochLLVMSetThunkCallback : LLVMContextHandle handle, (func : string -> integer)                                    [external("EpochLLVM.dll", "EpochLLVMSetThunkCallback")]
EpochLLVMSetStringCallback : LLVMContextHandle handle, (func : integer -> integer)									[external("EpochLLVM.dll", "EpochLLVMSetStringCallback")]


EpochLLVMGetCurrentBasicBlock : LLVMContextHandle handle -> LLVMBasicBlock ret = 0									[external("EpochLLVM.dll", "EpochLLVMGetCurrentBasicBlock")]
EpochLLVMSetCurrentBasicBlock : LLVMContextHandle handle, LLVMBasicBlock block										[external("EpochLLVM.dll", "EpochLLVMSetCurrentBasicBlock")]


EpochLLVMCodeCreateBasicBlock :
	LLVMContextHandle handle,
	LLVMFunctionRef func,
	boolean setinsertpoint
  ->
	LLVMBasicBlock ret = 0
  [external("EpochLLVM.dll", "EpochLLVMCodeCreateBasicBlock")]
    
  
EpochLLVMCodeCreateAlloca : LLVMContextHandle handle, LLVMType vartype, string varname -> LLVMAlloca ret = 0		[external("EpochLLVM.dll", "EpochLLVMCodeCreateAlloca")]
EpochLLVMCodeCreateBranch : LLVMContextHandle handle, LLVMBasicBlock target, boolean setinsertpoint 				[external("EpochLLVM.dll", "EpochLLVMCodeCreateBranch")]
EpochLLVMCodeCreateCall : LLVMContextHandle handle, LLVMFunctionRef target -> integer ret = 0						[external("EpochLLVM.dll", "EpochLLVMCodeCreateCall")]
EpochLLVMCodeCreateCallIndirect : LLVMContextHandle handle, LLVMAlloca alloca										[external("EpochLLVM.dll", "EpochLLVMCodeCreateCallIndirect")]
EpochLLVMCodeCreateCallThunk : LLVMContextHandle handle, integer target -> integer ret = 0							[external("EpochLLVM.dll", "EpochLLVMCodeCreateCallThunk")]
EpochLLVMCodeCreateCondBranch : LLVMContextHandle handle, LLVMBasicBlock truetarget, LLVMBasicBlock falsetarget		[external("EpochLLVM.dll", "EpochLLVMCodeCreateCondBranch")]
EpochLLVMCodeCreateGEP : LLVMContextHandle handle, integer index -> LLVMGEP ret = 0									[external("EpochLLVM.dll", "EpochLLVMCodeCreateGEP")]
EpochLLVMCodeCreateRead : LLVMContextHandle handle, LLVMAlloca alloca												[external("EpochLLVM.dll", "EpochLLVMCodeCreateRead")]
EpochLLVMCodeCreateReadParam : LLVMContextHandle handle, integer index												[external("EpochLLVM.dll", "EpochLLVMCodeCreateReadParam")]
EpochLLVMCodeCreateReadStructure : LLVMContextHandle handle, LLVMGEP gep											[external("EpochLLVM.dll", "EpochLLVMCodeCreateReadStructure")]
EpochLLVMCodeCreateRet : LLVMContextHandle handle																	[external("EpochLLVM.dll", "EpochLLVMCodeCreateRet")]
EpochLLVMCodeCreateRetVoid : LLVMContextHandle handle																[external("EpochLLVM.dll", "EpochLLVMCodeCreateRetVoid")]
EpochLLVMCodeCreateWrite : LLVMContextHandle handle, LLVMAlloca alloca												[external("EpochLLVM.dll", "EpochLLVMCodeCreateWrite")]
EpochLLVMCodeCreateWriteParam : LLVMContextHandle handle, integer index												[external("EpochLLVM.dll", "EpochLLVMCodeCreateWriteParam")]
EpochLLVMCodeCreateWriteStructure : LLVMContextHandle handle, LLVMGEP gep											[external("EpochLLVM.dll", "EpochLLVMCodeCreateWriteStructure")]
EpochLLVMCodeCreateWriteStructurePop : LLVMContextHandle handle														[external("EpochLLVM.dll", "EpochLLVMCodeCreateWriteStructurePop")]

EpochLLVMCodeCreateDereference : LLVMContextHandle handle															[external("EpochLLVM.dll", "EpochLLVMCodeCreateDereference")]

EpochLLVMCodeStatementFinalize : LLVMContextHandle handle															[external("EpochLLVM.dll", "EpochLLVMCodeStatementFinalize")]

EpochLLVMCodeOperatorBooleanNot : LLVMContextHandle context															[external("EpochLLVM.dll", "EpochLLVMCodeOperatorBooleanNot")]
EpochLLVMCodeOperatorIntegerEquals : LLVMContextHandle context														[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerEquals")]
EpochLLVMCodeOperatorIntegerNotEquals : LLVMContextHandle context													[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerNotEquals")]
EpochLLVMCodeOperatorIntegerPlus : LLVMContextHandle context														[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerPlus")]
EpochLLVMCodeOperatorIntegerMinus : LLVMContextHandle context														[external("EpochLLVM.dll", "EpochLLVMCodeOperatorIntegerMinus")]

EpochLLVMCodePushBoolean : LLVMContextHandle context, boolean literal												[external("EpochLLVM.dll", "EpochLLVMCodePushBoolean")]
EpochLLVMCodePushInteger : LLVMContextHandle context, integer literal												[external("EpochLLVM.dll", "EpochLLVMCodePushInteger")]
EpochLLVMCodePushInteger16 : LLVMContextHandle context, integer16 literal											[external("EpochLLVM.dll", "EpochLLVMCodePushInteger16")]
EpochLLVMCodePushInteger64 : LLVMContextHandle context, integer literal												[external("EpochLLVM.dll", "EpochLLVMCodePushInteger64")]
EpochLLVMCodePushRawAlloca : LLVMContextHandle context, LLVMAlloca alloca											[external("EpochLLVM.dll", "EpochLLVMCodePushRawAlloca")]
EpochLLVMCodePushRawCall : LLVMContextHandle context, integer callinst												[external("EpochLLVM.dll", "EpochLLVMCodePushRawCall")]
EpochLLVMCodePushRawGEP : LLVMContextHandle context, LLVMGEP gep													[external("EpochLLVM.dll", "EpochLLVMCodePushRawGEP")]
EpochLLVMCodePushString : LLVMContextHandle context, integer handle													[external("EpochLLVM.dll", "EpochLLVMCodePushString")]
EpochLLVMCodePushFunction : LLVMContextHandle context, LLVMFunctionRef func											[external("EpochLLVM.dll", "EpochLLVMCodePushFunction")]


SetUpAllLLVMCode : LLVMContextHandle context
{	
	print("Generating LLVM structure types...")
	CodeGenRearrangeStructures(Structures)
	CreateAllStructuresInLLVM(context, Structures)
	
	print("Generating LLVM structure constructors...")
	CreateAllConstructorsInLLVM(context, Structures)
	
	print("Generating LLVM function signatures...")
	CreateAllFunctionSignaturesInLLVM(context, FunctionSignatures)

	print("Generating LLVM function thunks...")
	SetUpCustomLLVMThunks(context, GlobalRootNamespace.FunctionTags)
	
	print("Generating LLVM function implementations...")
	CreateAllFunctionsInLLVM(context, Functions)
}


CreateAllFunctionSignaturesInLLVM : LLVMContextHandle context, list<FunctionSignature> ref signatures
{
	if(signatures.value.Name != 0)
	{
		EpochLLVMFunctionTypePush(context)
		LLVMType funcrettype = GetLLVMTypeForEpochType(context, GetTypeByName(signatures.value.ReturnTypeName))
		CreateFunctionParamTypesInLLVM(context, signatures.value.Parameters, 0, false)

		LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
		BinaryTreeCreateOrInsert<LLVMFunctionType>(LLVMFunctionSignatureTable, signatures.value.Name, functype)
	}
	
	CreateAllFunctionSignaturesInLLVM(context, signatures.next)
}

CreateAllFunctionSignaturesInLLVM : LLVMContextHandle context, nothing



CreateAllFunctionsInLLVM : LLVMContextHandle context, list<FunctionDefinition> ref funcs
{
	if(!funcs.value.IsTemplate)
	{
		if(funcs.value.Name != 0)
		{
			CreateSingleFunctionInLLVM(context, funcs.value)
		}
	}

	CreateAllFunctionsInLLVM(context, funcs.next)
}

CreateAllFunctionsInLLVM : LLVMContextHandle context, nothing



CreateSingleFunctionInLLVM : LLVMContextHandle context, FunctionDefinition ref func
{
	string funcname = GetPooledString(func.Name)

	EpochLLVMFunctionTypePush(context)

	LLVMType funcrettype = GetLLVMTypeForEpochType(context, func.Return)
	
	integer rawname = 0
	if(listcontains(CustomConstructors, func.Name))
	{
		rawname = func.RawName
	}
	
	CreateFunctionParamTypesInLLVM(context, func.Params, rawname, false)
	
	LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
	LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, funcname, functype)

	BinaryTreeCreateOrInsert<LLVMFunctionRef>(LLVMFunctionTable, func.Name, llvmfunc)
}

CreateFunctionParamTypesInLLVM : LLVMContextHandle context, FunctionParams ref params, integer rawfuncname, boolean isthunk
{
	CreateFunctionParamTypesInLLVM(context, params.Params, rawfuncname, isthunk)
}

CreateFunctionParamTypesInLLVM : LLVMContextHandle context, list<UnresolvedParameter> ref params, integer rawfuncname, boolean isthunk
{
	if((MakeNonReferenceType(params.value.ResolvedType) == 0x01000000) && (rawfuncname != 0))
	{
		integer typeid = GetTypeByName(rawfuncname)
		LLVMType paramtype = GetLLVMTypeForEpochType(context, MakeReferenceType(typeid))
		EpochLLVMFunctionQueueParamType(context, paramtype)
	}
	else
	{
		LLVMType paramtype = GetLLVMTypeForEpochType(context, params.value.ResolvedType)
		EpochLLVMFunctionQueueParamType(context, paramtype)
	}
	
	CreateFunctionParamTypesInLLVM(context, params.next, rawfuncname, isthunk)
}

CreateFunctionParamTypesInLLVM : LLVMContextHandle context, nothing, integer rawfuncname, boolean isthunk


CreateFunctionParamTypesInLLVM : LLVMContextHandle context, list<Parameter> ref params, integer rawfuncname, boolean isthunk
{
	if(params.value.Name != 0)
	{
		LLVMType paramtype = GetLLVMTypeForEpochType(context, params.value.Type)
		EpochLLVMFunctionQueueParamType(context, paramtype)
	}	

	CreateFunctionParamTypesInLLVM(context, params.next, rawfuncname, isthunk)
}


GetLLVMTypeForEpochType : LLVMContextHandle context, Expression expr -> LLVMType t = GetLLVMTypeForEpochType(context, expr.Type)

GetLLVMTypeForEpochType : LLVMContextHandle context, integer typeid -> LLVMType t = 0
{
	boolean wasref = IsReferenceType(typeid)
	typeid = MakeNonReferenceType(typeid)
	
	while((typeid & 0x7f000000) == 0x05000000)
	{
		typeid = FindTypeAliasBase(typeid)
	}
	

	if(typeid == 0x01000001)
	{
		t = EpochLLVMTypeGetInteger(context)		
	}
	elseif(typeid == 0x01000002)
	{
		t = EpochLLVMTypeGetInteger16(context)
	}
	elseif(typeid == 0x01000003)
	{
		t = EpochLLVMTypeGetBoolean(context)
	}
	elseif(typeid == 0x01000004)
	{
		t = EpochLLVMTypeGetReal(context)
	}
	elseif(typeid == 0x01000005)
	{
		t = EpochLLVMTypeGetInteger64(context)
	}
	elseif(typeid == 0x02000000)
	{
		t = EpochLLVMTypeGetString(context)
	}
	elseif(IsStructureType(typeid))
	{
		boolean found = BinaryTreeCopyPayload<LLVMType>(LLVMStructureTypeTable.RootNode, typeid, t)
		assertmsg(found, "Structure type not registered with LLVM " ; GetPooledString(GetNameOfType(typeid)))
	}
	elseif(IsFunctionType(typeid))
	{
		LLVMFunctionType fty = 0
		boolean found = BinaryTreeCopyPayload<LLVMFunctionType>(LLVMFunctionSignatureTable.RootNode, typeid, fty)
		assertmsg(found, "Function signature not registered with LLVM")
		
		t = EpochLLVMTypeGetPointerTo(context, fty)
	}
	else
	{
		assertmsg(false, "Unsupported type for LLVM bindings: " ; GetPooledString(GetNameOfType(typeid)))
	}
	
	if(wasref)
	{
		t = EpochLLVMTypeGetPointerTo(context, t)
	}
}

GetLLVMTypeForEpochType : LLVMContextHandle context, nothing -> LLVMType t = EpochLLVMTypeGetVoid(context)



EmitAllFunctionsToLLVM : LLVMContextHandle context, list<FunctionDefinition> ref funcs
{
	if(!funcs.value.IsTemplate)
	{
		if(funcs.value.Name != 0)
		{
			EmitSingleFunctionToLLVM(context, funcs.value)
		}
	}

	EmitAllFunctionsToLLVM(context, funcs.next)
}

EmitAllFunctionsToLLVM : LLVMContextHandle context, nothing



CreateLLVMAllocasForScope : LLVMBuildContext ref context, Scope ref scope, FunctionDefinition ref func
{
	CreateLLVMAllocasForScope(context, scope.Variables, func)
}

CreateLLVMAllocasForScope : LLVMBuildContext ref context, list<Variable> ref variables, FunctionDefinition ref func
{
	if(variables.value.Name != 0)
	{
		CreateSingleLLVMAlloca(context, variables.value, func)
	}
	
	CreateLLVMAllocasForScope(context, variables.next, func)
}

CreateLLVMAllocasForScope : LLVMBuildContext ref context, nothing, FunctionDefinition ref func


CreateSingleLLVMAlloca : LLVMBuildContext ref context, Variable ref var, FunctionDefinition ref func
{
	if(var.VarType == 0x81000000)
	{
		if(listcontains(CustomConstructors, func.Name))
		{
			integer typeid = GetTypeByName(func.RawName)
			
			LLVMType vartype = GetLLVMTypeForEpochType(context.Context, MakeReferenceType(typeid))
			LLVMAlloca alloca = EpochLLVMCodeCreateAlloca(context.Context, vartype, GetPooledString(var.Name))
			BinaryTreeCreateOrInsert<LLVMAlloca>(context.LocalVariables, var.Name, alloca)
			
			return()
		}
	}
	
	LLVMType vartype = GetLLVMTypeForEpochType(context.Context, var.VarType)
	LLVMAlloca alloca = EpochLLVMCodeCreateAlloca(context.Context, vartype, GetPooledString(var.Name))
	BinaryTreeCreateOrInsert<LLVMAlloca>(context.LocalVariables, var.Name, alloca)
}



EmitRetInitializerToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, Expression ref expr -> LLVMAlloca ret = 0
{
	integer returnname = 0
	FindReturnVariableNameInSingleScope(func.AttachedScope.Wrapped, returnname)
	
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, returnname, alloca)
	
	EmitExpressionAtomsToLLVM(context, expr.Atoms)
	
	
	if(!IsStructureType(expr.Type))
	{
		EpochLLVMCodeCreateWrite(context.Context, alloca)
	}
	
	ret = alloca
}

EmitRetInitializerToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, nothing -> LLVMAlloca ret = 0


EmitParamInitializersToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, integer paramindex, FunctionParams ref params
{
	EmitParamInitializersToLLVM(context, func, paramindex, params.Params)
}

EmitParamInitializersToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, integer paramindex, list<UnresolvedParameter> ref params
{
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, params.value.NameHandle, alloca)
	
	EpochLLVMCodeCreateReadParam(context.Context, paramindex)
	EpochLLVMCodeCreateWrite(context.Context, alloca)

	EmitParamInitializersToLLVM(context, func, paramindex + 1, params.next)
}

EmitParamInitializersToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, integer paramindex, nothing


EmitSingleFunctionToLLVM : LLVMContextHandle context, FunctionDefinition ref func
{
	print("Generating LLVM code for function: " ; GetPooledString(func.Name))

	LLVMFunctionRef llvmfunc = 0
	BinaryTreeCopyPayload<LLVMFunctionRef>(LLVMFunctionTable.RootNode, func.Name, llvmfunc)

	LLVMBasicBlock funcbody = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, true)
	

	BinaryTreeRoot<LLVMAlloca> vartree = nothing
	LLVMBuildContext build = context, llvmfunc, vartree
	CreateLLVMAllocasForScope(build, func.AttachedScope.Wrapped, func)
	
	FindScopeAndSetContext(func)

	EmitParamInitializersToLLVM(build, func, 0, func.Params)
	LLVMAlloca ret = EmitRetInitializerToLLVM(build, func, func.Return)
		
	EmitExternalInvokeTagToLLVM(build, func, GlobalRootNamespace.FunctionTags, ret)
	
	EmitCodeBlockToLLVM(build, func.Code)
	
	if(listcontains(CustomConstructors, func.Name))
	{
		integer returnname = 0
		FindReturnVariableNameInSingleScope(func.AttachedScope.Wrapped, returnname)
		
		LLVMAlloca alloca = 0
		BinaryTreeCopyPayload<LLVMAlloca>(vartree.RootNode, returnname, alloca)
		
		EpochLLVMCodeCreateRead(context, alloca)
		EpochLLVMCodeCreateWriteParam(context, 0)
	}
	
	if(func.AnonymousReturn)
	{
		EmitReturnRegisterToLLVMAnonymous(build, func.Return)
	}
	else
	{
		EmitReturnRegisterToLLVM(build, func, func.Return)
	}
		
	string funcname = GetPooledString(func.Name)
	if(funcname == "entrypoint")
	{
		EpochLLVMFunctionSetEntry(context, llvmfunc)
	}
	
	EpochLLVMFunctionFinalize(context)
}

EmitAllParamsToLLVM : LLVMContextHandle context, integer paramindex, FunctionParams ref params
{
	EmitAllParamsToLLVM(context, paramindex, params.Params)
}


EmitAllParamsToLLVM : LLVMContextHandle context, integer paramindex, list<UnresolvedParameter> ref params
{
	EpochLLVMCodeCreateReadParam(context, paramindex)
	EmitAllParamsToLLVM(context, paramindex + 1, params.next)
}

EmitAllParamsToLLVM : LLVMContextHandle context, integer paramindex, nothing


EmitExternalInvokeTagToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, list<FunctionTag> ref taglist, LLVMAlloca ret
{
	if(taglist.value.FunctionName == func.Name)
	{
		if(taglist.value.TagName == "external")
		{
			EmitAllParamsToLLVM(context.Context, 0, func.Params)

			integer thunk = 0
			BinaryTreeCopyPayload<integer>(LLVMGlobalThunks.RootNode, func.Name, thunk)
			
			assertmsg(thunk != 0, "Missing external thunk")
			integer callinst = EpochLLVMCodeCreateCallThunk(context.Context, thunk)
			
			if(GetOptionalExpressionType(func.Return) != 0)
			{
				EpochLLVMCodePushRawCall(context.Context, callinst)
				EpochLLVMCodeCreateWrite(context.Context, ret)
			}
			
			return()
		}
	}

	EmitExternalInvokeTagToLLVM(context, func, taglist.next, ret)
}

EmitExternalInvokeTagToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, nothing, LLVMAlloca ret



EmitCodeBlockToLLVM : LLVMBuildContext ref context, CodeBlock ref code
{
	EmitCodeBlockEntriesToLLVM(context, code.Entries)
}

EmitCodeBlockToLLVM : LLVMBuildContext ref context, nothing


EmitReturnRegisterToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, Expression ref expr
{
	integer returnname = 0
	FindReturnVariableNameInSingleScope(func.AttachedScope.Wrapped, returnname)
	
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, returnname, alloca)
	
	EpochLLVMCodeCreateRead(context.Context, alloca)
	EpochLLVMCodeCreateRet(context.Context)
}

EmitReturnRegisterToLLVM : LLVMBuildContext ref context, FunctionDefinition ref func, nothing
{
	EpochLLVMCodeCreateRetVoid(context.Context)
}


EmitReturnRegisterToLLVMAnonymous : LLVMBuildContext ref context, Expression ref expr
{
	EmitExpressionAtomsToLLVM(context, expr.Atoms)
	EpochLLVMCodeCreateRet(context.Context)
}


EmitReturnRegisterToLLVMAnonymous : LLVMBuildContext ref context, nothing
{
	EpochLLVMCodeCreateRetVoid(context.Context)
}



EmitCodeBlockEntriesToLLVM : LLVMBuildContext ref context, list<CodeBlockEntry> ref entries
{
	EmitSingleCodeBlockEntryToLLVM(context, entries.value)
	EmitCodeBlockEntriesToLLVM(context, entries.next)
}

EmitCodeBlockEntriesToLLVM : LLVMBuildContext ref context, nothing




EmitAssignmentRHSToLLVM : LLVMBuildContext ref context, Assignment ref entry
{
	EmitSingleCodeBlockEntryToLLVM(context, entry)
	
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, entry.LHSName, alloca)

	EpochLLVMCodeCreateRead(context.Context, alloca)
}

EmitAssignmentRHSToLLVM : LLVMBuildContext ref context, Expression ref expr
{
	EmitExpressionAtomsToLLVM(context, expr)
}



EmitSingleCodeBlockEntryToLLVM : LLVMBuildContext ref context, Assignment ref entry
{
	assertmsg(entry.Operator == PooledStringHandleForAssignment, "Unsupported assignment operator")
	
	EmitAssignmentRHSToLLVM(context, entry.RHS)
		
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, entry.LHSName, alloca)

	EpochLLVMCodeCreateWrite(context.Context, alloca)
}


EmitSingleCodeBlockEntryToLLVM : LLVMBuildContext ref context, AssignmentCompound ref entry
{
	assertmsg(entry.Operator == PooledStringHandleForAssignment, "Unsupported assignment operator")

	EmitAssignmentRHSToLLVM(context, entry.RHS)
	
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, entry.LHS.value, alloca)
	
	integer typeid = MakeNonReferenceType(FindVariableType(entry.LHS.value))

	integer structurename = GetNameOfStructureByType(typeid)
	EpochLLVMCodePushRawAlloca(context.Context, alloca)
	EmitAssignmentLHSGEPsToLLVM(context, entry.LHS.next, structurename)
	
	EpochLLVMCodeCreateWriteStructurePop(context.Context)
}


EmitSingleCodeBlockEntryToLLVM : LLVMBuildContext ref context, Statement ref entry
{
	// TODO - see if we still need type annotation logic, see CodeGenEmitSingleCodeBlockEntry and sum-type construction
	
	if(IsRecognizedBuiltIn(entry.Name))
	{
		if(GetTypeByName(entry.Name) == 0)
		{
			EmitExpressionListToLLVM(context, entry.Parameters)
			
			integer thunk = 0
			BinaryTreeCopyPayload<integer>(LLVMGlobalThunks.RootNode, entry.Name, thunk)
			EpochLLVMCodeCreateCallThunk(context.Context, thunk)
		}
		else
		{
			integer varname = ExtractConstructorIdentifier(entry.Parameters)
			assertmsg(varname != 0, "Couldn't find variable to initialize")
						
			LLVMAlloca alloca = 0
			BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, varname, alloca)
			assertmsg(alloca != 0, "Couldn't find LLVM binding alloca to initialize")
			
			EmitPartialExpressionListToLLVM(context, entry.Parameters)
			EpochLLVMCodeCreateWrite(context.Context, alloca)
			
			EmitExpressionListToLLVM(context, entry.Parameters)
		}
	}
	elseif(SumTypeExists(entry.Name))
	{
		// TODO - LLVM sum type implementation
		//BytecodeConstructSumType(stream)
	}
	else
	{
		EmitExpressionListToLLVM(context, entry.Parameters)

		integer vartype = GetVariableTypeFromScope(EmittingScope.Wrapped, entry.Name)
		if((vartype & 0x7f000000) == 0x09000000)
		{
			LLVMAlloca fpalloca = 0
			BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, entry.Name, fpalloca)
			assertmsg(fpalloca != 0, "Missing higher order function parameter")
			
			EpochLLVMCodeCreateCallIndirect(context.Context, fpalloca)
		}
		else
		{
			LLVMFunctionRef llvmfunc = 0
			BinaryTreeCopyPayload<LLVMFunctionRef>(LLVMFunctionTable.RootNode, entry.Name, llvmfunc)
			
			if(llvmfunc == 0)
			{
				assertmsg(llvmfunc != 0, "Failed to map LLVM function " ; GetPooledString(entry.Name))
			}
			
			EpochLLVMCodeCreateCall(context.Context, llvmfunc)
		}
	}
	
	if(entry.TopLevel)
	{
		EpochLLVMCodeStatementFinalize(context.Context)
	}
}

EmitSingleCodeBlockEntryToLLVM : LLVMBuildContext ref context, EntityChain ref entry
{
	EmitEntityChainEntriesToLLVM(context, entry.Entries)
}

EmitEntityChainEntriesToLLVM : LLVMBuildContext ref context, EntityList ref entitylist
{
	EmitEntityChainEntriesToLLVM(context, entitylist.ActualList)
}

EmitEntityChainEntriesToLLVM : LLVMBuildContext ref context, list<Entity> ref entities
{
	boolean entityiforelse = false
	
	if(entities.value.Tag == 0x11)
	{
		entityiforelse = true
	}
		
	if(entities.value.Tag == 0x12)
	{
		entityiforelse = true
	}

	if(entityiforelse)			// if/elseif
	{
		EmitExpressionAtomsToLLVM(context, entities.value.Param)
		
		LLVMBasicBlock currentinsertpoint = EpochLLVMGetCurrentBasicBlock(context.Context)
		
		LLVMBasicBlock falseblock = EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, false)
		LLVMBasicBlock mergeblock = EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, false)
		
		LLVMBasicBlock trueblock = EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, true)
		EmitCodeBlockToLLVM(context, entities.value.Code)
		EpochLLVMCodeCreateBranch(context.Context, mergeblock, false)
				
		EpochLLVMSetCurrentBasicBlock(context.Context, currentinsertpoint)
		EpochLLVMCodeCreateCondBranch(context.Context, trueblock, falseblock)
		
		EpochLLVMSetCurrentBasicBlock(context.Context, falseblock)
		EmitEntityChainEntriesToLLVM(context, entities.next)
		EpochLLVMCodeCreateBranch(context.Context, mergeblock, true)
	}
	elseif(entities.value.Tag == 0x13)		// else
	{
		EmitCodeBlockToLLVM(context, entities.value.Code)
	}
	elseif(entities.value.Tag == 0x14)		// while
	{		
		LLVMBasicBlock condblock = EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, false)
		LLVMBasicBlock loopblock = EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, false)
		LLVMBasicBlock mergeblock = EpochLLVMCodeCreateBasicBlock(context.Context, context.EmittingFunction, false)

		EpochLLVMCodeCreateBranch(context.Context, condblock, true)
		
		EmitExpressionAtomsToLLVM(context, entities.value.Param)		
		EpochLLVMCodeCreateCondBranch(context.Context, loopblock, mergeblock)
		
		EpochLLVMSetCurrentBasicBlock(context.Context, loopblock)
		EmitCodeBlockToLLVM(context, entities.value.Code)
		EpochLLVMCodeCreateBranch(context.Context, condblock, false)
		
		EpochLLVMSetCurrentBasicBlock(context.Context, mergeblock)
	}
	elseif(entities.value.Tag == 0)
	{
		EmitEntityChainEntriesToLLVM(context, entities.next)
	}
}



EmitEntityChainEntriesToLLVM : LLVMBuildContext ref context, nothing



// TODO - remaining code block entry types


EmitExpressionListToLLVM : LLVMBuildContext ref context, nothing

EmitExpressionListToLLVM : LLVMBuildContext ref context, ExpressionList ref exprs
{
	EmitExpressionListToLLVM(context, exprs.Expressions)
}

EmitExpressionListToLLVM : LLVMBuildContext ref context, list<Expression> ref exprs
{
	EmitExpressionAtomsToLLVM(context, exprs.value.Atoms)
	EmitExpressionListToLLVM(context, exprs.next)
}


EmitPartialExpressionListToLLVM : LLVMBuildContext ref context, ExpressionList ref exprs
{
	EmitExpressionListToLLVM(context, exprs.Expressions.next)
}


EmitExpressionAtomsToLLVM : LLVMBuildContext ref context, Expression ref expr
{
	EmitExpressionAtomsToLLVM(context, expr.Atoms)
}

EmitExpressionAtomsToLLVM : LLVMBuildContext ref context, list<ExpressionAtom> ref atoms
{
	// TODO - expand this to support all the nifty stuff atoms can do
	
	EmitSingleAtomToLLVM(context, atoms.value)
	EmitExpressionAtomsToLLVM(context, atoms.next)
}

EmitExpressionAtomsToLLVM : LLVMBuildContext ref context, nothing


EmitSingleAtomToLLVM : LLVMBuildContext ref context, AtomSentinel ref sentinel


EmitSingleAtomToLLVM : LLVMBuildContext ref context, integer ref literal
{
	EpochLLVMCodePushInteger(context.Context, literal)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, integer16 ref literal
{
	EpochLLVMCodePushInteger16(context.Context, literal)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, integer64 ref literal
{
	EpochLLVMCodePushInteger64(context.Context, literal.dummy)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, boolean ref literal
{
	EpochLLVMCodePushBoolean(context.Context, literal)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, StringHandleAtom ref literal
{
	EpochLLVMCodePushString(context.Context, literal.Handle)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, Statement ref statement
{
	EmitSingleCodeBlockEntryToLLVM(context, statement)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, IdentifierAtom ref idatom
{
	integer atomtype = MakeNonReferenceType(idatom.Type)

	if(atomtype == 0x00000004)							// Nothing type signature
	{
		EpochLLVMCodePushInteger(context.Context, 0)
	}
	else
	{
		if(idatom.IsFunction)
		{
			LLVMFunctionRef func = 0
			BinaryTreeCopyPayload<LLVMFunctionRef>(LLVMFunctionTable.RootNode, idatom.Handle, func)
			assertmsg(func != 0, "Missing function used as higher-order parameter")
			
			EpochLLVMCodePushFunction(context.Context, func)
		}
		elseif(GetTypeByName(idatom.Handle) != 0)
		{
			EpochLLVMCodePushString(context.Context, idatom.Handle)
		}
		else
		{
			if(atomtype == 0x01000000)					// Identifier type signature
			{
				if(!IsReferenceType(idatom.Type))
				{
					EpochLLVMCodePushString(context.Context, idatom.Handle)
				}
				else
				{
					LLVMAlloca alloca = 0
					BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, idatom.Handle, alloca)

					EpochLLVMCodePushRawAlloca(context.Context, alloca)
				}
			}
			elseif((atomtype & 0x7f000000) == 0x09000000)			// Function type family signature
			{
				LLVMFunctionRef func = 0
				BinaryTreeCopyPayload<LLVMFunctionRef>(LLVMFunctionTable.RootNode, idatom.Handle, func)
				assertmsg(func != 0, "Missing function used as higher-order parameter")
				
				EpochLLVMCodePushFunction(context.Context, func)
			}
			else
			{
				LLVMAlloca alloca = 0
				BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, idatom.Handle, alloca)

				if(idatom.IsReference)
				{
					EpochLLVMCodePushRawAlloca(context.Context, alloca)
				}
				else
				{	
					EpochLLVMCodeCreateRead(context.Context, alloca)
				}
					
				Variable var = 0, 0, 0, 0
				FindVariableDataInSingleScope(EmittingScope.Wrapped, idatom.Handle, var)
				assertmsg(var.Name != 0, "Missing local variable")
				
				if(IsReferenceType(var.VarType))
				{
					EpochLLVMCodeCreateDereference(context.Context)
				}
					
					
					//integer frames = 0
					//integer index = FindVariable(idatom.Handle, frames)

					//if(frames == 0)
					//{
					//	BytecodePushVarValue(stream, idatom.Handle, idatom.Type)
					//}
					//elseif(IsReferenceType(idatom.Type))
					//{
					//	BytecodeBindReference(stream, frames, index)
					//}
					//else
					//{
					//	Variable var = 0, 0, 0, 0
					//	FindVariableDataInSingleScope(GlobalScope.Wrapped, idatom.Handle, var)

					//	if(var.Name == 0)
					//	{
					//		print("Code generation error - missing local variable " ; GetPooledString(idatom.Handle) ; " in scope " ; GetPooledString(EmittingFunctionName))
					//		assert(false)
					//	}
						
					//	BytecodePushLocal(stream, frames, var.Offset)
					//}
			}
		}
	}
}


EmitSingleAtomToLLVM : LLVMBuildContext ref context, OperatorInvokeAtom ref atom
{
	if(atom.OperatorName == PooledStringHandleForUnaryNotBoolean)
	{
		EpochLLVMCodeOperatorBooleanNot(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForEqualityInteger)
	{
		EpochLLVMCodeOperatorIntegerEquals(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForEqualityInteger16)
	{
		EpochLLVMCodeOperatorIntegerEquals(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForInequalityInteger)
	{
		EpochLLVMCodeOperatorIntegerNotEquals(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForPlusInteger)
	{
		EpochLLVMCodeOperatorIntegerPlus(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForMinusInteger)
	{
		EpochLLVMCodeOperatorIntegerMinus(context.Context)
	}
	elseif(atom.OperatorName == PooledStringHandleForStringConcat)
	{
		integer thunk = 0
		BinaryTreeCopyPayload<integer>(LLVMGlobalThunks.RootNode, atom.OperatorName, thunk)
		
		assertmsg(thunk != 0, "Missing external thunk")
		EpochLLVMCodeCreateCallThunk(context.Context, thunk)
	}
	else
	{
		assertmsg(false, "Operator not implemented in LLVM bindings")
	}
}


EmitSingleAtomToLLVM : LLVMBuildContext ref context, RefBinding ref atom
{
	integer index = GetStructureMemberIndex(atom.StructureName, atom.Identifier)
	
	LLVMGEP gep = EpochLLVMCodeCreateGEP(context.Context, index)
	EpochLLVMCodePushRawGEP(context.Context, gep)
}

EmitSingleAtomToLLVM : LLVMBuildContext ref context, CompoundAtom ref atom
{
	LLVMAlloca alloca = 0
	BinaryTreeCopyPayload<LLVMAlloca>(context.LocalVariables.RootNode, atom.Bindings.value.Identifier, alloca)

	EpochLLVMCodePushRawAlloca(context.Context, alloca)
	
	EmitCompoundBindingsToLLVM(context, atom.Bindings, atom.Bindings.next)

	if(!IsReferenceType(atom.Type))
	{
		if((atom.Type & 0x7f000000) == 0x07000000)
		{
			// TODO - sum type annotations?
			//BytecodeReadReferenceAnnotated(stream)
		}
		else
		{
			EpochLLVMCodeCreateDereference(context.Context)
		}
	}
}





EmitCompoundBindingsToLLVM : LLVMBuildContext ref context, list<RefBinding> ref bindings, list<RefBinding> ref tail
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(EmittingScope.Wrapped, bindings.value.Identifier, var)

	assertmsg(var.VarType != 0, "Compound bindings reference bogus variable")
	integer lhstypename = GetNameOfType(var.VarType)
	integer index = GetStructureMemberIndex(lhstypename, tail.value.Identifier)
	
	LLVMGEP gep = EpochLLVMCodeCreateGEP(context.Context, index)
	EpochLLVMCodePushRawGEP(context.Context, gep)

	EmitCompoundSubsequentBindingsToLLVM(context, tail.next)
}

EmitCompoundSubsequentBindingsToLLVM : LLVMBuildContext ref context, nothing

EmitCompoundSubsequentBindingsToLLVM : LLVMBuildContext ref context, list<RefBinding> ref bindings
{
	EmitSingleAtomToLLVM(context, bindings.value)
	EmitCompoundSubsequentBindingsToLLVM(context, bindings.next)
}








SetUpBuiltInLLVMThunks : LLVMContextHandle context
{
	BuiltInThunkCreateAssert(context)
	BuiltInThunkCreatePasstest(context)
	BuiltInThunkCreatePrint(context)
	BuiltInThunkCreateStringConcat(context)
}


SetUpCustomLLVMThunks : LLVMContextHandle context, list<FunctionTag> ref taglist
{
	if(taglist.value.TagName == "external")
	{
		string libname = ""
		string thunkname = ""
		string callconv = ""
		
		copyfromlist<string>(taglist.value.Parameters, 1, libname)
		copyfromlist<string>(taglist.value.Parameters, 2, thunkname)
		copyfromlist<string>(taglist.value.Parameters, 3, callconv)

		SetUpSingleLLVMThunk(context, Functions, taglist.value.FunctionName, thunkname, callconv)
		
		ThunkTableAddEntry(GlobalThunkTable, libname, thunkname)
	}
	
	SetUpCustomLLVMThunks(context, taglist.next)
}

SetUpCustomLLVMThunks : LLVMContextHandle context, nothing


SetUpSingleLLVMThunk : LLVMContextHandle context, list<FunctionDefinition> ref funcs, integer funcname, string thunkname, string callconv
{
	if(funcs.value.Name == funcname)
	{
		EpochLLVMFunctionTypePush(context)
		LLVMType funcrettype = GetLLVMTypeForEpochType(context, funcs.value.Return)
		CreateFunctionParamTypesInLLVM(context, funcs.value.Params, 0, true)
		LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, funcrettype)
		
		integer thunk = EpochLLVMFunctionCreateThunk(context, thunkname, fty)

		BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, funcname, thunk)
	}
	else
	{
		SetUpSingleLLVMThunk(context, funcs.next, funcname, thunkname, callconv)
	}
}



BuiltInThunkCreateAssert : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetBoolean(context))
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_assert", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForAssert, thunk)
}

BuiltInThunkCreatePasstest : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_passtest", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForPassTest, thunk)
}

BuiltInThunkCreatePrint : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context))
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_print", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForPrint, thunk)
}

BuiltInThunkCreateStringConcat : LLVMContextHandle context
{
	EpochLLVMFunctionTypePush(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context))
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context))
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetString(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_string_concat", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForStringConcat, thunk)
}




CreateAllStructuresInLLVM : LLVMContextHandle context, list<StructureDefinition> ref structures
{
	CreateAllStructuresInLLVM(context, structures.next)

	if(structures.value.Name != 0)
	{
		CreateStructureMembersInLLVM(context, structures.value.Members)
		LLVMType sty = EpochLLVMStructureTypeCreate(context, GetPooledString(structures.value.Name))

		BinaryTreeCreateOrInsert<LLVMType>(LLVMStructureTypeTable, structures.value.Type, sty)
	}
}


CreateAllStructuresInLLVM : LLVMContextHandle context, nothing



CreateStructureMembersInLLVM : LLVMContextHandle context, list<StructureMember> ref members
{
	EpochLLVMStructureQueueMemberType(context, GetLLVMTypeForMemberType(context, members.value))
	CreateStructureMembersInLLVM(context, members.next)
}

CreateStructureMembersInLLVM : LLVMContextHandle context, nothing


GetLLVMTypeForMemberType : LLVMContextHandle context, StructureMemberVariable ref member -> LLVMType t = GetLLVMTypeForEpochType(context, member.Type)
GetLLVMTypeForMemberType : LLVMContextHandle context, StructureMemberFunctionRef ref member -> LLVMType t = 0
{
	EpochLLVMFunctionTypePush(context)

	LLVMType funcrettype = GetLLVMTypeForEpochType(context, GetTypeByName(member.Signature.ReturnTypeName))
	CreateFunctionParamTypesInLLVM(context, member.Signature.Parameters, 0, false)
	
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, funcrettype)
	t = EpochLLVMTypeGetPointerTo(context, fty)
}





HACKdummyconstructor : LLVMContextHandle context, list<StructureDefinition> ref structures
{
	EpochLLVMFunctionTypePush(context)
	LLVMType funcrettype = EpochLLVMTypeGetVoid(context)
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, GetLLVMTypeForEpochType(context, structures.value.Type)))
	CreateMemberParamTypesInLLVM(context, structures.value.Members)
	LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
	LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, GetPooledString(structures.value.ConstructorName), functype)
	BinaryTreeCreateOrInsert<LLVMFunctionRef>(LLVMFunctionTable, structures.value.ConstructorName, llvmfunc)
	LLVMBasicBlock funcbody = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, true)
	
	EpochLLVMCodePushInteger64(context, 0)
	EpochLLVMCodeCreateWriteParam(context, 0)
	
	EpochLLVMCodeCreateRetVoid(context)
}


HACKdummyanonconstructor : LLVMContextHandle context, StructureDefinition ref struct
{
	EpochLLVMFunctionTypePush(context)
	LLVMType funcrettype = GetLLVMTypeForEpochType(context, struct.Type)
	CreateMemberParamTypesInLLVM(context, struct.Members)
	
	LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
	LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, GetPooledString(struct.AnonConstructorName), functype)
	
	BinaryTreeCreateOrInsert<LLVMFunctionRef>(LLVMFunctionTable, struct.AnonConstructorName, llvmfunc)
	
	
	LLVMBasicBlock funcbody = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, true)
	LLVMAlloca retalloca = EpochLLVMCodeCreateAlloca(context, funcrettype, "@anonymous")
		
	EpochLLVMCodePushRawAlloca(context, retalloca)
	EpochLLVMCodeCreateDereference(context)
	EpochLLVMCodeCreateRet(context)
}

HACKdummycopyconstructor : LLVMContextHandle context, StructureDefinition ref struct
{
	EpochLLVMFunctionTypePush(context)
	LLVMType funcrettype = EpochLLVMTypeGetVoid(context)
	
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, GetLLVMTypeForEpochType(context, struct.Type)))
	EpochLLVMFunctionQueueParamType(context, GetLLVMTypeForEpochType(context, struct.Type))
	//EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, GetLLVMTypeForEpochType(context, struct.Type)))

	LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
	LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, GetPooledString(struct.CopyConstructorName), functype)
	
	BinaryTreeCreateOrInsert<LLVMFunctionRef>(LLVMFunctionTable, struct.CopyConstructorName, llvmfunc)
	
	
	LLVMBasicBlock funcbody = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, true)

	EpochLLVMCodeCreateReadParam(context, 1)
	//EpochLLVMCodeCreateDereference(context)
	EpochLLVMCodeCreateWriteParam(context, 0)
	EpochLLVMCodeCreateRetVoid(context)
}


CreateAllConstructorsInLLVM : LLVMContextHandle context, list<StructureDefinition> ref structures
{
	if((structures.value.Name != 0) && (!structures.value.IsTemplate))
	{
		if(GetPooledString(structures.value.Name) == "OPAQUE")
		{
			// TODO - destroy this hack once integer64 support is implemented
			
			HACKdummyconstructor(context, structures)
			HACKdummyanonconstructor(context, structures.value)
			if(structures.value.CopyConstructorName != 0)
			{
				HACKdummycopyconstructor(context, structures.value)
			}
		}
		else
		{
			CreateConstructorInLLVM(context, structures.value)
			CreateAnonConstructorInLLVM(context, structures.value)

			if(structures.value.CopyConstructorName != 0)
			{
				CreateCopyConstructorInLLVM(context, structures.value)
			}
		}
	}

	CreateAllConstructorsInLLVM(context, structures.next)
}

CreateAllConstructorsInLLVM : LLVMContextHandle context, nothing



CreateMemberParamTypesInLLVM : LLVMContextHandle context, list<StructureMember> ref members
{
	EpochLLVMFunctionQueueParamType(context, GetLLVMTypeForMemberType(context, members.value))
	CreateMemberParamTypesInLLVM(context, members.next)
}

CreateMemberParamTypesInLLVM : LLVMContextHandle context, nothing




CreateConstructorInLLVM : LLVMContextHandle context, StructureDefinition ref struct
{
	EpochLLVMFunctionTypePush(context)
	LLVMType funcrettype = EpochLLVMTypeGetVoid(context)
	
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, GetLLVMTypeForEpochType(context, struct.Type)))
	CreateMemberParamTypesInLLVM(context, struct.Members)
	
	LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
	LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, GetPooledString(struct.ConstructorName), functype)

	BinaryTreeCreateOrInsert<LLVMFunctionRef>(LLVMFunctionTable, struct.ConstructorName, llvmfunc)


	LLVMBasicBlock funcbody = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, true)

	EmitStructureInitializationToLLVM(context, struct.Members, 0, 1)
	
	EpochLLVMCodeCreateRetVoid(context)
}

CreateAnonConstructorInLLVM : LLVMContextHandle context, StructureDefinition ref struct
{
	EpochLLVMFunctionTypePush(context)
	LLVMType funcrettype = GetLLVMTypeForEpochType(context, struct.Type)
	CreateMemberParamTypesInLLVM(context, struct.Members)
	
	LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
	LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, GetPooledString(struct.AnonConstructorName), functype)
	
	BinaryTreeCreateOrInsert<LLVMFunctionRef>(LLVMFunctionTable, struct.AnonConstructorName, llvmfunc)
	
	
	LLVMBasicBlock funcbody = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, true)
	LLVMAlloca retalloca = EpochLLVMCodeCreateAlloca(context, funcrettype, "@anonymous")
	
	EmitAnonStructureInitializationToLLVM(context, struct.Members, 0, 0, retalloca)
	
	EpochLLVMCodePushRawAlloca(context, retalloca)
	EpochLLVMCodeCreateDereference(context)
	EpochLLVMCodeCreateRet(context)
}

CreateCopyConstructorInLLVM : LLVMContextHandle context, StructureDefinition ref struct
{
	EpochLLVMFunctionTypePush(context)
	LLVMType funcrettype = EpochLLVMTypeGetVoid(context)
	
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, GetLLVMTypeForEpochType(context, struct.Type)))
	EpochLLVMFunctionQueueParamType(context, GetLLVMTypeForEpochType(context, struct.Type))
	//EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetPointerTo(context, GetLLVMTypeForEpochType(context, struct.Type)))

	LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
	LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, GetPooledString(struct.CopyConstructorName), functype)
	
	BinaryTreeCreateOrInsert<LLVMFunctionRef>(LLVMFunctionTable, struct.CopyConstructorName, llvmfunc)
	
	
	LLVMBasicBlock funcbody = EpochLLVMCodeCreateBasicBlock(context, llvmfunc, true)

	EpochLLVMCodeCreateReadParam(context, 1)
	//EpochLLVMCodeCreateDereference(context)
	EpochLLVMCodeCreateWriteParam(context, 0)
	EpochLLVMCodeCreateRetVoid(context)
}




EmitStructureInitializationToLLVM : LLVMContextHandle context, list<StructureMember> ref members, integer memberindex, integer paramindex
{
	EpochLLVMCodeCreateReadParam(context, 0)
	LLVMGEP gep = EpochLLVMCodeCreateGEP(context, memberindex)

	EpochLLVMCodeCreateReadParam(context, paramindex)
	EpochLLVMCodeCreateWriteStructure(context, gep)
	
	EmitStructureInitializationToLLVM(context, members.next, memberindex + 1, paramindex + 1)
}


EmitStructureInitializationToLLVM : LLVMContextHandle context, nothing, integer memberindex, integer paramindex



EmitAnonStructureInitializationToLLVM : LLVMContextHandle context, list<StructureMember> ref members, integer memberindex, integer paramindex, LLVMAlloca retalloca
{
	EpochLLVMCodePushRawAlloca(context, retalloca)
	LLVMGEP gep = EpochLLVMCodeCreateGEP(context, memberindex)
	
	EpochLLVMCodeCreateReadParam(context, paramindex)
	EpochLLVMCodeCreateWriteStructure(context, gep)
	
	EmitAnonStructureInitializationToLLVM(context, members.next, memberindex + 1, paramindex + 1, retalloca)
}

EmitAnonStructureInitializationToLLVM : LLVMContextHandle context, nothing, integer memberindex, integer paramindex, LLVMAlloca retalloca



EmitAssignmentLHSGEPsToLLVM : LLVMBuildContext ref context, simplelist<integer> ref lhsmembers, integer structurename
{
	integer membertype = GetStructureMemberType(structurename, lhsmembers.value)
	integer memberindex = GetStructureMemberIndex(structurename, lhsmembers.value)
	
	while((membertype & 0x7f000000) == 0x05000000)
	{
		membertype = FindTypeAliasBase(membertype)
	}

	LLVMGEP gep = EpochLLVMCodeCreateGEP(context.Context, memberindex)
	EpochLLVMCodePushRawGEP(context.Context, gep)

	// Recurse
	assertmsg(membertype != 0, "Member has no type!")
	EmitAssignmentLHSGEPsToLLVM(context, lhsmembers.next, GetNameOfType(membertype))
}

EmitAssignmentLHSGEPsToLLVM : LLVMBuildContext ref context, nothing, integer structurename


ADummyFunction :
{
	simplelist<boolean> hack = false, nothing
	hack.value = true
}

