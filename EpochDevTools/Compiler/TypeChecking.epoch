TypeListContains : simplelist<integer> ref thelist, integer value -> integer ret = 0 [nogc]
{
	integer listval = thelist.value
	if((value & 0x7f000000) != 0x05000000)
	{
		while((listval & 0x7f000000) == 0x05000000)
		{
			listval = FindTypeAliasBase(listval)
		}
	}


	// TEST HACK
	if((listval & 0x7f000000) != 0x05000000)
	{
		while((value & 0x7f000000) == 0x05000000)
		{
			value = FindTypeAliasBase(value)
		}
	}
	// END HACK


	if(listval == value)
	{
		ret = listval
		return()
	}
	elseif(MakeNonReferenceType(listval) == value)
	{
		ret = listval
		return()
	}
	elseif(listval == MakeNonReferenceType(value))
	{
		ret = listval
		return()
	}

	if((value & 0x7f000000) == 0x07000000)
	{
		if(MakeNonReferenceType(value) == MakeNonReferenceType(listval))
		{
			ret = value
			return()
		}

		if(SumTypeHasBase(MakeNonReferenceType(value), MakeNonReferenceType(listval)))
		{
			ret = value
			return()
		}
	}

	if((listval & 0x7f000000) == 0x07000000)
	{
		if(MakeNonReferenceType(value) == MakeNonReferenceType(listval))
		{
			ret = value
			return()
		}

		if(SumTypeHasBase(listval, MakeNonReferenceType(value)))
		{
			ret = value
			return()
		}
	}

	ret = TypeListContains(thelist.next, value)
}

TypeListContains : nothing, integer value -> 0




structure InferenceContext :
	integer ScopeName,
	integer StatementName,
	simplelist<integer> ref ExpectedTypes,
	boolean FunctionReturn,
	integer NumParameters,
	boolean TopLevelStatement,
	boolean Parenthetical,
	ContextWrapper<Scope> ScopeRef,
	ContextWrapper<FunctionDefinition> FuncRef

structure TypePossibilityList :
	simplelist<integer> ref Types,
	boolean Consumed

structure InferencePossibility :
	integer FunctionName,
	list<TypePossibilityList> ref ParameterTypes,
	TypePossibilityList ref ReturnType

structure ExpressionInferenceStackEntry :
	list<InferencePossibility> ref PossibilityList



TypeInferenceSumTypeHelper : integer typeid, SumType ref st -> boolean success = true [nogc]
{
	if(st.Type != 0)
	{
		if(!st.IsTemplate)
		{
			if(!ResolveSumTypeBases(st.Bases))
			{
				success = false
			}
		}
	}
}


IRTypeInference : -> boolean success = true
{
	if(!BinaryTreeWalkAllNodes<SumType>(GlobalRootNamespace.SumTypes.RootNode, TypeInferenceSumTypeHelper))
	{
		success = false
	}

	if(!TypeInference(Structures, DummyContextForFunctions))
	{
		success = false
	}

	if(GlobalCodeBlockName != 0)
	{
		ContextWrapper<FunctionDefinition> funcwrap = nothing
		InferenceContext globalcontext = GlobalCodeBlockName, 0, globalemptyintlist, false, 0, false, false, GlobalScope, funcwrap
		if(!TypeInference(GlobalCodeBlock, globalcontext))
		{
			success = false
		}
	}

	if(!TypeInference(Functions, DummyContextForFunctions))
	{
		success = false
	}
}

TypeInference : nothing, InferenceContext ref context -> true

TypeInference : list<StructureDefinition> ref structures, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(structures.value, context))
	{
		success = false
	}

	if(!TypeInference(structures.next, context))
	{
		success = false
	}
}

TypeInference : StructureDefinition ref structuredef, InferenceContext ref context -> boolean success = true
{
	if(structuredef.Name == 0)
	{
		return()
	}

	if(structuredef.IsTemplate)
	{
		return()
	}

	if(!TypeInference(structuredef.Members, context))
	{
		success = false
	}

	integer ctorname = PoolString(structuredef.ReadableName ; "@@constructor")
	integer anonname = PoolString(structuredef.ReadableName ; "@@anonconstructor")
	integer copyname = PoolString(structuredef.ReadableName ; "@@copyconstructor")
	OnCodeGenRegisterConstructors(structuredef.Name, ctorname, anonname, copyname)

	Overload selfoverload = structuredef.Name, ctorname, nothing
	prepend<Overload>(AutoGenOverloads, selfoverload)

	Overload anonoverload = ctorname, anonname, nothing
	prepend<Overload>(AutoGenOverloads, anonoverload)

	Overload copyoverload = ctorname, copyname, nothing
	prepend<Overload>(AutoGenOverloads, copyoverload)
}


TypeInference : list<StructureMember> ref members, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(members.value, context))
	{
		success = false
	}

	if(!TypeInference(members.next, context))
	{
		success = false
	}
}

TypeInference : StructureMemberVariable ref memvar, InferenceContext ref context -> boolean success = true
{
	if(memvar.Name == 0)
	{
		return()
	}

	integer pretype = 0
	if(IsReferenceType(memvar.Type))
	{
		pretype = MakeReferenceType(0)
	}
	
	memvar.Type = GetTypeByName(InstantiateStructureTemplate(memvar.TypeNameHandle, memvar.TemplateArgs))
	if(memvar.Type == 0)
	{
		memvar.Type = GetTypeByName(memvar.TypeNameHandle)
	}

	if(memvar.Type == 0)
	{
		print("Type not recognized: " ; GetPooledString(memvar.TypeNameHandle))
		success = false
	}
	else
	{
		memvar.Type = memvar.Type + pretype			// 3 to accept reference marker
	}
}

TypeInference : StructureMemberFunctionRef ref memfunc, InferenceContext ref context -> boolean success = true
{
	ResolveSignatureTypes(memfunc.Signature)
}


TypeInference : list<FunctionDefinition> ref functions, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(functions.value, context))
	{
		success = false
	}

	if(!TypeInference(functions.next, context))
	{
		success = false
	}
}


TypeInference : FunctionDefinition ref func, InferenceContext ref context -> boolean success = true
{
	if(func.IsTemplate)
	{
		return()
	}

	if(func.InferenceDone)
	{
		return()
	}

	func.InferenceDone = true

	ContextWrapper<Scope> scopewrap = func.AttachedScope.Wrapped
	ContextWrapper<FunctionDefinition> funcwrap = func
	InferenceContext innercontext = func.Name, 0, globalemptyintlist, false, 0, false, false, scopewrap, funcwrap


	if(!TypeInference(func.Params, innercontext))
	{
		print("Parameters to function failed type inference")
		success = false
	}

	
	InferenceContext retcontext = func.Name, 0, globalemptyintlist, true, 0, false, false, innercontext.ScopeRef, funcwrap
	if(!TypeInference(func.Return, retcontext))
	{
		print("Function return expression failed type inference")
		success = false
	}

	integer rettype = GetOptionalExpressionType(func.Return)
	if((rettype != 0) && (rettype != 0x00000002))	// void magic
	{
		if(func.AnonymousReturn)
		{
			StoreVariableInSingleScope(innercontext.ScopeRef.Wrapped, PooledStringHandleForAnonymousRet, rettype, false, 2)
		}
	}

	if(!TypeInference(func.Code, innercontext))
	{
		print(GetPooledString(func.Name) ; "() - Function code body failed type inference")
		success = false
	}
}

TypeInference : FunctionParams ref params, InferenceContext ref context -> boolean success = TypeInference(params.Params, context)

TypeInference : list<UnresolvedParameter> ref params, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(params.value, context))
	{
		success = false
	}

	if(!TypeInference(params.next, context))
	{
		success = false
	}
}

TypeInference : UnresolvedParameter ref param, InferenceContext ref context -> boolean success = true
{
	if((param.ResolvedType & 0x7f000000) == 0x09000000)
	{
		TypeInferenceOnFunctionSignature(FunctionSignatures, param.ResolvedType)
		StoreVariableInSingleScope(context.ScopeRef.Wrapped, param.NameHandle, param.ResolvedType, false, 1)
		return()
	}

	integer patternmatchtype = GetOptionalExpressionType(param.PatternMatchValue)
	if(patternmatchtype != 0)
	{
		param.ResolvedType = patternmatchtype
		return()
	}

	param.TypeNameHandle = MangleTemplateNameByHandle(param.TypeNameHandle, param.TemplateArgs)

	param.ResolvedType = GetTypeByName(param.TypeNameHandle)
	if(param.ResolvedType == 0)
	{
		print("Unknown parameter type: " ; GetPooledString(param.TypeNameHandle))
		success = false
	}
	else
	{
		if(param.HasRefTag)
		{
			param.ResolvedType = param.ResolvedType + 0x80000000
		}

		StoreVariableInSingleScope(context.ScopeRef.Wrapped, param.NameHandle, param.ResolvedType, false, 1)
	}
}


TypeInferenceOnFunctionSignature : list<FunctionSignature> ref signatures, integer sigtype
{
	if(signatures.value.Name == sigtype)
	{
		if(!signatures.value.InferenceDone)
		{
			ResolveSignatureTypes(signatures.value.Parameters)
			signatures.value.InferenceDone = true
		}
	}
	else
	{
		TypeInferenceOnFunctionSignature(signatures.next, sigtype)
	}
}


TypeInference : CodeBlock ref code, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(code.Entries, context))
	{
		success = false
	}
}

TypeInference : list<CodeBlockEntry> ref code, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(code.value, context))
	{
		success = false
	}

	if(!TypeInference(code.next, context))
	{
		success = false
	}
}


TypeInference : PreOpStatement ref statement, InferenceContext ref context -> boolean success = true
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(context.ScopeRef.Wrapped, statement.Operand.value, var)

	if(var.Name == 0)
	{
		print("Cannot operate on variable, it doesn't exist!")
		print(GetPooledString(statement.Operand.value))
		
		success = false
		return()
	}

	integer operandtype = MakeNonReferenceType(var.VarType)

	if(countnonzero(statement.Operand) > 1)
	{
		assertmsg(operandtype != 0, "Pre-operation statement has no type")
		operandtype = ComputeCompoundAssignmentLHSTypeMembers(statement.Operand.next, GetNameOfType(operandtype))
	}

	statement.Operator = FindPrePostOperatorOverload(statement.Operator, operandtype)
	statement.Type = operandtype		// TODO - maybe don't assume that the operator returns the same type as it takes?
}


TypeInference : PostOpStatement ref statement, InferenceContext ref context -> boolean success = true
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(context.ScopeRef.Wrapped, statement.Operand.value, var)

	if(var.Name == 0)
	{
		print("Cannot operate on variable, it doesn't exist!")
		print(GetPooledString(statement.Operand.value))
		
		success = false
		return()
	}

	integer operandtype = MakeNonReferenceType(var.VarType)

	if(countnonzero(statement.Operand) > 1)
	{
		assertmsg(operandtype != 0, "Post-operation statement has no type")
		operandtype = ComputeCompoundAssignmentLHSTypeMembers(statement.Operand.next, GetNameOfType(operandtype))
	}

	statement.Operator = FindPrePostOperatorOverload(statement.Operator, operandtype)
	statement.Type = operandtype
}


TypeInference : Statement ref statement, InferenceContext ref context -> boolean success = true
{
	if(statement.InferenceDone)
	{
		return()
	}

	statement.InferenceDone = true

	integer originalname = statement.Name
	statement.Name = InstantiateTemplateFast(statement.Name, statement.TemplateArgs)

	integer paramcount = CountExpressions(statement.Parameters)

	integer vartype = GetTypeByName(statement.Name)
	if(vartype != 0)
	{
		integer origin = 0
		if(context.FunctionReturn)
		{
			origin = 2
			SetFunctionReturnType(context.FuncRef.Wrapped, context.ScopeName, vartype)
		}

		integer basetype = vartype
		while((basetype & 0x7f000000) == 0x05000000)
		{
			basetype = FindTypeAliasBase(basetype)
		}

		if(IsStructureType(basetype))
		{
			statement.Name = GetConstructorName(Structures, basetype)
		}
		else
		{
			assertmsg(vartype != 0, "Assumption failure in statement type inference")
			statement.Name = GetNameOfType(vartype)
		}

		if(statement.ArrayArity > 0)
		{
			vartype = GetArrayType(ArrayTypes, vartype, statement.ArrayArity)
		}

		if(statement.TopLevel)
		{
			ConstructVariableFromStatement(statement, context.ScopeRef.Wrapped, vartype, origin)
		}
	}

	InferenceContext newcontext = context.ScopeName, statement.Name, context.ExpectedTypes, false, paramcount, statement.TopLevel, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(statement.Parameters, newcontext))
	{
		success = false
		print("Type inference failed for call to " ; GetPooledString(statement.Name) ; "()")
	}


	ContextNode<FunctionDefinition> contextfunc = nothing
	ContextNode<PendingTypeMatcher> contextmatch = nothing
	boolean isuserfunc = false


	if(statement.Name == PooledStringHandleForCast)
	{
		statement.Name = GetCastOverload(statement.Parameters)

		if(statement.Name == 0)
		{
			success = false
			print("Invalid cast()")
		}
	}
	else
	{
		if(IsRecognizedBuiltIn(statement.Name))
		{
			isuserfunc = false
		}
		else
		{
			isuserfunc = SearchBinaryTreeForPayload<FunctionDefinition>(GlobalRootNamespace.Functions.RootNode, statement.Name, contextfunc)
		}

		simplelist<integer> paramtypes = 0, nothing
		AccumulateParameterTypes(paramtypes, statement.Parameters)

		integer overloadname = 0

		if(isuserfunc)
		{
			overloadname = FindOverloadWithParameterTypesFast(contextfunc, statement.Name, paramtypes)
		}
		else
		{
			overloadname = FindOverloadWithParameterTypes(AutoGenOverloads, statement.Name, paramtypes)
			
			if(vartype == 0)
			{
				if(!FunctionIsAutoGenOrHasIR(statement.Name))
				{
					integer localtype = GetVariableTypeFromScope(context.ScopeRef.Wrapped, statement.Name)
					if(localtype != 0)
					{
						if((localtype & 0x7f000000) != 0x09000000)
						{
							print("Call to " ; GetPooledString(statement.Name) ; "() is invalid - variable is not a function")
							success = false
						}
					}
					else
					{
						if(!IsRecognizedBuiltIn(statement.Name))
						{
							overloadname = 0
						}
					}
				}
			}
		}

		if(overloadname != 0)
		{			
			statement.Name = overloadname

			if(IsRecognizedBuiltIn(statement.Name))
			{
				isuserfunc = false
			}
			else
			{
				isuserfunc = SearchBinaryTreeForPayload<FunctionDefinition>(GlobalRootNamespace.Functions.RootNode, statement.Name, contextfunc)
			}


			Variable var = 0, 0, 0, 0
			FindVariableDataInSingleScope(context.ScopeRef.Wrapped, statement.Name, var)

			if((var.Name != 0) && ((var.VarType & 0x7f000000) == 0x09000000))
			{
				// TODO - type checking on higher order functions
				statement.Type = GetSignatureReturnType(FunctionSignatures, var.VarType)
				
				WalkFunctionParamsAndSetReferencesForSignature(FunctionSignatures, var.VarType, statement.Parameters)
				
				return()
			}		
		}
		else
		{
			success = false
			print("No matching overload for call to " ; GetPooledString(statement.Name) ; "()")
			DumpTypeList(paramtypes)
			
			print("Available overloads:")
			DumpOverloadList(contextfunc)
		}
	}

	if(context.FunctionReturn)
	{
		statement.Type = vartype
	}
	else
	{
		if(isuserfunc)
		{
			statement.Type = InferFunctionReturnType(contextfunc)
		}
		else
		{
			statement.Type = GetPendingTypeMatcherReturnType(statement.Name, contextmatch)
		}
	}

	if(isuserfunc)
	{
		WalkFunctionParamsAndSetReferencesShim(contextfunc, statement.Parameters)
	}
	else
	{
		MakeParametersReferencesForTypeMatcher(statement.Name, statement.Parameters)
	}

	if(vartype != 0)
	{
		if(isuserfunc)
		{
			AnnotateTypeMatchedParamsForWrapper(contextfunc, statement.Parameters)
		}
		else
		{
			FindConstructorAndAnnotateTypeMatchedParams(Structures, statement.Name, statement.Parameters)
		}
		
		if((vartype & 0x7f000000) == 0x05000000)
		{
			statement.Name = GetNameOfType(FindTypeAliasBase(vartype))
		}
	}
	elseif(ContextHasTypeMatcher(contextmatch))
	{
		//AnnotateAllParameters(statement.Parameters, originalname, 0, paramcount, statement.TopLevel)
	}

	//if(SumTypeExists(statement.Name))
	//{
	//	AnnotateAllParameters(statement.Parameters, originalname, 0, paramcount, statement.TopLevel)
	//}
}


WalkFunctionParamsAndSetReferencesForSignature : list<FunctionSignature> ref signatures, integer sigtype, OptionalExpressionList ref optexprs
{
	if(signatures.value.Name == sigtype)
	{
		SetReferencesFromSignature(optexprs, signatures.value)
	}
	else
	{
		WalkFunctionParamsAndSetReferencesForSignature(signatures.next, sigtype, optexprs)
	}
}


SetReferencesFromSignature : ExpressionList ref exprs, FunctionSignature ref signature
{
	SetReferencesFromSignature(exprs.Expressions, signature.Parameters)
}

SetReferencesFromSignature : list<Expression> ref exprs, list<Parameter> ref params
{
	if(params.value.Name == 0)
	{
		SetReferencesFromSignature(exprs, params.next)
		return()
	}
	
	if(params.value.Name == 2)
	{
		if(!MarkAtomAsReference(exprs.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
			DumpAtom(exprs.value.Atoms.value)
		}
	}

	SetReferencesFromSignature(exprs.next, params.next)
}

SetReferencesFromSignature : nothing, list<Parameter> ref params
{
	assertmsg(params.value.Name == 0, "Parameter count mismatch for higher-order function")
}

SetReferencesFromSignature : list<Expression> ref exprs, nothing
{
	assertmsg(ExpressionAtomIsSentinel(exprs.value.Atoms.value), "Parameter count mismatch for higher-order function")
}

SetReferencesFromSignature : nothing, nothing



TypeInference : MessageSend ref msg, InferenceContext ref context -> boolean success = true
{
	// TODO - typechecking on messages
}



AnyTypeIsReferenceType : simplelist<integer> ref types -> boolean isref = false [nogc]
{
	if(IsReferenceType(types.value))
	{
		isref = true
	}
	else
	{
		isref = AnyTypeIsReferenceType(types.next)
	}
}

AnyTypeIsReferenceType : nothing -> false [nogc]


UnaliasType : integer namehandle -> integer unaliasedname = namehandle [nogc]
{
	integer typeid = 0
	BinaryTreeCopyPayload<integer>(NameToTypeMap.RootNode, namehandle, typeid)
	
	if(typeid == 0)
	{
		return()
	}


	ContextNode<TypeAlias> wrap = nothing
	if(SearchBinaryTreeForPayload<TypeAlias>(GlobalRootNamespace.TypeWeakAliases.RootNode, typeid, wrap))
	{
		unaliasedname = GrabAliasBaseTypeName(wrap)
	}
}



FindTypeAliasBase : integer aliastype -> integer basetype = 0 [nogc]
{
	boolean isref = IsReferenceType(aliastype)
	aliastype = MakeNonReferenceType(aliastype)

	ContextNode<TypeAlias> wrap = nothing

	if(SearchBinaryTreeForPayload<TypeAlias>(GlobalRootNamespace.TypeAliases.RootNode, aliastype, wrap))
	{
		basetype = GrabAliasBaseType(wrap)
		if(isref)
		{
			basetype = MakeReferenceType(basetype)
		}
	}
}

GrabAliasBaseType : TypeAlias ref alias -> integer typeid = GetTypeByName(alias.BaseNameHandle)
GrabAliasBaseTypeName : TypeAlias ref alias -> integer typename = alias.BaseNameHandle


FindTypeAliasByName : integer aliasname -> integer aliastype = 0 [nogc]
{
	BinaryTreeCopyPayload<integer>(NameToTypeMap.RootNode, aliasname, aliastype)
}



IRProcess : -> boolean success = true
{
	prepend<StructureDefinition>(Structures, dummystruct)		// TODO - why does this need to be here?

	if(!IRTypeInference())
	{
		success = false
		return()
	}
}



AnnotateAllParameters : ExpressionList ref exprs, integer statementname, integer paramindex, integer paramcount, boolean toplevel
{
	AnnotateAllParameters(exprs.Expressions, statementname, paramindex, paramcount, toplevel)
}

AnnotateAllParameters : list<Expression> ref params, integer statementname, integer paramindex, integer paramcount, boolean toplevel
{
	if((params.value.Type & 0x7f000000) != 0x07000000)
	{
		AddTypeAnnotation(params.value)
	}
	elseif(IsRefBind(params.value.Atoms.value))
	{
		TypeAnnotationAtom atom = 5
		ExpressionAtom wrap = atom
		AppendAtomToExpression(params.value.Atoms, params.value.Atoms.next, wrap)
	}

	AnnotateAllParameters(params.next, statementname, paramindex + 1, paramcount, toplevel)
}

AnnotateAllParameters : nothing, integer statementname, integer paramindex, integer paramcount, boolean toplevel



AnnotateNonReferenceParameters : ExpressionList ref exprs [nogc]
{
	AnnotateNonReferenceParameters(exprs.Expressions)
}

AnnotateNonReferenceParameters : list<Expression> ref params [nogc]
{
	if((params.value.Type & 0x7f000000) != 0x07000000)
	{
		AddTypeAnnotation(params.value)
	}
	AnnotateNonReferenceParameters(params.next)
}

AnnotateNonReferenceParameters : nothing [nogc]



AddTypeAnnotation : nothing [nogc]

AddTypeAnnotation : list<Expression> ref params [nogc]
{
	AddTypeAnnotation(params.value)
}

AddTypeAnnotation : Expression ref expr [nogc]
{
	integer typeid = expr.Type
	TypeAnnotationAtom atom = typeid
	ExpressionAtom wrap = atom
	AppendAtomToExpression(expr.Atoms, expr.Atoms.next, wrap)
}


AccumulateParameterTypes : simplelist<integer> ref types, OptionalExpressionList ref exprs [nogc]
{
	AccumulateParameterTypesUnwrap(types, exprs)
}

AccumulateParameterTypesUnwrap : simplelist<integer> ref types, ExpressionList ref exprs [nogc]
{
	AccumulateParameterTypesUnwrapped(exprs.Expressions, types)
}

AccumulateParameterTypesUnwrap : simplelist<integer> ref types, nothing [nogc]

AccumulateParameterTypesUnwrapped : list<Expression> ref exprs, simplelist<integer> ref types [nogc]
{
	AccumulateParameterTypesUnwrapped(exprs.next, types)
	simpleprepend<integer>(types, exprs.value.Type)
}

AccumulateParameterTypesUnwrapped : nothing, simplelist<integer> ref types [nogc]



CheckCopyType : simplelist<integer> ref a, integer b -> boolean match = (a.value == b)


CheckParameterTypesForMatch : nothing, simplelist<integer> ref types -> boolean match = false
{
	integer count = countnonzero(types)
	if(count == 0)
	{
		match = true
	}
	elseif(count == 1)
	{
		if(types.value == 0x00000002)		// void type signature
		{
			match = true
		}
	}
}

CheckParameterTypesForMatch : FunctionDefinition ref func, simplelist<integer> ref types -> boolean match = CheckParameterTypesForMatch(func.Params, types)
CheckParameterTypesForMatch : FunctionParams ref params, simplelist<integer> ref types -> boolean match = CheckParameterTypesForMatch(params.Params, types)


CheckParameterTypesForMatch : list<UnresolvedParameter> ref params, simplelist<integer> ref types -> boolean match = true
{
	if(!ResolvedTypesMatch(params, types))
	{
		match = false
	}
}

CheckParameterTypesForMatch : simplelist<integer> ref atypes, simplelist<integer> ref btypes -> boolean match = TypesMatch(atypes, btypes)



TypesMatch : simplelist<integer> ref a, simplelist<integer> ref b -> boolean match = true
{
	if(MakeNonReferenceType(a.value) != MakeNonReferenceType(b.value))
	{
		match = false
	}
	else
	{
		match = TypesMatch(a.next, b.next)
	}
}

TypesMatch : nothing, nothing -> true

TypesMatch : nothing, simplelist<integer> ref b -> boolean match = (b.value == 0)
TypesMatch : simplelist<integer> ref a, nothing -> boolean match = (a.value == 0)



ResolvedTypesMatch : nothing, nothing -> true

ResolvedTypesMatch : list<UnresolvedParameter> ref params, nothing -> false
ResolvedTypesMatch : nothing, simplelist<integer> ref types -> boolean match = false
{
	if(types.value == 0)
	{
		match = true
	}
}

ResolvedTypesMatch : list<UnresolvedParameter> ref params, simplelist<integer> ref types -> boolean match = true
{
	integer resolved = params.value.ResolvedType
	while((resolved & 0x7f000000) == 0x05000000)
	{
		resolved = FindTypeAliasBase(resolved)
	}

	integer expected = types.value
	while((expected & 0x7f000000) == 0x05000000)
	{
		expected = FindTypeAliasBase(expected)
	}

	if(MakeNonReferenceType(resolved) != MakeNonReferenceType(expected))
	{
		match = false
		return()
	}


	listnode<UnresolvedParameter> n = params.next
	simplelistnode<integer> nt = types.next
	match = ResolvedTypesMatch(n, nt)			// TODO - this is some kind of compiler bug... or maybe a runtime bug?!
}


TypeInference : Assignment ref assignment, InferenceContext ref context -> boolean success = true
{
	integer vartype = GetVariableTypeFromScope(context.ScopeRef.Wrapped, assignment.LHSName)
	if(vartype == 0)
	{
		success = false
		print("Assignment to non-existent variable " ; GetPooledString(assignment.LHSName))
		return()
	}

	simplelist<integer> temp = vartype, nothing
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(assignment.RHS, newcontext))
	{
		print("Failed to infer type of RHS of assignment")
		success = false
	}

	assignment.LHSType = vartype

	if(assignment.LHSType != GetAssignmentRHSType(assignment.RHS))
	{
		// TODO - check type of RHS vs. LHS?

		assignment.Annotation = GetAssignmentRHSType(assignment.RHS)
	}

	assignment.Operator = FindAssignmentOperator(assignment.Operator, assignment.LHSType, GetAssignmentRHSType(assignment.RHS))
}

TypeInference : AssignmentCompound ref assignment, InferenceContext ref context -> boolean success = true
{
	integer lhstype = ComputeCompoundAssignmentLHSType(assignment, context.ScopeRef.Wrapped)

	simplelist<integer> temp = lhstype, nothing
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(assignment.RHS, newcontext))
	{
		print("Failed to infer type of RHS of assignment")
		success = false
	}

	assignment.LHSType = lhstype

	if(assignment.LHSType != GetAssignmentRHSType(assignment.RHS))
	{
		// TODO - check type of RHS vs. LHS?

		assignment.Annotation = GetAssignmentRHSType(assignment.RHS)
	}

	assignment.Operator = FindAssignmentOperator(assignment.Operator, assignment.LHSType, GetAssignmentRHSType(assignment.RHS))
}

TypeInference : EntityChain ref chain, InferenceContext ref context -> boolean success = TypeInference(chain.Entries, context)

TypeInference : EntityList ref entities, InferenceContext ref context -> boolean success = TypeInference(entities.ActualList, context)

TypeInference : list<Entity> ref entities, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(entities.value, context))
	{
		success = false
	}

	if(!TypeInference(entities.next, context))
	{
		success = false
	}
}

TypeInference : Entity ref entity, InferenceContext ref context -> boolean success = true
{
	simplelist<integer> temp = 0x01000003, nothing			// TODO - don't assume all entities take a boolean!
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(entity.Param, newcontext))
	{
		success = false
	}

	if(!TypeInference(entity.Code, context))
	{
		success = false
	}
}


TypeInference : ExpressionList ref parameters, InferenceContext ref context -> boolean success = true
{
	boolean hasallparams = false

	if((context.NumParameters > 0) && (!IsRecognizedBuiltIn(context.StatementName)))
	{
		ParameterTypeList dummyparaminfo = globalemptyintlist
		list<ParameterTypeList> paramtypeinfo = dummyparaminfo, nothing

		integer i = 1
		while(i < context.NumParameters)
		{
			ParameterTypeList dummyparaminfo2 = globalemptyintlist
			prepend<ParameterTypeList>(paramtypeinfo, dummyparaminfo2)

			++i
		}

		hasallparams = GatherAllPossibleParamTypes(context.StatementName, context.NumParameters, context.TopLevelStatement, paramtypeinfo)
	}
	
	if(!TypeInferenceExpressionList(parameters.Expressions, context, 0, hasallparams, paramtypeinfo))
	{
		success = false
	}
}


AddTypeToParamTypeList : list<ParameterTypeList> ref outinfo, integer ty
{
	simpleprepend<integer>(outinfo.value.Types, ty)
}


GrabTypeListAtIndex : list<ParameterTypeList> ref paraminfo, integer paramindex, simplelist<integer> ref out [nogc]
{
	if(paramindex == 0)
	{
		out = paraminfo.value.Types
		return()
	}

	GrabTypeListAtIndex(paraminfo.next, paramindex - 1, out)
}



TypeInferenceExpressionList : list<Expression> ref parameters, InferenceContext ref context, integer paramindex, boolean hasallparams, list<ParameterTypeList> ref paraminfo -> boolean success = true
{
	simplelist<integer> temp = 0, nothing

	if(hasallparams)
	{
		GrabTypeListAtIndex(paraminfo, paramindex, temp)
	}
	else
	{
		GetExpectedParameterTypes(context.StatementName, paramindex, context.NumParameters, context.TopLevelStatement, temp)
		GetHigherOrderParameterTypes(context.StatementName, paramindex, context.ScopeRef.Wrapped, temp)
	}

	InferenceContext newcontext = context.ScopeName, context.StatementName, temp, context.FunctionReturn, context.NumParameters, context.TopLevelStatement, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(parameters.value, newcontext))
	{
		print("Parameter " ; cast(string, paramindex) ; " failed type inference!")
		success = false
	}
	else
	{
		context.StatementName = newcontext.StatementName
	}

	if(!TypeInferenceExpressionList(parameters.next, context, paramindex + 1, hasallparams, paraminfo))
	{
		success = false
	}
}

TypeInferenceExpressionList : nothing, InferenceContext ref context, integer paramindex, boolean hasallparams, list<ParameterTypeList> ref paraminfo -> boolean success = true


TypeInference : Expression ref expression, InferenceContext ref context -> boolean success = true
{
	if(expression.Type != 0)
	{
		return()
	}

	if(ExpressionAtomIsSentinel(expression.Atoms.value))
	{
		expression.Type = 0x00000002
		return()
	}

	if(countatoms(expression.Atoms) > 1)
	{
		CoalesceMemberAccesses(expression.Atoms, context.ScopeRef.Wrapped)
		ShuntingYard(expression.Atoms)
		
		InferencePossibility temp = 0, scratchparampossibles, scratchreturns
		list<InferencePossibility> possibilities = temp, nothing
		ExpressionInferenceStackEntry stackentry = possibilities
		list<ExpressionInferenceStackEntry> stack = stackentry, nothing

		integer counter = 0

		WalkAtomsForType(expression.Atoms, expression.Atoms.next, stack, counter, context)

		integer possibilitycount = CountPossibilities(stack.value.PossibilityList)
		if(possibilitycount == 1)
		{
			if((!context.FunctionReturn) && (context.StatementName != 0))
			{
				simplelist<integer> types = 0, nothing
				EliminateImpossibleType(stack.value.PossibilityList.value.ReturnType.Types, context.ExpectedTypes, types)
				
				integer typecount = countnonzero(types)
				if(typecount == 1)
				{
					assertmsg(types.value != 0, "Inferred a non-type!")
					expression.Type = types.value
				}
				elseif(typecount > 1)
				{
					print("Multiple types possible:")
					DumpTypeList(types)
				}
				else
				{
					// TODO - demotion logic here is MESSY
					if((countnonzero(stack.value.PossibilityList.value.ReturnType.Types) == 1) && (countnonzero(context.ExpectedTypes) == 1) && (stack.value.PossibilityList.value.ReturnType.Types.value == 0x01000001) && (context.ExpectedTypes.value == 0x01000002))
					{
						expression.Type = 0x01000002
					}
					elseif((countnonzero(stack.value.PossibilityList.value.ReturnType.Types) == 1) && (countnonzero(context.ExpectedTypes) == 1) && (stack.value.PossibilityList.value.ReturnType.Types.value == 0x01000001) && (context.ExpectedTypes.value == 0x01000005))
					{
						expression.Type = 0x01000005
					}
					else
					{
						print("All types ruled out")
						DumpTypeList(stack.value.PossibilityList.value.ReturnType.Types)
						print("Expected types are")
						DumpTypeList(context.ExpectedTypes)
					}
				}
			}
			else
			{
				simplelist<integer> possibletypes = 0, nothing
				simplelist<integer> possibletypesprepromotion = 0, nothing
				FilterTypesForDemotion(stack.value.PossibilityList.value.ReturnType.Types, possibletypesprepromotion)
				FilterTypesForPromotion(possibletypesprepromotion, possibletypes)

				integer typecount = countnonzero(possibletypes)
				if(typecount == 1)
				{
					expression.Type = possibletypes.value
					assertmsg(expression.Type != 0, "Ruled out all types but a non-type!")
				}
				elseif(context.FunctionReturn)
				{
					print("Failed to infer return type of function - " ; cast(string, typecount) ; " types possible")
					DumpTypeList(possibletypes)
				}
				else
				{
					print("Expression has " ; cast(string, typecount) ; " types possible")
					DumpTypeList(possibletypes)
				}
			}
		}
		else
		{
			// TODO - error context!
			if(possibilitycount > 0)
			{
				print("Multiple overloads possible:")
				DumpOverloadList(stack.value.PossibilityList)
			}
			else
			{
				print("No types possible in this expression:")
				DumpExpressionAtoms(expression.Atoms)
				print("End expression")
			}
		}
	}
	else
	{
		simplelist<integer> possibletypes = 0, nothing
		TypePossibilityList poss = possibletypes, false
		GetAtomType(expression.Atoms.value, poss, context.ScopeRef.Wrapped, context.FuncRef.Wrapped, context.FunctionReturn, context.Parenthetical)

		if((!context.FunctionReturn) && (context.StatementName != 0))
		{
			simplelist<integer> types = 0, nothing
			EliminateImpossibleType(poss.Types, context.ExpectedTypes, types)

			integer typecount = countnonzero(types)
			if(typecount == 1)
			{
				expression.Type = types.value
			}
			elseif(typecount > 1)
			{
				print("Multiple types possible:")
				DumpTypeList(types)
			}
			else
			{
				print("Can't figure out type of expression atom!")
				DumpAtom(expression.Atoms.value)
				print("Failed guesses:")
				DumpTypeList(poss.Types)
				print("Expected types:")
				DumpTypeList(context.ExpectedTypes)
				success = false
			}
		}
		else
		{		
			simplelist<integer> filtered = 0, nothing
			simplelist<integer> prepromotion = 0, nothing
			FilterTypesForDemotion(poss.Types, prepromotion)
			FilterTypesForPromotion(prepromotion, filtered)

			integer typecount = countnonzero(filtered)
			if(typecount == 1)
			{
				expression.Type = filtered.value
				assertmsg(expression.Type != 0, "Ruled out all types but a non-type!")
			}
			elseif(context.FunctionReturn)
			{
				print("Failed to infer return type of function - " ; cast(string, typecount) ; " types possible")
				DumpTypeList(filtered)
				
				success = false
			}
			else
			{
				print("Expression has " ; cast(string, typecount) ; " types possible")
				DumpTypeList(filtered)
				
				success = false
			}
		}
	}

	if(expression.Type == 0)
	{
		success = false
	}
	elseif(expression.Type == 0x01000002)
	{
		DemoteAtomType(expression.Atoms)
	}
	elseif(expression.Type == 0x01000005)
	{
		PromoteAtomType(expression.Atoms)
	}
	elseif((expression.Type & 0x7f000000) == 0x09000000)
	{
		SetAtomType(expression.Atoms.value, expression.Type)
	}
	elseif(IsStructureType(expression.Type))
	{
		SetAtomType(expression.Atoms.value, expression.Type)
	}
	elseif(expression.Type == 0x01000000)
	{
		if((context.StatementName != 0) && (StructureConstructorExists(Structures, context.StatementName)))
		{
			SetAtomType(expression.Atoms.value, 0x81000000)		// hack
		}
		else
		{
			SetAtomType(expression.Atoms.value, expression.Type)
		}
	}
}

CountPossibilities : list<InferencePossibility> ref thelist -> integer count = 0 [nogc]
{
	if(thelist.value.FunctionName != 0)
	{
		++count
	}

	count += CountPossibilities(thelist.next)
}

CountPossibilities : nothing -> 0 [nogc]


WalkAtomsForType : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref tail, list<ExpressionInferenceStackEntry> ref stack, integer ref counter, InferenceContext ref context -> boolean demotedtoright = false
{
	boolean didrightdemote = WalkAtomsForType(tail, tail.next, stack, counter, context)
	boolean unarycompensate = false

	if(IsOperatorInvoke(tail.value))
	{
		if(IsUnaryOperator(tail.value))
		{
			SetOperatorAtomToOverload(tail, stack.value.PossibilityList.value.FunctionName, 0)
			unarycompensate = true
		}
	}

	if(IsOperatorInvoke(atoms.value))
	{
		if(counter > 0)
		{
			SetOperatorAtomToOverload(atoms, stack.value.PossibilityList.value.FunctionName, counter + 1)
			--counter
		}

		list<InferencePossibility> possibleoperators = scratchpossibility, nothing
		GetAtomTypeOperator(atoms.value, possibleoperators)

		ExpressionInferenceStackEntry entry = possibleoperators
		prepend<ExpressionInferenceStackEntry>(stack, entry)
	}
	else
	{
		list<InferencePossibility> out = scratchpossibility, nothing
		EliminateImpossibleParametersForAllOverloads(stack.value.PossibilityList, out, atoms.value, context.ScopeRef.Wrapped, context.FuncRef.Wrapped, context.FunctionReturn, context.Parenthetical)

		if(counter == 1)
		{
			list<InferencePossibility> filtered = scratchpossibility, nothing
			FilterOverloadsForTypeDemotion(out, filtered)
			stack.value.PossibilityList = filtered
		}
		else
		{
			stack.value.PossibilityList = out
		}

		if(CountPossibilities(stack.value.PossibilityList) == 1)
		{
			if(listcontains(stack.value.PossibilityList.value.ParameterTypes.value.Types, 0x01000002))
			{
				DemoteAtomType(atoms)
				demotedtoright = true

				if((!didrightdemote) && (!IsOperatorInvoke(tail.value)))
				{
					DemoteAtomType(tail)
				}
			}
			elseif(listcontains(stack.value.PossibilityList.value.ParameterTypes.value.Types, 0x01000005))
			{
				PromoteAtomType(atoms)
			}
		}
		elseif(didrightdemote)
		{
			DemoteAtomType(atoms)
		}

		++counter
		if(counter > 1)
		{
			SetOperatorAtomToOverload(atoms, stack.value.PossibilityList.value.FunctionName, counter)
			++counter
		}

		if(AllOptionsConsumed(stack.value.PossibilityList.value.ParameterTypes))
		{
			stack.value.PossibilityList.value.ReturnType.Consumed = true
			CopyReturnTypeToParamTypes(stack, stack.next)
		}
	}

	if(unarycompensate)
	{
		++counter
	}
}


CopyReturnTypeToParamTypes : list<ExpressionInferenceStackEntry> ref stack, list<ExpressionInferenceStackEntry> ref tail
{
	AddPossibleParamTypeForAllOverloads(tail.value.PossibilityList, stack.value.PossibilityList.value.ReturnType)
	PopExpressionInferenceStack(stack, tail)
}

CopyReturnTypeToParamTypes : list<ExpressionInferenceStackEntry> ref stack, nothing



AllOptionsConsumed : list<TypePossibilityList> ref options -> boolean allconsumed = true [nogc]
{
	if(!options.value.Consumed)
	{
		if(countnonzero(options.value.Types) > 0)
		{
			allconsumed = false
		}
		else
		{
			allconsumed = AllOptionsConsumed(options.next)
		}
	}
	else
	{
		allconsumed = AllOptionsConsumed(options.next)
	}
}

AllOptionsConsumed : nothing -> true [nogc]


PopExpressionInferenceStack : list<ExpressionInferenceStackEntry> ref stack, list<ExpressionInferenceStackEntry> ref tail [nogc]
{
	stack = tail
}

PopExpressionInferenceStack : list<ExpressionInferenceStackEntry> ref stack, nothing [nogc]


WalkAtomsForType : list<ExpressionAtom> ref atoms, nothing, list<ExpressionInferenceStackEntry> ref stack, integer ref counter, InferenceContext ref context -> boolean demotedtoright = false
{
	if(IsOperatorInvoke(atoms.value))
	{
		GetAtomTypeOperator(atoms.value, stack.value.PossibilityList)
	}
	else
	{
		TypePossibilityList poss = scratchpossibletypes, false
		InferencePossibility newpossibility = -1, scratchparampossibles, poss
		GetAtomType(atoms.value, newpossibility.ReturnType, context.ScopeRef.Wrapped, context.FuncRef.Wrapped, context.FunctionReturn, context.Parenthetical)

		prepend<InferencePossibility>(stack.value.PossibilityList, newpossibility)
	}
}


EliminateImpossibleParametersForAllOverloads : list<InferencePossibility> ref possibilities, list<InferencePossibility> ref out, ExpressionAtom ref atom, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	if(possibilities.value.FunctionName != 0)
	{
		if(EliminateImpossibleParameters(possibilities.value.ParameterTypes, atom, scope, func, funcret, parenthetical))
		{
			prepend<InferencePossibility>(out, possibilities.value)
		}
	}

	EliminateImpossibleParametersForAllOverloads(possibilities.next, out, atom, scope, func, funcret, parenthetical)
}

EliminateImpossibleParametersForAllOverloads : nothing, list<InferencePossibility> ref out, ExpressionAtom ref atom, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical


EliminateImpossibleParameters : list<TypePossibilityList> ref params, ExpressionAtom ref atom, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical -> boolean valid = true
{
	if(!params.value.Consumed)
	{
		TypePossibilityList poss = scratchpossibletypes, false
		GetAtomType(atom, poss, scope, func, funcret, parenthetical)

		simplelist<integer> types = 0, nothing
		integer typecount = EliminateImpossibleType(params.value.Types, poss.Types, types)

		if(typecount == 0)
		{
			valid = false
		}

		params.value.Types = types
		params.value.Consumed = true
	}
	else
	{
		if(!EliminateImpossibleParameters(params.next, atom, scope, func, funcret, parenthetical))
		{
			valid = false
		}
	}
}


EliminateImpossibleParameters : nothing, ExpressionAtom ref atom, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical -> true


EliminateImpossibleType : simplelist<integer> ref possibles, simplelist<integer> ref filter, simplelist<integer> ref out -> integer count = 0 [nogc]
{
	count = EliminateImpossibleType(possibles.next, filter, out)

	if(possibles.value != 0)
	{
		integer expectedtype = TypeListContains(filter, possibles.value)
		if(expectedtype != 0)
		{
			count = count + 1
			simpleprepend<integer>(out, expectedtype)
		}
	}
}

EliminateImpossibleType : nothing, simplelist<integer> ref filter, simplelist<integer> ref out -> 0 [nogc]


// TODO - type inference on array indexing expressions
GetAtomType : ArrayIndexAtom     ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000001) }	// integer magic

GetAtomType : AtomSentinel       ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x00000002) }	// void magic
GetAtomType : StringHandleAtom   ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x02000000) }
GetAtomType : TypeAnnotationAtom ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000001) }
GetAtomType : integer16          ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000002) }
GetAtomType : boolean            ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000003) }
GetAtomType : real               ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000004) }

GetAtomType : integer            ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	AddPossibleParameter(possibilities.Types, 0x01000001)
	AddPossibleParameter(possibilities.Types, 0x01000002)			// Allow demotion later
	AddPossibleParameter(possibilities.Types, 0x01000005)			// Allow promotion later
}

GetAtomType : CompoundAtom       ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, atom.Type)  }

GetAtomType : Statement ref statement, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	ContextWrapper<Scope> scopewrap = scope
	ContextWrapper<FunctionDefinition> funcwrap = func
	InferenceContext newcontext = scope.Name, statement.Name, globalemptyintlist, funcret, 0, false, false, scopewrap, funcwrap

	if(TypeInference(statement, newcontext))
	{
		AddPossibleParameter(possibilities.Types, statement.Type)
	}
}

GetAtomType : RefBinding ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical

GetAtomType : ParentheticalExpression ref parenthetical, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean isinparenthetical
{
	ContextWrapper<Scope> scopewrap = scope
	ContextWrapper<FunctionDefinition> funcwrap = func
	InferenceContext newcontext = scope.Name, 0, globalemptyintlist, funcret, 0, false, true, scopewrap, funcwrap

	if(TypeInference(parenthetical.Inner, newcontext))
	{
		AddPossibleParameter(possibilities.Types, GetParentheticalType(parenthetical.Inner))
	}
	else
	{
		print("Parenthetical expression failed type inference")
	}
}

GetParentheticalType : PreOpStatement ref statement -> integer rettype = statement.Type [nogc]
GetParentheticalType : PostOpStatement ref statement -> integer rettype = statement.Type [nogc]
GetParentheticalType : Expression ref expr -> integer rettype = expr.Type [nogc]

GetAtomTypeOperator : OperatorInvokeAtom ref atom, list<InferencePossibility> ref possibilities
{
	AddPossibilityPerOperatorOverload(atom.OperatorName, possibilities)
}

GetAtomType : IdentifierAtom ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	if(atom.Handle == PooledStringHandleForNothing)
	{
		atom.Type = 0x00000004
		AddPossibleParameter(possibilities.Types, 0x00000004)
		return()
	}

	if((!parenthetical) && (!funcret))
	{
		AddPossibleParameter(possibilities.Types, 0x01000000)
	}

	integer nametype = GetTypeByName(atom.Handle)
	if(nametype != 0)
	{
		if(IsStructureType(nametype))
		{
			if(FunctionIsAutoGenOrHasIR(atom.Handle))
			{
				atom.IsFunction = true
			}
		}

		return()
	}


	integer vartype = GetVariableTypeFromScope(scope, atom.Handle)
	if(vartype != 0)
	{
		AddPossibleParameter(possibilities.Types, vartype)
		if((vartype & 0x7f000000) == 0x09000000)
		{
			atom.IsFunction = true
		}
	}
	else
	{
		if(SearchBinaryTree<FunctionDefinition>(GlobalRootNamespace.Functions.RootNode, atom.Handle))
		{
			atom.IsFunction = true

			// TODO - overload resolution on higher order function name
			integer sigtype = FindFunctionAndGetSignatureType(Functions, atom.Handle)
			AddPossibleParameter(possibilities.Types, sigtype)
		}
		else
		{
			integer sigtype = FindBuiltinAndGetSignatureType(atom.Handle)
			if(sigtype != 0)
			{
				AddPossibleParameter(possibilities.Types, sigtype)
			}
			else
			{
				print(GetPooledString(atom.Handle) ; " is not a defined identifier!")
			}
		}
	}
}

AddPossibleParameter : simplelist<integer> ref possibilities, integer paramtype [nogc]
{
	simpleprepend<integer>(possibilities, paramtype)

	//if((paramtype & 0x7f000000) == 0x05000000)
	//{
	//	simpleprepend<integer>(possibilities, FindTypeAliasBase(paramtype))
	//}
}

AddBinaryPossibility : list<InferencePossibility> ref possibilities, integer functionname, integer param1type, integer param2type, integer rettype [nogc]
{
	assertmsg(functionname != 0, "Cannot configure inference possibility for nameless function")

	simplelist<integer> p1t = param1type, nothing
	simplelist<integer> p2t = param2type, nothing

	TypePossibilityList param1options = p1t, false
	TypePossibilityList param2options = p2t, false

	list<TypePossibilityList> paramtypes = param2options, nothing
	prepend<TypePossibilityList>(paramtypes, param1options)

	simplelist<integer> rt = rettype, nothing
	TypePossibilityList rettypelist = rt, false

	InferencePossibility possibility = functionname, paramtypes, rettypelist
	prepend<InferencePossibility>(possibilities, possibility)
}

AddUnaryPossibility : list<InferencePossibility> ref possibilities, integer functionname, integer param1type, integer rettype [nogc]
{
	assertmsg(functionname != 0, "Cannot configure inference possibility for nameless function")

	simplelist<integer> p1t = param1type, nothing

	TypePossibilityList param1options = p1t, false

	list<TypePossibilityList> paramtypes = param1options, nothing

	simplelist<integer> rt = rettype, nothing
	TypePossibilityList rettypelist = rt, false

	InferencePossibility possibility = functionname, paramtypes, rettypelist
	prepend<InferencePossibility>(possibilities, possibility)
}

GetExpectedParameterTypes : integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	FindFunctionAndAddParameterTypes(funcname, paramindex, paramcount, toplevel, types)
	EnumerateOverloadsAndAddParameterTypes(AutoGenOverloads, funcname, paramindex, paramcount, toplevel, types)
}


GetHigherOrderParameterTypes : integer funcname, integer paramindex, Scope ref scope, simplelist<integer> ref types
{
	integer vartype = GetVariableTypeFromScope(scope, funcname)
	if(vartype != 0)
	{
		integer t = GetFunctionSignatureParamType(FunctionSignatures, vartype, paramindex)
		if(t != 0)
		{
			simpleprepend<integer>(types, t)
		}
	}
}


InferFunctionParameterTypes : FunctionDefinition ref function, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(!function.InferenceDone)
	{
		TypeInference(function, DummyContextForFunctions)
	}

	UnwrapParamsForTypeRetrieval(function.Params, paramindex, paramcount, types)
}

FindFunctionAndAddParameterTypes : integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(!FindConstructorAndAddParameterTypes(Structures, funcname, paramindex, paramcount, toplevel, types))
	{
		FindBuiltinAndAddParameterTypes(funcname, paramindex, paramcount, types)
	}
}

UnwrapParamsForTypeRetrieval : FunctionParams ref params, integer paramindex, integer paramcount, simplelist<integer> ref types
{
	if(CountUnresolvedParameters(params) == paramcount)
	{
		RetrieveParamType(params.Params, paramindex, types)
	}
}

UnwrapParamsForTypeRetrieval : nothing, integer paramindex, integer paramcount, simplelist<integer> ref types


RetrieveParamType : list<UnresolvedParameter> ref params, integer paramindex, simplelist<integer> ref types
{
	if(paramindex == 0)
	{
		simpleprepend<integer>(types, params.value.ResolvedType)
		return()
	}

	RetrieveParamType(params.next, paramindex - 1, types)
}

RetrieveParamType : nothing, integer paramindex, simplelist<integer> ref types
{
	print("Too many parameters to call!")
	assert(false)
}


InferFunctionReturnType : PendingTypeMatcher ref pending -> integer rettype = InferFunctionReturnType(pending.OverloadImplementation)

InferFunctionReturnType : FunctionDefinition ref func -> integer rettype = 0
{
	if(!func.InferenceDone)
	{
		TypeInference(func, DummyContextForFunctions)
	}

	rettype = GetOptionalExpressionType(func.Return)
}


GetFunctionReturnType : list<FunctionDefinition> ref functions, integer funcname -> integer rettype = 0
{
	if(functions.value.Name == funcname)
	{
		rettype = InferFunctionReturnType(functions.value)
	}
	else
	{
		rettype = GetFunctionReturnType(functions.next, funcname)
	}
}

GetFunctionReturnType : nothing, integer funcname -> integer rettype = 0
{
	ContextNode<PendingTypeMatcher> ignored = nothing
	rettype = GetPendingTypeMatcherReturnType(funcname, ignored)
}

GetOptionalExpressionType : Expression ref expr -> expr.Type [nogc]
GetOptionalExpressionType : nothing -> 0 [nogc]



MakeParametersReferencesUnwrapFast : FunctionDefinition ref function, integer overloadname, ExpressionList ref params
{
	WalkFunctionParamsAndSetReferences(function.Params, params)
}

MakeParametersReferencesForTypeMatcherFast : PendingTypeMatcher ref pending, integer matchername, ExpressionList ref params
{
	if(pending.MatcherName == matchername)
	{
		MakeParametersReferencesUnwrapFast(pending.OverloadImplementation, pending.OverloadName, params)
	}
	else
	{
		MakeParametersReferencesForConstructor(Structures, matchername, params)
	}
}

MakeParametersReferencesUnwrap : PendingTypeMatcher ref pending, ExpressionList ref params
{
	MakeParametersReferencesUnwrapFast(pending.OverloadImplementation, pending.OverloadName, params)
}

MakeParametersReferencesForTypeMatcher : integer matchername, ExpressionList ref params
{
	ContextNode<PendingTypeMatcher> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<PendingTypeMatcher>(TypeMatchersWhichExistByMatcherName, matchername, wrap)
	if(found)
	{
		MakeParametersReferencesUnwrap(wrap, params)
	}
	else
	{
		MakeParametersReferencesForConstructor(Structures, matchername, params)
	}
}


MakeParametersReferencesForConstructor : list<StructureDefinition> ref structures, integer constructorname, ExpressionList ref params
{
	if(structures.value.ConstructorName == constructorname)
	{
		boolean ok = MakeParametersReferencesForStructureMembers(structures.value.Members, params.Expressions.next)
		if(!ok)
		{
			print("Failed to generate call to constructor " ; GetPooledString(constructorname))
			assert(false)
		}
	}
	elseif(structures.value.CopyConstructorName == constructorname)
	{
		MarkExpressionAsReference(params.Expressions.next)
	}
	else
	{
		MakeParametersReferencesForConstructor(structures.next, constructorname, params)
	}
}

MarkExpressionAsReference : list<Expression> ref expr
{
	MarkAtomAsReference(expr.value.Atoms.value)
}


MakeParametersReferencesForConstructor : nothing, integer constructorname, ExpressionList ref params
{
	MakeParametersReferencesForBuiltIn(constructorname, params)
}


MakeParametersReferencesForStructureMembers : list<StructureMember> ref members, list<Expression> ref params -> boolean ret = true
{
	assertmsg(GetMemberName(members.value) != 0, "Traversed dummy member of structure errantly")

	if(IsMemberReferenceType(members.value))
	{
		if(!MarkAtomAsReference(params.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
			DumpAtom(params.value.Atoms.value)
		}
	}

	ret = MakeParametersReferencesForStructureMembers(members.next, params.next)
}


MakeParametersReferencesForStructureMembers : list<StructureMember> ref members, nothing -> false
{
	if(GetMemberName(members.value) != 0)
	{
		// TODO - bug? custom constructors with optional arguments are not overload-resolving correctly maybe?!
		print("Constructor has too few arguments!")
	}
}

MakeParametersReferencesForStructureMembers : nothing, list<Expression> ref params -> false
{
	print("Constructor has too many arguments!")
}

MakeParametersReferencesForStructureMembers : nothing, nothing -> true



WalkFunctionParamsAndSetReferencesShim : FunctionDefinition ref func, OptionalExpressionList ref optexprs
{
	WalkFunctionParamsAndSetReferences(func.Params, optexprs)
}

WalkFunctionParamsAndSetReferences : nothing, ExpressionList ref paramexprs

WalkFunctionParamsAndSetReferences : FunctionParams ref params, ExpressionList ref paramexprs
{
	WalkFunctionParamsAndSetReferencesUnwrapped(params.Params, paramexprs.Expressions)
}


WalkFunctionParamsAndSetReferencesUnwrapped : list<UnresolvedParameter> ref params, list<Expression> ref paramexprs
{
	boolean needref = false
	if(IsReferenceType(params.value.ResolvedType))
	{
		assert((params.value.ResolvedType & 0x7f000000) != 0x09000000)
		needref = true
	}
	elseif(params.value.ResolvedType == 0x00000004)			// TODO - don't assume "nothing" is always passed by ref
	{
		needref = true
	}

	if(needref)
	{
		if(!MarkAtomAsReference(paramexprs.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
			DumpAtom(paramexprs.value.Atoms.value)
		}
	}

	listnode<UnresolvedParameter> np = params.next
	listnode<Expression> ne = paramexprs.next
	WalkFunctionParamsAndSetReferencesUnwrapped(np, ne)
}

WalkFunctionParamsAndSetReferencesUnwrapped : nothing, nothing



DemoteAtomType : list<ExpressionAtom> ref atoms [nogc]
{
	PerformDemotion(atoms, atoms.value)
}

PerformDemotion : list<ExpressionAtom> ref atoms, integer ref atom [nogc]
{
	integer16 newatom = cast(integer16, atom)
	ExpressionAtom wrap = newatom
	atoms.value = wrap
}

PerformDemotion : list<ExpressionAtom> ref atoms, IdentifierAtom ref atom [nogc]

PerformDemotion : list<ExpressionAtom> ref atoms, Statement ref atom [nogc]
{
	assertmsg(atom.Type == 0x01000002, "Failed to demote statement type")
}

PerformDemotion : list<ExpressionAtom> ref atoms, CompoundAtom ref atom [nogc]


PromoteAtomType : list<ExpressionAtom> ref atoms [nogc]
{
	PerformPromotion(atoms, atoms.value)
}

PerformPromotion : list<ExpressionAtom> ref atoms, integer ref atom [nogc]
{
	integer64 newatom = atom
	ExpressionAtom wrap = newatom
	atoms.value = wrap
}

PerformPromotion : list<ExpressionAtom> ref atoms, IdentifierAtom ref atom [nogc]

PerformPromotion : list<ExpressionAtom> ref atoms, Statement ref atom [nogc]
{
	integer atomtype = atom.Type
	while((atomtype & 0x7f000000) == 0x05000000)
	{
		atomtype = FindTypeAliasBase(atomtype)
	}

	assertmsg(atomtype == 0x01000005, "Failed to promote statement type")
}

PerformPromotion : list<ExpressionAtom> ref atoms, CompoundAtom ref atom [nogc]






FilterOverloadsForTypeDemotion : list<InferencePossibility> ref in, list<InferencePossibility> ref out
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false

	CheckIfContainsOnlyDemotedOverloads(in, hasdemoted, hassuperior, hasother)

	if(hasdemoted && hassuperior && (!hasother))
	{
		StripDemotedOverloads(in, out)
	}
	else
	{
		out = in
	}
}


FilterTypesForDemotion : simplelist<integer> ref in, simplelist<integer> ref out [nogc]
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false

	CheckIfContainsOnlyDemotedTypes(in, hasdemoted, hassuperior, hasother)

	if(hasdemoted && hassuperior && (!hasother))
	{
		StripDemotedTypes(in, out)
	}
	else
	{
		out = in
	}
}



FilterOverloadsForTypePromotion : list<InferencePossibility> ref in, list<InferencePossibility> ref out
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false

	CheckIfContainsOnlyDemotedOverloads(in, hasdemoted, hassuperior, hasother)

	if(hasdemoted && hassuperior && (!hasother))
	{
		StripPromotedOverloads(in, out)
	}
	else
	{
		out = in
	}
}


FilterTypesForPromotion : simplelist<integer> ref in, simplelist<integer> ref out [nogc]
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false

	CheckIfContainsOnlyDemotedTypes(in, hasdemoted, hassuperior, hasother)

	if(hassuperior && (!hasother) && (!hasdemoted))
	{
		StripPromotedTypes(in, out)
	}
	else
	{
		out = in
	}
}



CheckIfContainsOnlyDemotedOverloads : list<InferencePossibility> ref in, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]
{
	if(in.value.FunctionName != 0)
	{
		if(in.value.ParameterTypes.value.Types.value == 0x01000001)
		{
			hassuperior = true
		}
		elseif(in.value.ParameterTypes.value.Types.value == 0x01000002)
		{
			hasdemoted = true
		}
		elseif(in.value.ParameterTypes.value.Types.value == 0x01000005)
		{
			hassuperior = true
		}
		elseif(in.value.ParameterTypes.value.Types.value == 0)
		{
		}
		else
		{
			hasother = true
		}
	}

	CheckIfContainsOnlyDemotedOverloads(in.next, hasdemoted, hassuperior, hasother)
}

CheckIfContainsOnlyDemotedOverloads : nothing, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]


StripDemotedOverloads : list<InferencePossibility> ref in, list<InferencePossibility> ref out [nogc]
{
	if(in.value.FunctionName != 0)
	{
		if(in.value.ParameterTypes.value.Types.value != 0x01000002)
		{
			prepend<InferencePossibility>(out, in.value)
		}
	}

	StripDemotedOverloads(in.next, out)
}

StripDemotedOverloads : nothing, list<InferencePossibility> ref out [nogc]



StripPromotedOverloads : list<InferencePossibility> ref in, list<InferencePossibility> ref out [nogc]
{
	if(in.value.FunctionName != 0)
	{
		if(in.value.ParameterTypes.value.Types.value != 0x01000005)
		{
			prepend<InferencePossibility>(out, in.value)
		}
	}

	StripPromotedOverloads(in.next, out)
}

StripPromotedOverloads : nothing, list<InferencePossibility> ref out [nogc]




CheckIfContainsOnlyDemotedTypes : simplelist<integer> ref in, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]
{
	if(in.value == 0x01000001)
	{
		hassuperior = true
	}
	elseif(in.value == 0x01000002)
	{
		hasdemoted = true
	}
	elseif(in.value == 0x01000005)
	{
		hassuperior = true
	}
	elseif(in.value == 0)
	{
	}
	else
	{
		hasother = true
	}

	CheckIfContainsOnlyDemotedTypes(in.next, hasdemoted, hassuperior, hasother)
}

CheckIfContainsOnlyDemotedTypes : nothing, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]


StripDemotedTypes : simplelist<integer> ref in, simplelist<integer> ref out [nogc]
{
	if(in.value != 0)
	{
		if(in.value != 0x01000002)
		{
			simpleprepend<integer>(out, in.value)
		}
	}

	StripDemotedTypes(in.next, out)
}

StripDemotedTypes : nothing, simplelist<integer> ref out [nogc]



StripPromotedTypes : simplelist<integer> ref in, simplelist<integer> ref out [nogc]
{
	if(in.value != 0)
	{
		if(in.value != 0x01000005)
		{
			simpleprepend<integer>(out, in.value)
		}
	}

	StripPromotedTypes(in.next, out)
}

StripPromotedTypes : nothing, simplelist<integer> ref out [nogc]


CheckMemberTypes : list<StructureMember> ref members, simplelist<integer> ref types -> boolean match = true
{
	integer membertype = MakeNonReferenceType(GetMemberTypeDecompose(members.value))
	integer curtype = MakeNonReferenceType(types.value)

	while((membertype & 0x7f000000) == 0x05000000)
	{
		membertype = FindTypeAliasBase(membertype)
	}

	while((curtype & 0x7f000000) == 0x05000000)
	{
		curtype = FindTypeAliasBase(curtype)
	}


	if(membertype == curtype)
	{
		match = CheckMemberTypes(members.next, types.next)
	}
	elseif(SumTypeHasBase(membertype, curtype))
	{
		match = CheckMemberTypes(members.next, types.next)
	}
	else
	{
		match = false
	}
}

CheckMemberTypes : nothing, nothing -> true

CheckMemberTypes : list<StructureMember> ref members, nothing -> false

CheckMemberTypes : nothing, simplelist<integer> ref types -> boolean match = false
{
	if(types.value == 0)
	{
		match = true
	}
}



SignatureMatchesParams : list<Parameter> ref params, simplelist<integer> ref paramtypes, simplelist<boolean> ref paramrefflags -> boolean match = true
{
	if(params.value.Name == 0)
	{
		match = SignatureMatchesParams(params.next, paramtypes, paramrefflags)
	}
	elseif(paramtypes.value == 0)
	{
		match = SignatureMatchesParams(params, paramtypes.next, paramrefflags.next)
	}
	elseif(MakeNonReferenceType(params.value.Type) != GetTypeByName(paramtypes.value))
	{
		match = false
	}
	else
	{
		match = SignatureMatchesParams(params.next, paramtypes.next, paramrefflags.next)
	}
}

SignatureMatchesParams : nothing, simplelist<integer> ref paramtypes, simplelist<boolean> ref paramrefflags -> (paramtypes.value == 0)
SignatureMatchesParams : list<Parameter> ref params, nothing, nothing -> (params.value.Name == 0)

SignatureMatchesParams : nothing, nothing, nothing -> true

ResolveSignatureTypes : FunctionSignature ref signature
{
	ResolveSignatureTypes(signature.Parameters)
}

ResolveSignatureTypes : list<Parameter> ref params
{
	params.value.Type = GetTypeByName(params.value.Type)
	ResolveSignatureTypes(params.next)
}

ResolveSignatureTypes : nothing



FigureOutCastOriginType : list<Expression> ref params -> integer origintype = params.value.Type [nogc]

FigureOutCastOriginType : nothing -> 0 [nogc]


PopPendingFunctionForInference : ContextNode<FunctionDefinition> ref out -> boolean hasnode = false [nogc]
{
	hasnode = PopPendingFunctionForInferenceWorker(PendingInferenceFunctions, PendingInferenceFunctions.next, out)
}

PopPendingFunctionForInferenceWorker : list<FunctionDefinition> ref head, list<FunctionDefinition> ref tail, ContextNode<FunctionDefinition> ref out -> boolean hasnode = false [nogc]
{
	if(head.value.Name != 0)
	{
		ContextNode<FunctionDefinition> outwrap = head.value
		out = outwrap
		head = tail
		hasnode = true
	}
}

PopPendingFunctionForInferenceWorker : list<FunctionDefinition> ref head, nothing, ContextNode<FunctionDefinition> ref out -> boolean hasnode = false [nogc]
{
	assert(head.value.Name == 0)
}

PushPendingFunctionForInference : FunctionDefinition ref func [nogc]
{
	prepend<FunctionDefinition>(PendingInferenceFunctions, func)
}
