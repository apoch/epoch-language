
//
// Callback invoked when the code generation process can begin
//

OnCodeGenProcessProgram : BytecodeStream ref stream
{
	GenerateTypeMatcherMappings(Functions)
	GeneratePendingTypeMatchers(PendingTypeMatchers)

	CodeGenEmitStrings(stream)
	CodeGenEmitSumTypes(stream)
	CodeGenRearrangeStructures(Structures)
	CodeGenEmitStructures(stream, Structures)
	CodeGenEmitFunctionSignatures(stream, FunctionSignatures)

	if(GlobalCodeBlockName != 0)
	{
		CodeGenEmitSpecificScope(stream, GlobalScope.Wrapped)
	}

	CodeGenEmitScopes(stream)
	CodeGenEmitFunctionTags(stream, GlobalRootNamespace.FunctionTags)
	CodeGenEmitGlobalBlockPrologue(stream, GlobalCodeBlock)
	CodeGenEmitFunctions(stream, Functions)
	CodeGenEmitGlobalBlockEpilogue(stream, GlobalCodeBlock)
	CodeGenEmitTypeMatchers(stream, TypeMatchers)
	CodeGenEmitPatternMatchers(stream, PendingPatternMatchers)
	CodeGenEmitConstructors(stream, Structures)
}

OnCodeGenRegisterStructureMemVar : integer structurename, integer structuretype, integer membername, integer typenamehandle, boolean isref, boolean templated [nogc]
{
	integer refnum = 0
	if(isref)
	{
		refnum = 0x80000000
	}

	StructureMemberVariable member = membername, refnum, typenamehandle, nothing
	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		member.TemplateArgs = ScratchTemplateArgumentStack.value

		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}

	StructureMember memwrap = member
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSig : integer structurename, integer structuretype, integer name, integer rettypename [nogc]
{
	list<Parameter> p = dummyparam, nothing
	FunctionSignature signature = name, p, rettypename, false
	StructureMemberFunctionRef m = name, signature
	StructureMember memwrap = m
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSigParam : integer structurename, integer structuretype, integer membername, integer paramtype
{
	Parameter param = 1, paramtype
	FindStructureAndAddMemberParam(Structures, structurename, structuretype, membername, param)
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, simplelist<integer> ref typenames
{
	OnCodeGenRegisterStructureMemFuncSigParamList(structurename, structuretype, membername, typenames.next)

	if(typenames.value != 0)
	{
		OnCodeGenRegisterStructureMemFuncSigParam(structurename, structuretype, membername, typenames.value)
	}
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, nothing





OnCodeGenRegisterConstructors : integer structurename, integer constructorname, integer anonname, integer copyname [nogc]
{
	FindStructureAndSetConstructors(structurename, constructorname, anonname, copyname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, constructorname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, anonname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, copyname)
}

OnCodeGenRegisterScope : integer scopename, integer parentname, boolean attachtofunction
{
	list<Variable> v = dummyvar, nothing
	Scope scope = scopename, parentname, v, 0, 0
	
	BinaryTreeCreateOrInsert<Scope>(GlobalRootNamespace.Scopes, scopename, scope)
	
	if(attachtofunction)
	{
		Functions.value.AttachedScope.Wrapped = scope
	}
}


OnCodeGenRegisterGlobalBlock : integer name
{
	ContextStackEntry entry = STACK_TYPE_GLOBAL, name
	prepend<ContextStackEntry>(ContextStack, entry)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	GlobalCodeBlockName = name
	
	
	CacheGlobalCodeBlock()
}


OnCodeGenRegisterFunction : integer funcname, integer rawfuncname, string rawfuncnamestr, boolean istemplate
{
	ContextWrapper<Scope> scopewrap = nothing
	FunctionDefinition func = rawfuncname, funcname, nothing, nothing, nothing, dummyoverloadlist, scopewrap, rawfuncnamestr, 0, false, istemplate, false
	prepend<FunctionDefinition>(Functions, func)
	BinaryTreeCreateOrInsert<FunctionDefinition>(GlobalRootNamespace.Functions, funcname, func)

	// TODO - this is a weird bug. For some reason we don't init the field correctly in the above constructor
	if(istemplate)
	{
		func.IsTemplate = true
	}

	if(funcname != rawfuncname)
	{	
		ContextNode<FunctionDefinition> wrap = nothing
		if(SearchBinaryTreeForPayload<FunctionDefinition>(GlobalRootNamespace.Functions.RootNode, rawfuncname, wrap))
		{
			AttachContextToFunction(wrap, funcname, func)
		}
	}
	
	Overload selfoverload = rawfuncname, funcname, func
	prepend<Overload>(func.Overloads, selfoverload)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	if(istemplate)
	{
		CreateFunctionTemplateAndAttachParams(funcname, TemplateParameterQueue)

		// Reset template parameter queue
		list<TemplateParameter> dummylist = scratchtemplateparam, nothing
		TemplateParameterQueue = dummylist
	}
}


OnCodeGenEnterFunctionBody : integer funcname
{
	ContextStackEntry entry = STACK_TYPE_FUNCTION, funcname
	prepend<ContextStackEntry>(ContextStack, entry)
}

OnCodeGenEnterFunctionReturn : integer funcname, boolean anonymous
{
	ContextStackEntry entry = STACK_TYPE_FUNCRET, funcname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d

	Functions.value.AnonymousReturn = anonymous
	InFuncRetHack = true
}

OnCodeGenExitContext :
{
	integer entrytype = ContextStack.value.EntryType
	pop<ContextStackEntry>(ContextStack, ContextStack.next)

	if(entrytype == STACK_TYPE_STATEMENT)
	{
		if(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
		{
			AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
		}
		elseif(ContextStack.value.EntryType != STACK_TYPE_SUBSTATEMENT)
		{
			FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
		}
	}
	elseif(entrytype == STACK_TYPE_ASSIGNMENT)
	{
		FindCurrentAssignmentAndSetExpression(ScratchExpressions.value)
	}
	elseif(entrytype == STACK_TYPE_SUBSTATEMENT)
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
		PopCurrentStatementAndAppendToScratchExpression(ScratchExpressions, ScratchExpressions.next)
	}
	elseif(entrytype == STACK_TYPE_FUNCRET)
	{
		SetReturnExpression(Functions.value, ScratchExpressions.value)
		InFuncRetHack = false
	}
	elseif(entrytype == STACK_TYPE_FUNCTION)
	{
		assertmsg(CodeBlockDepth(CurrentCodeBlockStack) == 1, "Code block depth is invalid")
		SetFunctionCodeBlock(Functions.value, CurrentCodeBlockStack.value)
	}
	elseif(entrytype == STACK_TYPE_ENTITY_CODE)
	{
		Entity entity = EntityStack.value.Tag, EntityStack.value.PostfixTag, EntityStack.value.Param, CurrentCodeBlockStack.value
		AppendEntityToChain(ChainStack, entity)
		pop<Entity>(EntityStack, EntityStack.next)
		PopCodeBlock(CurrentCodeBlockStack, CurrentCodeBlockStack.next)
	}
	elseif(entrytype == STACK_TYPE_CHAIN)
	{
		CodeBlockEntry cbe = ChainStack.value
		AppendEntryToCurrentCodeBlock(cbe)
		pop<EntityChain>(ChainStack, ChainStack.next)
	}
	elseif(entrytype == STACK_TYPE_PARENTHETICAL)
	{
		ExpressionOrPrePostOp epp = ScratchExpressions.value
		ParentheticalExpression parenthetical = epp
		ExpressionAtom atom = parenthetical
		pop<Expression>(ScratchExpressions, ScratchExpressions.next)
		PlaceAtomInScratchExpression(atom)
	}
	elseif(entrytype == STACK_TYPE_GLOBAL)
	{
		SetGlobalCodeBlock(CurrentCodeBlockStack.value)
	}
}


OnCodeGenEnterTypeMatcher : integer matchername
{
	ContextStackEntry entry = STACK_TYPE_TYPEMATCH, matchername
	prepend<ContextStackEntry>(ContextStack, entry)

	list<FunctionSignature> dsl = dummysignature, nothing
	TypeMatcher matcher = matchername, dsl
	prepend<TypeMatcher>(TypeMatchers, matcher)
}


OnCodeGenRegisterLiteralBoolean : boolean value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralInteger : integer value, integer literaltype
{
	while((literaltype & 0x7f000000) == 0x05000000)
	{
		literaltype = FindTypeAliasBase(literaltype)
	}

	if(literaltype == 0x01000001)		// Integer32 type signature
	{
		ExpressionAtom atom = value
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		integer16 i16value = cast(integer16, value)
		ExpressionAtom atom = i16value
		PlaceAtomInScratchExpression(atom)
	}
}

OnCodeGenRegisterLiteralString : integer handle
{
	StringHandleAtom sha = handle
	ExpressionAtom atom = sha
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralReal : real value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterOperatorInvoke : integer ophandle
{
	OperatorInvokeAtom oia = ophandle
	ExpressionAtom atom = oia
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifier : integer idhandle, integer idtype
{
	IdentifierAtom id = idhandle, idtype, false, false
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifierReference : integer idhandle
{
	IdentifierAtom id = idhandle, 0, true, false
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterTypeAnnotation : integer annotationtype
{
	TypeAnnotationAtom taa = annotationtype
	ExpressionAtom atom = taa
	PlaceAtomInScratchExpression(atom)
}


OnCodeGenRegisterRefBinding : integer id, integer structureid, boolean isref, boolean inputref
{
	RefBinding binding = id, structureid, isref, inputref
	ExpressionAtom atom = binding
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenEnterStatement : integer statementname, integer statementtype, boolean toplevel, boolean hastemplateargs
{
	Statement statement = statementname, nothing, statementtype, nothing, toplevel, false

	if(hastemplateargs)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		statement.TemplateArgs = ScratchTemplateArgumentStack.value

		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}

	OnCodeGenEmplaceStatement(statement)
}

OnCodeGenEmplaceStatement : Statement ref statement
{
	if(ContextStack.value.EntryType == STACK_TYPE_SUBSTATEMENT)
	{
		prepend<Statement>(SubStatements, statement)
	}
	elseif(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
	{
		prepend<Statement>(SubStatements, statement)
	}
	else
	{
		CodeBlockEntry cbe = statement
		AppendEntryToCurrentCodeBlock(cbe)
		LastTopLevelStatementHack.Wrapped = statement
	}

	ContextStackEntry entry = STACK_TYPE_STATEMENT, statement.Name
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, expr)
}


OnCodeGenEnterMessageSend : integer targetname, integer messagename
{
	MessageSend msg = targetname, messagename, nothing, 0, nothing, false
	
	CodeBlockEntry cbe = msg
	AppendEntryToCurrentCodeBlock(cbe)
	
	ContextStackEntry entry = STACK_TYPE_MESSAGE, msg.MessageName
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, expr)
}


OnCodeGenEnterTask : integer taskname
{
	ContextStackEntry entry = STACK_TYPE_TASK, taskname
	prepend<ContextStackEntry>(ContextStack, entry)
}


OnCodeGenEnterAssignment : integer operator, integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	Assignment assignment = operator, lhsname, lhstype, annotation, rhs
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)

	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, lhsname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression blank = dummyatomlist, 0
	ScratchExpressions.value = blank
}


OnCodeGenChainAssignment : integer operator, integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	Assignment assignment = operator, lhsname, lhstype, annotation, rhs
	AppendEntryToCurrentAssignmentChain(assignment)
}


OnCodeGenEnterAssignmentCompound : integer operator, integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	AssignmentCompound assignment = operator, idlist, lhstype, annotation, rhs
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)
}

OnCodeGenAssignmentCompoundEnd :
{
	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression blank = dummyatomlist, 0
	ScratchExpressions.value = blank
}



OnCodeGenChainAssignmentCompound : integer operator, integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	AssignmentCompound assignment = operator, idlist, lhstype, annotation, rhs
	AppendEntryToCurrentAssignmentChain(assignment)
}

OnCodeGenEnterSubStatement :
{
	ContextStackEntry entry = STACK_TYPE_SUBSTATEMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)
}





CodeGenEmitSingleString : integer handle, string ref contents, BytecodeStream ref stream -> boolean ret = true [nogc]
{
	BytecodePoolString(stream, handle, contents)
}


CodeGenEmitStrings : BytecodeStream ref stream
{
	BinaryTreeWalkAllNodesWithParam<string, BytecodeStream>(GlobalStringPool.LookupMap.RootNode, CodeGenEmitSingleString, stream)
}



CodeGenEmitStructures : BytecodeStream ref stream, list<StructureDefinition> ref structures
{
	CodeGenEmitStructures(stream, structures.next)

	if((structures.value.Name != 0) && (!structures.value.IsTemplate))
	{
		BytecodeDefineStructure(stream, structures.value.Type, structures.value.MemberCount)
		CodeGenEmitMembers(stream, structures.value.Members)
	}
}

CodeGenEmitStructures : BytecodeStream ref stream, nothing


CodeGenEmitMembers : BytecodeStream ref stream, list<StructureMember> ref members
{
	CodeGenEmitMember(stream, members.value)
	CodeGenEmitMembers(stream, members.next)
}

CodeGenEmitMembers : BytecodeStream ref stream, nothing

CodeGenEmitMember : BytecodeStream ref stream, StructureMemberVariable ref memvar
{
	integer membertype = memvar.Type
	while((membertype & 0x7f000000) == 0x05000000)
	{
		membertype = FindTypeAliasBase(membertype)
	}

	BytecodeStructureMember(stream, memvar.Name, membertype)
}

CodeGenEmitMember : BytecodeStream ref stream, StructureMemberFunctionRef ref member
{
	BytecodeStructureMember(stream, member.Name, GetMemberTypeDecompose(member))
}



CodeGenEmitSingleScope : integer scopename, Scope ref scope, BytecodeStream ref stream -> boolean ret = true
{
	if((scope.Name != 0) && (scope.Name != GlobalCodeBlockName))
	{
		integer parentname = scope.ParentName
		if((parentname == 0) && (scope.Name != GlobalCodeBlockName))
		{
			parentname = GlobalCodeBlockName
		}

		integer varcount = CountScopeVariables(scope)
		BytecodeLexicalScope(stream, scope.Name, parentname, varcount)
		CodeGenEmitVariables(stream, scope.Variables, scope.Name)
	}
}

CodeGenEmitScopes : BytecodeStream ref stream
{
	BinaryTreeWalkAllNodesWithParam<Scope, BytecodeStream>(GlobalRootNamespace.Scopes.RootNode, CodeGenEmitSingleScope, stream)
}


CodeGenEmitSpecificScope : BytecodeStream ref stream, Scope ref scope
{
	integer varcount = CountScopeVariables(scope)
	BytecodeLexicalScope(stream, scope.Name, 0, varcount)
	CodeGenEmitVariables(stream, scope.Variables, 0)
}


CodeGenEmitVariables : BytecodeStream ref stream, list<Variable> ref vars, integer funcname
{
	if(vars.value.Name != 0)
	{
		integer basetype = vars.value.VarType
		while((basetype & 0x7f000000) == 0x05000000)
		{
			basetype = FindTypeAliasBase(basetype)
		}

		if(vars.value.Origin == 2)
		{
			if(listcontains(CustomConstructors, funcname))
			{
				BytecodeLexicalScopeEntry(stream, vars.value.Name, basetype, 0)
			}
			else
			{
				BytecodeLexicalScopeEntry(stream, vars.value.Name, basetype, vars.value.Origin)
			}
		}
		else
		{
			BytecodeLexicalScopeEntry(stream, vars.value.Name, basetype, vars.value.Origin)
		}
	}

	CodeGenEmitVariables(stream, vars.next, funcname)
}

CodeGenEmitVariables : BytecodeStream ref stream, nothing, integer funcname



CodeGenEmitFunctions : BytecodeStream ref stream, list<FunctionDefinition> ref table
{
	if(!table.value.IsTemplate)
	{
		if(table.value.Name != 0)
		{
			FindScopeAndSetContext(table.value)

			EmittingFunctionName = table.value.Name
			BytecodeEnterFunction(stream, table.value.Name)
			CodeGenEmitFunctionReturn(stream, table.value.Return)

			if(table.value.InvokeTag != 0)
			{
				BytecodeInvoke(stream, table.value.InvokeTag)
			}

			CodeGenEmitCodeBlock(stream, table.value.Code)
			if(listcontains(CustomConstructors, table.value.Name))
			{
				BytecodePushVarValueNoCopy(stream, FindReturnVariableName())
				BytecodeBindReference(stream, 0, 0)			// TODO - kind of a hack
				BytecodeAssign(stream)
			}
			else
			{
				if(table.value.AnonymousReturn)
				{
					CodeGenEmitReturnRegisterAnonymous(stream, table.value.Return)
				}
				else
				{
					CodeGenEmitReturnRegister(stream, table.value.Return)
				}
			}
			BytecodeExitFunction(stream)
		}
	}

	CodeGenEmitFunctions(stream, table.next)
}

CodeGenEmitFunctions : BytecodeStream ref stream, nothing


CodeGenEmitFunctionReturn : BytecodeStream ref stream, Expression ref expr
{
	CodeGenEmitExpressionAtoms(stream, expr.Atoms, false, false)
}

CodeGenEmitFunctionReturn : BytecodeStream ref stream, nothing


CodeGenEmitReturnRegister : BytecodeStream ref stream, Expression ref expr
{
	integer index = FindReturnVariableIndex()
	BytecodeSetReturnRegister(stream, index)
}

CodeGenEmitReturnRegister : BytecodeStream ref stream, nothing


CodeGenEmitReturnRegisterAnonymous : BytecodeStream ref stream, Expression ref expr
{
	integer index = FindReturnVariableIndex()

	BytecodeBindReference(stream, 0, index)
	BytecodeAssign(stream)

	BytecodeSetReturnRegister(stream, index)
}

CodeGenEmitReturnRegisterAnonymous : BytecodeStream ref stream, nothing



CodeGenEmitCodeBlock : BytecodeStream ref stream, CodeBlock ref block
{
	CodeGenEmitCodeBlockEntries(stream, block.Entries)
}

CodeGenEmitCodeBlock : BytecodeStream ref stream, nothing


CodeGenEmitCodeBlockEntries : BytecodeStream ref stream, list<CodeBlockEntry> ref entries
{
	CodeGenEmitSingleCodeBlockEntry(stream, entries.value)
	CodeGenEmitCodeBlockEntries(stream, entries.next)
}

CodeGenEmitCodeBlockEntries : BytecodeStream ref stream, nothing


CodeGenEmitSingleCodeBlockEntry : BytecodeStream ref stream, Statement ref s
{
	boolean constructssumtype = false
	if((s.Type & 0x7f000000) == 0x07000000)
	{
		constructssumtype = true
	}

	boolean constructorcall = StructureConstructorExists(Structures, s.Name)

	CodeGenEmitExpressionList(stream, s.Parameters, constructssumtype, constructorcall)

	if(FunctionIsAutoGenOrHasIR(s.Name))
	{
		BytecodeInvokeOffset(stream, s.Name)
	}
	elseif(SumTypeExists(s.Name))
	{
		BytecodeConstructSumType(stream)
	}
	else
	{
		integer vartype = GetVariableTypeFromScope(EmittingScope.Wrapped, s.Name)
		if((vartype != 0) && ((vartype & 0x7f000000) == 0x09000000))
		{
			BytecodeInvokeIndirect(stream, s.Name)
		}
		else
		{
			if(!IsRecognizedBuiltIn(s.Name))
			{
				print("ILLEGAL EXTERNAL FUNCTION: " ; GetPooledString(s.Name))
				assert(false)
			}
			
			BytecodeInvoke(stream, s.Name)
		}
	}
}

CodeGenEmitSingleCodeBlockEntry : BytecodeStream ref stream, MessageSend ref m
{
	// TODO - send message to target task instead of just invoking a function
	CodeGenEmitExpressionList(stream, m.Parameters, false, false)
	BytecodeInvokeOffset(stream, m.MessageName)
}

CodeGenEmitAssignmentRHS : BytecodeStream ref stream, Expression ref expr
{
	CodeGenEmitExpressionAtoms(stream, expr.Atoms, false, false)
}

CodeGenEmitAssignmentRHS : BytecodeStream ref stream, Assignment ref a
{
	CodeGenEmitAssignmentRHS(stream, a.RHS)

	integer frames = 0
	integer index = FindVariable(a.LHSName, frames)
	BytecodeBindReference(stream, frames, index)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		BytecodeAssignSumType(stream)
	}
	else
	{
		BytecodeAssign(stream)
	}

	CodeGenEmitBindingsForVariable(stream, a.LHSName)
	BytecodeReadReference(stream)
}

CodeGenEmitSingleCodeBlockEntry : BytecodeStream ref stream, Assignment ref a
{
	boolean sideeffects = false

	if(a.Operator != PooledStringHandleForAssignment)
	{
		sideeffects = true
		CodeGenEmitBindingsForVariable(stream, a.LHSName)
		BytecodeReadReference(stream)
	}

	CodeGenEmitAssignmentRHS(stream, a.RHS)

	if(sideeffects)
	{
		BytecodeInvoke(stream, a.Operator)
	}

	if(a.Annotation != 0)
	{
		BytecodePushTypeAnnotation(stream, a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHSName, frames)
	BytecodeBindReference(stream, frames, index)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		BytecodeAssignSumType(stream)
	}
	else
	{
		BytecodeAssign(stream)
	}
}

CodeGenEmitSingleCodeBlockEntry : BytecodeStream ref stream, AssignmentCompound ref a
{
	boolean sideeffects = false
	if(a.Operator != PooledStringHandleForAssignment)
	{
		sideeffects = true
		CodeGenEmitBindingsForOperand(stream, a.LHS)
		BytecodeReadReference(stream)
	}

	CodeGenEmitAssignmentRHS(stream, a.RHS)

	if(sideeffects)
	{
		BytecodeInvoke(stream, a.Operator)
	}

	if(a.Annotation != 0)
	{
		BytecodePushTypeAnnotation(stream, a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHS.value, frames)
	BytecodeBindReference(stream, frames, index)

	integer typeid = MakeNonReferenceType(FindVariableType(a.LHS.value))

	integer structurename = GetNameOfStructureByType(typeid)
	BindAssignmentMembers(stream, a.LHS.next, structurename)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		BytecodeAssignSumType(stream)
	}
	else
	{
		BytecodeAssign(stream)
	}
}


CodeGenEmitBindingsForOperand : BytecodeStream ref stream, simplelist<integer> ref operand
{
	integer frames = 0
	integer index = FindVariable(operand.value, frames)
	BytecodeBindReference(stream, frames, index)

	integer structurename = GetNameOfStructureByType(FindVariableType(operand.value))
	BindAssignmentMembers(stream, operand.next, structurename)
}

CodeGenEmitBindingsForVariable : BytecodeStream ref stream, integer operand
{
	integer frames = 0
	integer index = FindVariable(operand, frames)
	BytecodeBindReference(stream, frames, index)
}


CodeGenEmitSingleCodeBlockEntry : BytecodeStream ref stream, PreOpStatement ref preop
{
	CodeGenEmitBindingsForOperand(stream, preop.Operand)
	BytecodeReadReference(stream)
	BytecodeInvoke(stream, preop.Operator)
	CodeGenEmitBindingsForOperand(stream, preop.Operand)
	BytecodeAssign(stream)
}

CodeGenEmitSingleCodeBlockEntry : BytecodeStream ref stream, PostOpStatement ref postop
{
	CodeGenEmitBindingsForOperand(stream, postop.Operand)
	BytecodeReadReference(stream)
	BytecodeInvoke(stream, postop.Operator)
	CodeGenEmitBindingsForOperand(stream, postop.Operand)
	BytecodeAssign(stream)
}



CodeGenEmitSingleCodeBlockEntry : BytecodeStream ref stream, EntityChain ref chain
{
	BytecodeBeginChain(stream)
	CodeGenEmitEntityChain(stream, chain.Entries)
	BytecodeEndChain(stream)
}


CodeGenEmitEntityChain : BytecodeStream ref stream, EntityList ref entities
{
	CodeGenEmitEntityList(stream, entities.ActualList)
}

CodeGenEmitEntityList : BytecodeStream ref stream, list<Entity> ref thelist
{
	if(thelist.value.Tag != 0)
	{
		CodeGenEmitExpression(stream, thelist.value.Param, false, false)
		BytecodeEnterEntity(stream, thelist.value.Tag, 0)
		CodeGenEmitCodeBlock(stream, thelist.value.Code)
		BytecodeExitEntity(stream)
	}

	CodeGenEmitEntityList(stream, thelist.next)
}

CodeGenEmitEntityList : BytecodeStream ref stream, nothing


BindAssignmentMembers : BytecodeStream ref stream, simplelist<integer> ref lhsmembers, integer structurename
{
	integer membertype = 0
	integer memberoffset = 0
	GetStructureMemberTypeAndOffset(structurename, lhsmembers.value, membertype, memberoffset)
	
	while((membertype & 0x7f000000) == 0x05000000)
	{
		membertype = FindTypeAliasBase(membertype)
	}

	BytecodeBindStructReference(stream, membertype, memberoffset)

	// Recurse
	assertmsg(membertype != 0, "Member has no type!")
	BindAssignmentMembers(stream, lhsmembers.next, GetNameOfType(membertype))
}

BindAssignmentMembers : BytecodeStream ref stream, nothing, integer structurename



CodeGenEmitExpressionList : BytecodeStream ref stream, nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpressionList : BytecodeStream ref stream, ExpressionList ref expressions, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionList(stream, expressions.Expressions, constructssumtype, constructorcall)
}

CodeGenEmitExpressionList : BytecodeStream ref stream, list<Expression> ref expressions, boolean constructssumtype, boolean constructorcall
{
	boolean constructssumtypetemp = constructssumtype
	if((expressions.value.Type & 0x7f000000) == 0x07000000)
	{
		constructssumtypetemp = true
	}

	CodeGenEmitExpressionAtoms(stream, expressions.value.Atoms, constructssumtypetemp, constructorcall)
	CodeGenEmitExpressionList(stream, expressions.next, constructssumtype, constructorcall)
}

CodeGenEmitExpression : BytecodeStream ref stream, nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpression : BytecodeStream ref stream, Expression ref expr, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionAtoms(stream, expr.Atoms, constructssumtype, constructorcall)
}

CodeGenEmitExpressionAtoms : BytecodeStream ref stream, list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean constructorcall
{
	boolean needsref = false
	CodeGenEmitExpressionAtomsWorker(stream, atoms, constructssumtype, needsref, constructorcall)
	if(needsref)
	{
		if(constructssumtype)
		{
			BytecodeReadReferenceAnnotated(stream)
		}
		else
		{
			BytecodeReadReference(stream)
		}
	}
}

CodeGenEmitExpressionAtomsWorker : BytecodeStream ref stream, list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean ref needsref, boolean constructorcall
{
	boolean thisneedsref = CodeGenCheckAtomForReadRef(atoms.value)
	if(thisneedsref)
	{
		needsref = true
	}
	elseif(needsref)
	{
		if(constructssumtype)
		{
			BytecodeReadReferenceAnnotated(stream)
		}
		else
		{
			BytecodeReadReference(stream)
		}
		needsref = false
	}

	CodeGenEmitSingleAtom(stream, atoms.value, constructorcall)
	CodeGenEmitExpressionAtomsWorker(stream, atoms.next, constructssumtype, needsref, constructorcall)
}

CodeGenEmitExpressionAtomsWorker : BytecodeStream ref stream, nothing, boolean constructssumtype, boolean ref needsref, boolean constructorcall


CodeGenCheckAtomForReadRef : RefBinding ref atom -> !atom.IsReference [nogc]
CodeGenCheckAtomForReadRef : CompoundAtom ref atom -> false [nogc]

CodeGenCheckAtomForReadRef : integer ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : integer16 ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : boolean ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : real ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : IdentifierAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : StringHandleAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : OperatorInvokeAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : TypeAnnotationAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : Statement ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : ParentheticalExpression ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : AtomSentinel ref atom -> false [nogc]




CodeGenEmitSingleAtom : BytecodeStream ref stream, integer ref literalinteger, boolean constructor
{
	BytecodePushLiteralInteger(stream, literalinteger)
}

CodeGenEmitSingleAtom : BytecodeStream ref stream, integer16 ref literalinteger16, boolean constructor
{
	BytecodePushLiteralInteger16(stream, literalinteger16)
}

CodeGenEmitSingleAtom : BytecodeStream ref stream, boolean ref literalboolean, boolean constructor
{
	BytecodePushBoolean(stream, literalboolean)
}

CodeGenEmitSingleAtom : BytecodeStream ref stream, real ref literalreal, boolean constructor
{
	BytecodePushLiteralReal(stream, literalreal)
}

CodeGenEmitSingleAtom : BytecodeStream ref stream, StringHandleAtom ref atom, boolean constructor
{
	BytecodePushLiteralString(stream, atom.Handle)
}

CodeGenEmitSingleAtom : BytecodeStream ref stream, OperatorInvokeAtom ref atom, boolean constructor
{
	BytecodeInvoke(stream, atom.OperatorName)
}

CodeGenEmitSingleAtom : BytecodeStream ref stream, IdentifierAtom ref idatom, boolean constructor
{
	integer atomtype = MakeNonReferenceType(idatom.Type)

	if(atomtype == 0x00000004)							// Nothing type signature
	{
		BytecodePushLiteralInteger(stream, 0)
	}
	else
	{
		if(idatom.IsFunction)
		{
			BytecodePushLiteralFunction(stream, idatom.Handle)
		}
		elseif(GetTypeByName(idatom.Handle) != 0)
		{
			BytecodePushLiteralString(stream, idatom.Handle)
		}
		else
		{
			if(atomtype == 0x01000000)					// Identifier type signature
			{
				if((!constructor) && (!idatom.IsReference))
				{
					BytecodePushLiteralString(stream, idatom.Handle)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					BytecodeBindReference(stream, frames, index)
				}
			}
			elseif((atomtype & 0x7f000000) == 0x09000000)			// Function type family signature
			{
				BytecodePushLiteralFunction(stream, idatom.Handle)
			}
			else
			{
				if(idatom.IsReference)
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					BytecodeBindReference(stream, frames, index)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)

					if(frames == 0)
					{
						BytecodePushVarValue(stream, idatom.Handle, idatom.Type)
					}
					elseif(IsReferenceType(idatom.Type))
					{
						BytecodeBindReference(stream, frames, index)
					}
					else
					{
						Variable var = 0, 0, 0, 0
						FindVariableDataInSingleScope(GlobalScope.Wrapped, idatom.Handle, var)

						if(var.Name == 0)
						{
							print("Code generation error - missing local variable " ; GetPooledString(idatom.Handle) ; " in scope " ; GetPooledString(EmittingFunctionName))
							assert(false)
						}
						
						BytecodePushLocal(stream, frames, var.Offset)
					}
				}
			}
		}
	}
}

CodeGenEmitSingleAtom : BytecodeStream ref stream, TypeAnnotationAtom ref atom, boolean constructor
{
	integer atomtype = MakeNonReferenceType(atom.Type)
	while((atomtype & 0x7f000000) == 0x05000000)
	{
		atomtype = FindTypeAliasBase(atomtype)
	}
	BytecodePushTypeAnnotation(stream, atomtype)
}

CodeGenEmitSingleAtom : BytecodeStream ref stream, Statement ref atom, boolean constructor
{
	CodeGenEmitSingleCodeBlockEntry(stream, atom)
}

CodeGenEmitSingleAtom : BytecodeStream ref stream, RefBinding ref atom, boolean constructor
{
	integer memtype = 0
	integer memoffset = 0
	GetStructureMemberTypeAndOffset(atom.StructureName, atom.Identifier, memtype, memoffset)

	while((memtype & 0x7f000000) == 0x05000000)
	{
		memtype = FindTypeAliasBase(memtype)
	}

	BytecodeBindStructReference(stream, memtype, memoffset)
}

CodeGenEmitSingleAtom : BytecodeStream ref stream, ParentheticalExpression ref expr, boolean constructor
{
	CodeGenDecomposeParenthetical(stream, expr.Inner)
}

CodeGenDecomposeParenthetical : BytecodeStream ref stream, Expression ref expr
{
	CodeGenEmitExpression(stream, expr, false, false)
}

CodeGenDecomposeParenthetical : BytecodeStream ref stream, PreOpStatement ref statement
{
	CodeGenEmitSingleCodeBlockEntry(stream, statement)
	CodeGenEmitBindingsForOperand(stream, statement.Operand)
	BytecodeReadReference(stream)
}

CodeGenDecomposeParenthetical : BytecodeStream ref stream, PostOpStatement ref statement
{
	CodeGenEmitBindingsForOperand(stream, statement.Operand)
	BytecodeReadReference(stream)
	CodeGenEmitSingleCodeBlockEntry(stream, statement)
}

CodeGenEmitSingleAtom : BytecodeStream ref stream, CompoundAtom ref atom, boolean constructor
{
	integer frames = 0
	integer index = FindVariable(atom.Bindings.value.Identifier, frames)
	BytecodeBindReference(stream, frames, index)

	EmitCompoundBindings(stream, atom.Bindings, atom.Bindings.next)

	if(!IsReferenceType(atom.Type))
	{
		if((atom.Type & 0x7f000000) == 0x07000000)
		{
			BytecodeReadReferenceAnnotated(stream)
		}
		else
		{
			BytecodeReadReference(stream)
		}
	}
}

EmitCompoundBindings : BytecodeStream ref stream, list<RefBinding> ref bindings, list<RefBinding> ref tail
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(EmittingScope.Wrapped, bindings.value.Identifier, var)

	assertmsg(var.VarType != 0, "Compound bindings reference bogus variable")
	integer lhstypename = GetNameOfType(var.VarType)

	integer memtype = 0
	integer memoffset = 0
	GetStructureMemberTypeAndOffset(lhstypename, tail.value.Identifier, memtype, memoffset)

	while((memtype & 0x7f000000) == 0x05000000)
	{
		memtype = FindTypeAliasBase(memtype)
	}

	BytecodeBindStructReference(stream, memtype, memoffset)

	EmitCompoundSubsequentBindings(stream, tail.next)
}

EmitCompoundSubsequentBindings : BytecodeStream ref stream, nothing

EmitCompoundSubsequentBindings : BytecodeStream ref stream, list<RefBinding> ref bindings
{
	CodeGenEmitSingleAtom(stream, bindings.value, false)
	EmitCompoundSubsequentBindings(stream, bindings.next)
}


CodeGenEmitSingleAtom : BytecodeStream ref stream, AtomSentinel ref sentinel, boolean constructor


CodeGenEmitSingleSumType : integer typeid, SumType ref st, BytecodeStream ref stream -> boolean ret = true [nogc]
{
	if((st.Type != 0) && (!st.IsTemplate))
	{
		ByteStreamEmitByte(stream.Buffer, stream.Offset, 0x1f)			// SumTypeDef instruction
		ByteStreamEmitInteger(stream.Buffer, stream.Offset, st.Type)
		ByteStreamEmitInteger(stream.Buffer, stream.Offset, CountSumTypeBases(st.Bases))
		CodeGenEmitSumTypeBase(stream, st.Bases)
	}
}

CodeGenEmitSumTypes : BytecodeStream ref stream
{
	BinaryTreeWalkAllNodesWithParam<SumType, BytecodeStream>(GlobalRootNamespace.SumTypes.RootNode, CodeGenEmitSingleSumType, stream)
}



CodeGenEmitSumTypeBase : BytecodeStream ref stream, list<SumTypeBase> ref bases [nogc]
{
	CodeGenEmitSumTypeBase(stream, bases.next)

	if(bases.value.Name != 0)
	{
		ByteStreamEmitInteger(stream.Buffer, stream.Offset, bases.value.Name)
	}
}

CodeGenEmitSumTypeBase : BytecodeStream ref stream, nothing [nogc]



CodeGenEmitTypeMatchers : BytecodeStream ref stream, list<TypeMatcher> ref matchers
{
	if(matchers.value.Name != 0)
	{
		BytecodeLexicalScope(stream, matchers.value.Name, 0, 0)
		BytecodeEnterTypeResolver(stream, matchers.value.Name)
		CodeGenEmitTypeMatcherOverloads(stream, matchers.value.Overloads)
		BytecodeExitTypeResolver(stream)
	}

	CodeGenEmitTypeMatchers(stream, matchers.next)
}

CodeGenEmitTypeMatchers : BytecodeStream ref stream, nothing

CodeGenEmitTypeMatcherOverloads : BytecodeStream ref stream, list<FunctionSignature> ref signatures
{
	CodeGenEmitTypeMatcherOverloads(stream, signatures.next)

	if(signatures.value.Name != 0)
	{
		ByteStreamEmitByte(stream.Buffer, stream.Offset, 0x20)				// TypeMatch instruction
		ByteStreamEmitInteger(stream.Buffer, stream.Offset, signatures.value.Name)
		ByteStreamEmitInteger(stream.Buffer, stream.Offset, 0)
		ByteStreamEmitInteger(stream.Buffer, stream.Offset, CountParameters(signatures.value.Parameters))

		CodeGenEmitTypeMatcherParams(stream, signatures.value.Parameters)
	}
}

CodeGenEmitTypeMatcherOverloads : BytecodeStream ref stream, nothing


CodeGenEmitTypeMatcherParams : BytecodeStream ref stream, list<Parameter> ref params [nogc]
{
	CodeGenEmitTypeMatcherParams(stream, params.next)

	if(params.value.Name != 0)
	{
		integer refflag = 0
		if(IsReferenceType(params.value.Type))
		{
			refflag = 1
		}
		
		integer paramtype = MakeNonReferenceType(params.value.Type)
		while((paramtype & 0x7f000000) == 0x05000000)
		{
			paramtype = FindTypeAliasBase(paramtype)
		}

		ByteStreamEmitByte(stream.Buffer, stream.Offset, refflag)
		ByteStreamEmitInteger(stream.Buffer, stream.Offset, paramtype)
	}
}

CodeGenEmitTypeMatcherParams : BytecodeStream ref stream, nothing [nogc]


OnCodeGenRegisterFunctionTag : integer funcname, string tagname, integer rawfuncname
{
	list<string> dtp = "", nothing
	FunctionTag tag = funcname, tagname, dtp
	ListPrependOrCreate<FunctionTag>(GlobalRootNamespace.FunctionTags, tag)

	if(tagname == "constructor")
	{
		simpleprepend<integer>(CustomConstructors, funcname)

		integer baseconstructorname = PoolString(GetPooledString(rawfuncname) ; "@@constructor")

		Overload overload = baseconstructorname, funcname, nothing
		prepend<Overload>(AutoGenOverloads, overload)
		FindFunctionAndAddOverload(overload)

		PrependFunctionParameter(Functions, funcname, PoolString("@id"), 0x81000000)		// reference to identifier type signature
	}
}

OnCodeGenRegisterFunctionTagParam : integer funcname, string tagname, string param
{
	// TODO - less lazy implementation (find function and tag)
	AppendFunctionTagParamUnwrap(GlobalRootNamespace.FunctionTags, param)
}

AppendFunctionTagParamUnwrap : list<FunctionTag> ref tags, string param
{
	AppendFunctionTagParam(tags.value.Parameters, tags.value.Parameters.next, param)
}

AppendFunctionTagParamUnwrap : nothing, string param
{
	assertmsg(false, "Function tag parameter registered but no function tags have been set up!")
}


CodeGenEmitFunctionTags : BytecodeStream ref stream, list<FunctionTag> ref tags
{
	if(tags.value.FunctionName != 0)
	{
		if((tags.value.TagName != "") && (tags.value.TagName != "static"))
		{
			ByteStreamEmitByte(stream.Buffer, stream.Offset, 0x1a)
			ByteStreamEmitInteger(stream.Buffer, stream.Offset, tags.value.FunctionName)
			ByteStreamEmitInteger(stream.Buffer, stream.Offset, CountTagParams(tags.value.Parameters))
			ByteStreamEmitString(stream.Buffer, stream.Offset, tags.value.TagName)

			CodeGenEmitFunctionTagParams(stream, tags.value.Parameters)
		}
	}
	CodeGenEmitFunctionTags(stream, tags.next)
}

CodeGenEmitFunctionTags : BytecodeStream ref stream, nothing



CodeGenEmitFunctionTagParams : BytecodeStream ref stream, list<string> ref params [nogc]
{
	if(params.value != "")
	{
		ByteStreamEmitString(stream.Buffer, stream.Offset, params.value)
	}

	CodeGenEmitFunctionTagParams(stream, params.next)
}

CodeGenEmitFunctionTagParams : BytecodeStream ref stream, nothing [nogc]



CodeGenEmitConstructors : BytecodeStream ref stream, list<StructureDefinition> ref structures
{
	if((structures.value.Name != 0) && (!structures.value.IsTemplate))
	{
		EmitCtorTag(stream, structures.value.ConstructorName)
		EmitCtorTag(stream, structures.value.AnonConstructorName)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCtorTag(stream, structures.value.CopyConstructorName)
		}

		EmitConstructor(stream, structures.value)
		EmitAnonConstructor(stream, structures.value)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCopyConstructor(stream, structures.value)
		}
	}

	CodeGenEmitConstructors(stream, structures.next)
}

CodeGenEmitConstructors : BytecodeStream ref stream, nothing

EmitCtorTag : BytecodeStream ref stream, integer funcname
{
	ByteStreamEmitByte(stream.Buffer, stream.Offset, 0x1a)
	ByteStreamEmitInteger(stream.Buffer, stream.Offset, funcname)
	ByteStreamEmitInteger(stream.Buffer, stream.Offset, 0)
	ByteStreamEmitString(stream.Buffer, stream.Offset, "@@autogen@constructor")
}


EmitConstructor : BytecodeStream ref stream, StructureDefinition ref def
{
	integer idhandle = PooledStringHandleForIdentifier

	BytecodeLexicalScope(stream, def.ConstructorName, 0, def.MemberCount + 1)
	BytecodeLexicalScopeEntry(stream, idhandle, 0x81000000, 1)
	EmitScopeEntriesForMembers(stream, def.Members)

	BytecodeEnterFunction(stream, def.ConstructorName)
	BytecodeAllocStructure(stream, def.Type)
	BytecodeBindReference(stream, 0, 0)
	BytecodeAssign(stream)

	EmitMemberDataCopies(stream, def.Members, idhandle)

	BytecodeExitFunction(stream)
}

EmitAnonConstructor : BytecodeStream ref stream, StructureDefinition ref def
{
	integer membercount = def.MemberCount
	
	BytecodeLexicalScope(stream, def.AnonConstructorName, 0, membercount + 1)
	EmitScopeEntriesForMembers(stream, def.Members)
	BytecodeLexicalScopeEntry(stream, def.AnonConstructorName, def.Type, 2)

	BytecodeEnterFunction(stream, def.AnonConstructorName)
	BytecodeAllocStructure(stream, def.Type)
	BytecodeBindReference(stream, 0, membercount)
	BytecodeAssign(stream)

	EmitMemberDataCopies(stream, def.Members, def.AnonConstructorName)

	BytecodeSetReturnRegister(stream, membercount)
	BytecodeExitFunction(stream)
}

EmitCopyConstructor : BytecodeStream ref stream, StructureDefinition ref def
{
	BytecodeLexicalScope(stream, def.CopyConstructorName, 0, 2)
	BytecodeLexicalScopeEntry(stream, PooledStringHandleForIdentifier, 0x81000000, 1)
	BytecodeLexicalScopeEntry(stream, def.Name, def.Type, 1)

	BytecodeEnterFunction(stream, def.CopyConstructorName)
	BytecodePushVarValueNoCopy(stream, def.Name)
	BytecodeCopyStructure(stream)
	BytecodeBindReference(stream, 0, 0)
	BytecodeAssign(stream)
	BytecodeExitFunction(stream)
}


EmitScopeEntriesForMembers : BytecodeStream ref stream, list<StructureMember> ref members
{
	EmitScopeEntryForMember(stream, members.value)
	EmitScopeEntriesForMembers(stream, members.next)
}

EmitScopeEntriesForMembers : BytecodeStream ref stream, nothing


EmitScopeEntryForMember : BytecodeStream ref stream, StructureMemberVariable ref memvar
{
	if(memvar.Name != 0)
	{
		integer membertype = memvar.Type
		while((membertype & 0x7f000000) == 0x05000000)
		{
			membertype = FindTypeAliasBase(membertype)
		}
		
		BytecodeLexicalScopeEntry(stream, memvar.Name, membertype, 1)
	}
}

EmitScopeEntryForMember : BytecodeStream ref stream, StructureMemberFunctionRef ref memvar
{
	if(memvar.Name != 0)
	{
		BytecodeLexicalScopeEntry(stream, memvar.Name, GetMemberTypeDecompose(memvar), 1)
	}
}



EmitMemberDataCopies : BytecodeStream ref stream, list<StructureMember> ref members, integer idhandle
{
	EmitMemberDataCopy(stream, members.value, idhandle)
	EmitMemberDataCopies(stream, members.next, idhandle)
}

EmitMemberDataCopies : BytecodeStream ref stream, nothing, integer idhandle

EmitMemberDataCopy : BytecodeStream ref stream, StructureMemberVariable ref memvar, integer idhandle
{
	if(memvar.Name != 0)
	{
		BytecodePushVarValue(stream, memvar.Name, memvar.Type)
		BytecodeCopyToStructure(stream, idhandle, memvar.Name)
	}
}

EmitMemberDataCopy : BytecodeStream ref stream, StructureMemberFunctionRef ref member, integer idhandle
{
	if(member.Name != 0)
	{
		BytecodePushVarValue(stream, member.Name, 0x09000000)
		BytecodeCopyToStructure(stream, idhandle, member.Name)
	}
}


// Rearrange structure list to avoid dependency issues on load
CodeGenRearrangeStructures : list<StructureDefinition> ref thelist
{
	simplelist<integer> processed = 0, nothing
	boolean changed = CodeGenRearrangeStructuresRecurse(thelist, processed)

	if(changed)
	{
		CodeGenRearrangeStructures(thelist)
	}
}

CodeGenRearrangeStructuresRecurse : list<StructureDefinition> ref thelist, simplelist<integer> ref processed -> boolean changed = false
{
	if((thelist.value.Name != 0) && (!thelist.value.IsTemplate))
	{
		simplelist<integer> dependencies = 0, nothing
		ParseStructDependencies(thelist.value.Members, dependencies)

		if(MissingDependency(dependencies, processed))
		{
			SwapDown(thelist, thelist.next)
			changed = true
		}

		simpleprepend<integer>(processed, thelist.value.Type)
	}

	if(!changed)
	{
		CodeGenRearrangeStructuresRecurse(thelist.next, processed)
	}
}

CodeGenRearrangeStructuresRecurse : nothing, simplelist<integer> ref processed -> false


SwapDown : list<StructureDefinition> ref thelist, list<StructureDefinition> ref tail
{
	StructureDefinition temp = tail.value
	tail.value = thelist.value
	thelist.value = temp
}

SwapDown : list<StructureDefinition> ref thelist, nothing



OnCodeGenEnterEntity : integer entityname, integer postfixtag
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_PARAM, entityname
	prepend<ContextStackEntry>(ContextStack, entry)

	Entity entity = entityname, postfixtag, nothing, nothing
	prepend<Entity>(EntityStack, entity)

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

OnCodeGenEnterEntityCode :
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_CODE, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityStack.value.Param = ScratchExpressions.value

	OptionalCodeBlock block = nothing
	prepend<OptionalCodeBlock>(CurrentCodeBlockStack, block)
}

OnCodeGenEnterChain :
{
	ContextStackEntry entry = STACK_TYPE_CHAIN, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityChain newchain = dummychain
	prepend<EntityChain>(ChainStack, newchain)
}


OnCodeGenRegisterAlias : integer aliastype, integer aliasname, integer base
{
	TypeAlias newalias = aliastype, aliasname, base
	BinaryTreeCreateOrInsert<TypeAlias>(GlobalRootNamespace.TypeAliases, aliastype, newalias)
	BinaryTreeCreateOrInsert<integer>(NameToTypeMap, aliasname, aliastype)
	BinaryTreeCreateOrInsert<integer>(TypeToNameMap, aliastype, aliasname)
}

OnCodeGenRegisterWeakAlias : integer aliastype, integer aliasname, integer basename
{
	TypeAlias newalias = aliastype, aliasname, basename
	BinaryTreeCreateOrInsert<TypeAlias>(GlobalRootNamespace.TypeWeakAliases, aliastype, newalias)
	BinaryTreeCreateOrInsert<integer>(NameToTypeMap, aliasname, aliastype)
	BinaryTreeCreateOrInsert<integer>(TypeToNameMap, aliastype, aliasname)
}


OnCodeGenRegisterFunctionSig : integer sigtype, integer rettypename
{
	list<Parameter> d = dummyparam, nothing
	FunctionSignature sig = sigtype, d, rettypename, false
	prepend<FunctionSignature>(FunctionSignatures, sig)
}

OnCodeGenRegisterFunctionSigParam : integer paramtype, boolean isref
{
	// TODO - this is a really lame hack
	integer flag = 1
	if(isref)
	{
		flag = 2
	}
	
	Parameter param = flag, paramtype
	AppendParameter(FunctionSignatures.value.Parameters, param)
}

OnCodeGenRegisterFunctionSigParamList : simplelist<integer> ref paramtypenames, simplelist<boolean> ref paramrefflags
{
	OnCodeGenRegisterFunctionSigParamList(paramtypenames.next, paramrefflags.next)

	if(paramtypenames.value != 0)
	{
		OnCodeGenRegisterFunctionSigParam(paramtypenames.value, paramrefflags.value)
	}
}

OnCodeGenRegisterFunctionSigParamList : nothing, nothing


CodeGenEmitFunctionSignatures : BytecodeStream ref stream, list<FunctionSignature> ref thelist
{
	if(thelist.value.Name != 0)
	{
		integer rettype = GetTypeByName(thelist.value.ReturnTypeName)
		if(rettype == 0)
		{
			rettype = 0x00000002		// void
		}

		BytecodeEmitFunctionSignature(stream, thelist.value.Name, rettype, CountParameters(thelist.value.Parameters))
		CodeGenEmitFunctionSigParams(stream, thelist.value.Parameters)
	}
	CodeGenEmitFunctionSignatures(stream, thelist.next)
}

CodeGenEmitFunctionSignatures : BytecodeStream ref stream, nothing


CodeGenEmitFunctionSigParams : BytecodeStream ref stream, list<Parameter> ref params
{
	if(params.value.Type != 0)
	{
		integer t = params.value.Type
		if(params.value.Name == 2)		// VERY BAD HACK
		{
			t = MakeReferenceType(t)
		}
		BytecodeEmitFunctionSigParam(stream, t)
	}
	CodeGenEmitFunctionSigParams(stream, params.next)
}

CodeGenEmitFunctionSigParams : BytecodeStream ref stream, nothing


OnCodeGenRegisterParenthetical :
{
	ContextStackEntry entry = STACK_TYPE_PARENTHETICAL, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, d)
}


OnCodeGenPreparePreOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PreOpStatement preop = operator, operandlist, 0

	PreOpOnDeck = preop
}

OnCodeGenPreparePreOpCompoundOperand : integer operand
{
	AppendCompoundMemberHelper(PreOpOnDeck, operand)
}

OnCodeGenCompletePreOpStatement : boolean substatement
{
	if(substatement)
	{
		ExpressionOrPrePostOp wrap = PreOpOnDeck
		ParentheticalExpression parenthetical = wrap
		ExpressionAtom atom = parenthetical
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		CodeBlockEntry cbe = PreOpOnDeck
		AppendEntryToCurrentCodeBlock(cbe)
	}
}

OnCodeGenAddPreOpCompoundOperand : integer operand
{
	FindLastPreOpAndAppendCompoundMemberHelper(CurrentCodeBlockStack.value, operand)
}

OnCodeGenRegisterPostOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PostOpStatement postop = operator, operandlist, 0
	CodeBlockEntry cbe = postop
	AppendEntryToCurrentCodeBlock(cbe)
}



OnCodeGenShiftParameter :
{
	if(InFuncRetHack)
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
	}
	elseif(PeekContext(ContextStack, 1) != STACK_TYPE_SUBSTATEMENT)
	{
		FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
	}
	else
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
	}

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

PeekContext : list<ContextStackEntry> ref stack, integer depth -> integer peek = STACK_TYPE_GLOBAL
{
	if(depth == 0)
	{
		peek = stack.value.EntryType
	}
	else
	{
		peek = PeekContext(stack.next, depth - 1)
	}
}


CodeGenEmitGlobalBlockPrologue : BytecodeStream ref stream, CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		EmittingScope.Wrapped = GlobalScope.Wrapped

		BytecodeEnterEntity(stream, 4, GlobalCodeBlockName)
		CodeGenEmitCodeBlock(stream, block)
		BytecodeInvokeOffset(stream, FindHandleInTrie(GlobalStringPool.LookupTrie, "entrypoint"))
		BytecodeHalt(stream)
	}
}

CodeGenEmitGlobalBlockEpilogue : BytecodeStream ref stream, CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		BytecodeExitEntity(stream)
	}
}


EmitPatternMatchingForFunction : BytecodeStream ref stream, FunctionDefinition ref function
{
	ByteStreamEmitByte(stream.Buffer, stream.Offset, 0x12)			// PatternMatch instruction
	ByteStreamEmitInteger(stream.Buffer, stream.Offset, function.Name)
	ByteStreamEmitInteger(stream.Buffer, stream.Offset, 0)
	ByteStreamEmitInteger(stream.Buffer, stream.Offset, CountUnresolvedParameters(function.Params))
	EmitPatternMatchingForParameters(stream, function.Params)
}

EmitPatternMatchingForParameters : BytecodeStream ref stream, FunctionParams ref params
{
	EmitPatternMatchingForParameters(stream, params.Params)
}

EmitPatternMatchingForParameters : BytecodeStream ref stream, list<UnresolvedParameter> ref params
{
	integer parampatterntype = GetOptionalExpressionType(params.value.PatternMatchValue)
	ByteStreamEmitInteger(stream.Buffer, stream.Offset, MakeNonReferenceType(parampatterntype))

	if(parampatterntype != 0)
	{
		ByteStreamEmitBoolean(stream.Buffer, stream.Offset, true)
		EmitPatternMatchLiteral(stream, params.value.PatternMatchValue)
	}
	else
	{
		ByteStreamEmitBoolean(stream.Buffer, stream.Offset, false)
	}

	EmitPatternMatchingForParameters(stream, params.next)
}

EmitPatternMatchingForParameters : BytecodeStream ref stream, nothing


EmitPatternMatchLiteral : BytecodeStream ref stream, Expression ref expr
{
	EmitPatternMatchLiteralAtom(stream, expr.Atoms.value)
}

EmitPatternMatchLiteralAtom : BytecodeStream ref stream, integer value
{
	ByteStreamEmitInteger(stream.Buffer, stream.Offset, value)
}


FindScopeAndSetContext : FunctionDefinition ref func [nogc]
{
	EmittingScope.Wrapped = func.AttachedScope.Wrapped
}
