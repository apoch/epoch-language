

OnCodeGenRegisterStructureMemVar : integer structurename, integer structuretype, integer membername, integer typenamehandle, boolean isref, boolean templated [nogc]
{
	integer refnum = 0
	if(isref)
	{
		refnum = 0x80000000
	}

	StructureMemberVariable member = membername, refnum, typenamehandle, nothing
	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		member.TemplateArgs = ScratchTemplateArgumentStack.value

		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}

	StructureMember memwrap = member
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSig : integer structurename, integer structuretype, integer name, integer rettypename [nogc]
{
	list<Parameter> p = dummyparam, nothing
	FunctionSignature signature = name, p, rettypename, false
	StructureMemberFunctionRef m = name, signature
	StructureMember memwrap = m
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSigParam : integer structurename, integer structuretype, integer membername, integer paramtype
{
	Parameter param = 1, paramtype
	FindStructureAndAddMemberParam(Structures, structurename, structuretype, membername, param)
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, simplelist<integer> ref typenames
{
	OnCodeGenRegisterStructureMemFuncSigParamList(structurename, structuretype, membername, typenames.next)

	if(typenames.value != 0)
	{
		OnCodeGenRegisterStructureMemFuncSigParam(structurename, structuretype, membername, typenames.value)
	}
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, nothing





OnCodeGenRegisterConstructors : integer structurename, integer constructorname, integer anonname, integer copyname [nogc]
{
	FindStructureAndSetConstructors(structurename, constructorname, anonname, copyname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, constructorname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, anonname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, copyname)
}

OnCodeGenRegisterScope : integer scopename, integer parentname, boolean attachtofunction
{
	list<Variable> v = dummyvar, nothing
	Scope scope = scopename, parentname, v, 0, 0
	
	BinaryTreeCreateOrInsert<Scope>(GlobalRootNamespace.Scopes, scopename, scope)
	
	if(attachtofunction)
	{
		Functions.value.AttachedScope.Wrapped = scope
	}
}


OnCodeGenRegisterGlobalBlock : integer name
{
	ContextStackEntry entry = STACK_TYPE_GLOBAL, name
	prepend<ContextStackEntry>(ContextStack, entry)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	GlobalCodeBlockName = name
	
	
	CacheGlobalCodeBlock()
}


OnCodeGenRegisterFunction : integer funcname, integer rawfuncname, string rawfuncnamestr, boolean istemplate
{
	ContextWrapper<Scope> scopewrap = nothing
	FunctionDefinition func = rawfuncname, funcname, nothing, nothing, nothing, dummyoverloadlist, scopewrap, rawfuncnamestr, 0, false, istemplate, false
	prepend<FunctionDefinition>(Functions, func)
	BinaryTreeCreateOrInsert<FunctionDefinition>(GlobalRootNamespace.Functions, funcname, func)

	// TODO - this is a weird bug. For some reason we don't init the field correctly in the above constructor
	if(istemplate)
	{
		func.IsTemplate = true
	}

	if(funcname != rawfuncname)
	{	
		ContextNode<FunctionDefinition> wrap = nothing
		if(SearchBinaryTreeForPayload<FunctionDefinition>(GlobalRootNamespace.Functions.RootNode, rawfuncname, wrap))
		{
			AttachContextToFunction(wrap, funcname, func)
		}
	}
	
	Overload selfoverload = rawfuncname, funcname, func
	prepend<Overload>(func.Overloads, selfoverload)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	if(istemplate)
	{
		CreateFunctionTemplateAndAttachParams(funcname, TemplateParameterQueue)

		// Reset template parameter queue
		list<TemplateParameter> dummylist = scratchtemplateparam, nothing
		TemplateParameterQueue = dummylist
	}
}


OnCodeGenEnterFunctionBody : integer funcname
{
	ContextStackEntry entry = STACK_TYPE_FUNCTION, funcname
	prepend<ContextStackEntry>(ContextStack, entry)
}

OnCodeGenEnterFunctionReturn : integer funcname, boolean anonymous
{
	ContextStackEntry entry = STACK_TYPE_FUNCRET, funcname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d

	Functions.value.AnonymousReturn = anonymous
	InFuncRetHack = true
}

OnCodeGenExitContext :
{
	integer entrytype = ContextStack.value.EntryType
	pop<ContextStackEntry>(ContextStack, ContextStack.next)

	if(entrytype == STACK_TYPE_STATEMENT)
	{
		if(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
		{
			AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
		}
		elseif(ContextStack.value.EntryType != STACK_TYPE_SUBSTATEMENT)
		{
			FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
		}
	}
	elseif(entrytype == STACK_TYPE_ASSIGNMENT)
	{
		FindCurrentAssignmentAndSetExpression(ScratchExpressions.value)
	}
	elseif(entrytype == STACK_TYPE_SUBSTATEMENT)
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
		PopCurrentStatementAndAppendToScratchExpression(ScratchExpressions, ScratchExpressions.next)
	}
	elseif(entrytype == STACK_TYPE_FUNCRET)
	{
		SetReturnExpression(Functions.value, ScratchExpressions.value)
		InFuncRetHack = false
	}
	elseif(entrytype == STACK_TYPE_FUNCTION)
	{
		assertmsg(CodeBlockDepth(CurrentCodeBlockStack) == 1, "Code block depth is invalid")
		SetFunctionCodeBlock(Functions.value, CurrentCodeBlockStack.value)
	}
	elseif(entrytype == STACK_TYPE_ENTITY_CODE)
	{
		Entity entity = EntityStack.value.Tag, EntityStack.value.PostfixTag, EntityStack.value.Param, CurrentCodeBlockStack.value
		AppendEntityToChain(ChainStack, entity)
		pop<Entity>(EntityStack, EntityStack.next)
		PopCodeBlock(CurrentCodeBlockStack, CurrentCodeBlockStack.next)
	}
	elseif(entrytype == STACK_TYPE_CHAIN)
	{
		CodeBlockEntry cbe = ChainStack.value
		AppendEntryToCurrentCodeBlock(cbe)
		pop<EntityChain>(ChainStack, ChainStack.next)
	}
	elseif(entrytype == STACK_TYPE_PARENTHETICAL)
	{
		ExpressionOrPrePostOp epp = ScratchExpressions.value
		ParentheticalExpression parenthetical = epp
		ExpressionAtom atom = parenthetical
		pop<Expression>(ScratchExpressions, ScratchExpressions.next)
		PlaceAtomInScratchExpression(atom)
	}
	elseif(entrytype == STACK_TYPE_GLOBAL)
	{
		SetGlobalCodeBlock(CurrentCodeBlockStack.value)
	}
}


OnCodeGenEnterTypeMatcher : integer matchername
{
	ContextStackEntry entry = STACK_TYPE_TYPEMATCH, matchername
	prepend<ContextStackEntry>(ContextStack, entry)

	list<FunctionSignature> dsl = dummysignature, nothing
	TypeMatcher matcher = matchername, dsl
	prepend<TypeMatcher>(TypeMatchers, matcher)
}


OnCodeGenRegisterLiteralBoolean : boolean value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralInteger : integer value, integer literaltype
{
	while((literaltype & 0x7f000000) == 0x05000000)
	{
		literaltype = FindTypeAliasBase(literaltype)
	}

	if(literaltype == 0x01000001)		// Integer32 type signature
	{
		ExpressionAtom atom = value
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		integer16 i16value = cast(integer16, value)
		ExpressionAtom atom = i16value
		PlaceAtomInScratchExpression(atom)
	}
}

OnCodeGenRegisterLiteralString : integer handle
{
	StringHandleAtom sha = handle
	ExpressionAtom atom = sha
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralReal : real value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterOperatorInvoke : integer ophandle
{
	OperatorInvokeAtom oia = ophandle
	ExpressionAtom atom = oia
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifier : integer idhandle, integer idtype
{
	IdentifierAtom id = idhandle, idtype, false, false
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}


OnCodeGenRegisterRefBinding : integer id, integer structureid, boolean isref, boolean inputref
{
	RefBinding binding = id, structureid, isref, inputref
	ExpressionAtom atom = binding
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenEnterStatement : integer statementname, integer statementtype, boolean toplevel, boolean hastemplateargs
{
	Statement statement = statementname, nothing, statementtype, nothing, toplevel, false

	if(hastemplateargs)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		statement.TemplateArgs = ScratchTemplateArgumentStack.value

		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}

	OnCodeGenEmplaceStatement(statement)
}

OnCodeGenEmplaceStatement : Statement ref statement
{
	if(ContextStack.value.EntryType == STACK_TYPE_SUBSTATEMENT)
	{
		prepend<Statement>(SubStatements, statement)
	}
	elseif(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
	{
		prepend<Statement>(SubStatements, statement)
	}
	else
	{
		CodeBlockEntry cbe = statement
		AppendEntryToCurrentCodeBlock(cbe)
		LastTopLevelStatementHack.Wrapped = statement
	}

	ContextStackEntry entry = STACK_TYPE_STATEMENT, statement.Name
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, expr)
}


OnCodeGenEnterMessageSend : integer targetname, integer messagename
{
	MessageSend msg = targetname, messagename, nothing, 0, nothing, false
	
	CodeBlockEntry cbe = msg
	AppendEntryToCurrentCodeBlock(cbe)
	
	ContextStackEntry entry = STACK_TYPE_MESSAGE, msg.MessageName
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, expr)
}


OnCodeGenEnterTask : integer taskname
{
	ContextStackEntry entry = STACK_TYPE_TASK, taskname
	prepend<ContextStackEntry>(ContextStack, entry)
}


OnCodeGenEnterAssignment : integer operator, integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	Assignment assignment = operator, lhsname, lhstype, annotation, rhs
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)

	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, lhsname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression blank = dummyatomlist, 0
	ScratchExpressions.value = blank
}


OnCodeGenChainAssignment : integer operator, integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	Assignment assignment = operator, lhsname, lhstype, annotation, rhs
	AppendEntryToCurrentAssignmentChain(assignment)
}


OnCodeGenEnterAssignmentCompound : integer operator, integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	AssignmentCompound assignment = operator, idlist, lhstype, annotation, rhs
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)
}

OnCodeGenAssignmentCompoundEnd :
{
	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression blank = dummyatomlist, 0
	ScratchExpressions.value = blank
}



OnCodeGenChainAssignmentCompound : integer operator, integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	AssignmentCompound assignment = operator, idlist, lhstype, annotation, rhs
	AppendEntryToCurrentAssignmentChain(assignment)
}

OnCodeGenEnterSubStatement :
{
	ContextStackEntry entry = STACK_TYPE_SUBSTATEMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)
}




OnCodeGenRegisterFunctionTag : integer funcname, string tagname, integer rawfuncname
{
	list<string> dtp = "", nothing
	FunctionTag tag = funcname, tagname, dtp
	ListPrependOrCreate<FunctionTag>(GlobalRootNamespace.FunctionTags, tag)

	if(tagname == "constructor")
	{	
		simpleprepend<integer>(CustomConstructors, funcname)

		integer baseconstructorname = PoolString(GetPooledString(rawfuncname) ; "@@constructor")

		Overload overload = baseconstructorname, funcname, nothing
		prepend<Overload>(AutoGenOverloads, overload)
		FindFunctionAndAddOverload(overload)
		
		
		ContextNode<FunctionDefinition> wrap = nothing
		boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(GlobalRootNamespace.Functions.RootNode, funcname, wrap)
		assertmsg(found, "Missing function implementation")
		
		overload.Implementation = wrap

	
		PrependFunctionParameter(Functions, funcname, PoolString("@id"), 0x81000000)
	}
}

OnCodeGenRegisterFunctionTagParam : integer funcname, string tagname, string param
{
	// TODO - less lazy implementation (find function and tag)
	AppendFunctionTagParamUnwrap(GlobalRootNamespace.FunctionTags, param)
}

AppendFunctionTagParamUnwrap : list<FunctionTag> ref tags, string param
{
	AppendFunctionTagParam(tags.value.Parameters, tags.value.Parameters.next, param)
}

AppendFunctionTagParamUnwrap : nothing, string param
{
	assertmsg(false, "Function tag parameter registered but no function tags have been set up!")
}



// Rearrange structure list to avoid dependency issues on load
CodeGenRearrangeStructures : list<StructureDefinition> ref thelist
{
	simplelist<integer> processed = 0, nothing
	CodeGenRearrangeStructuresRecurse(DependencyStructures, thelist, processed)

	Structures = DependencyStructures
}

CodeGenRearrangeStructuresRecurse : list<StructureDefinition> ref rearranged, list<StructureDefinition> ref thelist, simplelist<integer> ref processed
{
	if((thelist.value.Name != 0) && (!thelist.value.IsTemplate))
	{
		CodeGenRearrangeStructuresVisit(DependencyStructures, thelist.value, processed)
	}

	CodeGenRearrangeStructuresRecurse(DependencyStructures, thelist.next, processed)
}

CodeGenRearrangeStructuresRecurse : list<StructureDefinition> ref rearranged, nothing, simplelist<integer> ref processed


CodeGenRearrangeStructuresVisit : list<StructureDefinition> ref rearranged, StructureDefinition ref s, simplelist<integer> ref processed
{
	if(!listcontains(processed, s.Type))
	{
		simplelist<integer> dependencies = 0, nothing
		ParseStructDependencies(s, dependencies)

		VisitDependencies(DependencyStructures, dependencies, processed)

		simpleprepend<integer>(processed, s.Type)
		prepend<StructureDefinition>(DependencyStructures, s)
	}
}


VisitDependencies : list<StructureDefinition> ref rearranged, simplelist<integer> ref dependencies, simplelist<integer> ref processed
{
	if(dependencies.value != 0)
	{
		integer name = GetNameOfStructureByType(dependencies.value)
		if(name != 0)			// hack
		{
			ContextNode<StructureDefinition> wrap = nothing
			boolean found = SearchBinaryTreeForPayload<StructureDefinition>(GlobalRootNamespace.Structures.RootNode, name, wrap)

			assertmsg(found, "Missing definition for structure type " ; GetPooledString(name))

			CodeGenRearrangeStructuresVisit(DependencyStructures, wrap, processed)
		}
	}

	VisitDependencies(DependencyStructures, dependencies.next, processed)
}

VisitDependencies : list<StructureDefinition> ref rearranged, nothing, simplelist<integer> ref processed



OnCodeGenEnterEntity : integer entityname, integer postfixtag
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_PARAM, entityname
	prepend<ContextStackEntry>(ContextStack, entry)

	Entity entity = entityname, postfixtag, nothing, nothing
	prepend<Entity>(EntityStack, entity)

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

OnCodeGenEnterEntityCode :
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_CODE, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityStack.value.Param = ScratchExpressions.value

	OptionalCodeBlock block = nothing
	prepend<OptionalCodeBlock>(CurrentCodeBlockStack, block)
}

OnCodeGenEnterChain :
{
	ContextStackEntry entry = STACK_TYPE_CHAIN, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityChain newchain = dummychain
	prepend<EntityChain>(ChainStack, newchain)
}


OnCodeGenRegisterAlias : integer aliastype, integer aliasname, integer base
{
	TypeAlias newalias = aliastype, aliasname, base
	BinaryTreeCreateOrInsert<TypeAlias>(GlobalRootNamespace.TypeAliases, aliastype, newalias)
	BinaryTreeCreateOrInsert<integer>(NameToTypeMap, aliasname, aliastype)
	BinaryTreeCreateOrInsert<integer>(TypeToNameMap, aliastype, aliasname)
}

OnCodeGenRegisterWeakAlias : integer aliastype, integer aliasname, integer basename
{
	TypeAlias newalias = aliastype, aliasname, basename
	BinaryTreeCreateOrInsert<TypeAlias>(GlobalRootNamespace.TypeWeakAliases, aliastype, newalias)
	BinaryTreeCreateOrInsert<integer>(NameToTypeMap, aliasname, aliastype)
	BinaryTreeCreateOrInsert<integer>(TypeToNameMap, aliastype, aliasname)
}


OnCodeGenRegisterFunctionSig : integer sigtype, integer rettypename
{
	list<Parameter> d = dummyparam, nothing
	FunctionSignature sig = sigtype, d, rettypename, false
	prepend<FunctionSignature>(FunctionSignatures, sig)
}

OnCodeGenRegisterFunctionSigParam : integer paramtype, boolean isref
{
	// TODO - this is a really lame hack
	integer flag = 1
	if(isref)
	{
		flag = 2
	}
	
	Parameter param = flag, paramtype
	AppendParameter(FunctionSignatures.value.Parameters, param)
}

OnCodeGenRegisterFunctionSigParamList : simplelist<integer> ref paramtypenames, simplelist<boolean> ref paramrefflags
{
	OnCodeGenRegisterFunctionSigParamList(paramtypenames.next, paramrefflags.next)

	if(paramtypenames.value != 0)
	{
		OnCodeGenRegisterFunctionSigParam(paramtypenames.value, paramrefflags.value)
	}
}

OnCodeGenRegisterFunctionSigParamList : nothing, nothing



OnCodeGenRegisterParenthetical :
{
	ContextStackEntry entry = STACK_TYPE_PARENTHETICAL, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, d)
}


OnCodeGenPreparePreOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PreOpStatement preop = operator, operandlist, 0

	PreOpOnDeck = preop
}

OnCodeGenPreparePreOpCompoundOperand : integer operand
{
	AppendCompoundMemberHelper(PreOpOnDeck, operand)
}

OnCodeGenCompletePreOpStatement : boolean substatement
{
	if(substatement)
	{
		ExpressionOrPrePostOp wrap = PreOpOnDeck
		ParentheticalExpression parenthetical = wrap
		ExpressionAtom atom = parenthetical
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		CodeBlockEntry cbe = PreOpOnDeck
		AppendEntryToCurrentCodeBlock(cbe)
	}
}

OnCodeGenAddPreOpCompoundOperand : integer operand
{
	FindLastPreOpAndAppendCompoundMemberHelper(CurrentCodeBlockStack.value, operand)
}

OnCodeGenRegisterPostOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PostOpStatement postop = operator, operandlist, 0
	CodeBlockEntry cbe = postop
	AppendEntryToCurrentCodeBlock(cbe)
}



OnCodeGenShiftParameter :
{
	if(InFuncRetHack)
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
	}
	elseif(PeekContext(ContextStack, 1) != STACK_TYPE_SUBSTATEMENT)
	{
		FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
	}
	else
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
	}

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

PeekContext : list<ContextStackEntry> ref stack, integer depth -> integer peek = STACK_TYPE_GLOBAL
{
	if(depth == 0)
	{
		peek = stack.value.EntryType
	}
	else
	{
		peek = PeekContext(stack.next, depth - 1)
	}
}


FindScopeAndSetContext : FunctionDefinition ref func [nogc]
{
	EmittingScope.Wrapped = func.AttachedScope.Wrapped
}
