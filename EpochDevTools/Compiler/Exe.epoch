//
// The Epoch Language Project
// Epoch Development Tools - Compiler Core
//
// EXE.EPOCH
// Executable binary generation routines
//
// This module is responsible for outputting executable
// 32-bit Windows binaries in the PE format. The binary
// itself is a stub that launches the Epoch runtime and
// passes in a stream of bytecode embedded in the file.
//
// In general code in this file is pretty hacky and not
// especially clear. It could use some major cleanup.
//


type LLVMContextHandle : integer
type LLVMFunctionRef : integer
type LLVMFunctionType : integer
type LLVMType : integer
type LLVMBasicBlock : integer
type LLVMGlobalVar : integer

EpochLLVMInitialize : 																								[external("EpochLLVM.dll", "EpochLLVMInitialize")]

EpochLLVMContextCreate : -> LLVMContextHandle ret = 0 																[external("EpochLLVM.dll", "EpochLLVMContextCreate")]
EpochLLVMContextDestroy : LLVMContextHandle handle																	[external("EpochLLVM.dll", "EpochLLVMContextDestroy")]

EpochLLVMFunctionTypeCreate : LLVMContextHandle context, LLVMType rettype -> LLVMFunctionType ret = 0				[external("EpochLLVM.dll", "EpochLLVMFunctionTypeCreate")]

EpochLLVMFunctionCreate :
	LLVMContextHandle handle,
	string funcname,
	LLVMFunctionType functype
  ->
	LLVMFunctionRef ret = 0
  [external("EpochLLVM.dll", "EpochLLVMFunctionCreate")]

EpochLLVMFunctionCreateThunk : LLVMContextHandle context, string name, LLVMFunctionType ty -> integer v = 0			[external("EpochLLVM.dll", "EpochLLVMFunctionCreateThunk")]

EpochLLVMFunctionQueueParamType : LLVMContextHandle context, LLVMType t												[external("EpochLLVM.dll", "EpochLLVMFunctionQueueParamType")]

EpochLLVMFunctionSetEntry : LLVMContextHandle context, LLVMFunctionRef func											[external("EpochLLVM.dll", "EpochLLVMFunctionSetEntry")]

EpochLLVMTypeGetBoolean : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetBoolean")]
EpochLLVMTypeGetString : LLVMContextHandle context -> LLVMType t = 0												[external("EpochLLVM.dll", "EpochLLVMTypeGetString")]
EpochLLVMTypeGetVoid : LLVMContextHandle context -> LLVMType t = 0													[external("EpochLLVM.dll", "EpochLLVMTypeGetVoid")]

EpochLLVMEmitBinaryObject : LLVMContextHandle handle, buffer ref outbuffer, integer maxsize -> integer written = 0 	[external("EpochLLVM.dll", "EpochLLVMEmitBinaryObject")]

EpochLLVMSetThunkCallback : LLVMContextHandle handle, (func : string -> integer)                                    [external("EpochLLVM.dll", "EpochLLVMSetThunkCallback")]
EpochLLVMSetStringCallback : LLVMContextHandle handle, (func : integer -> integer)									[external("EpochLLVM.dll", "EpochLLVMSetStringCallback")]


EpochLLVMCodeCreateBasicBlock : LLVMContextHandle handle, LLVMFunctionRef func -> LLVMBasicBlock ret = 0			[external("EpochLLVM.dll", "EpochLLVMCodeCreateBasicBlock")]
EpochLLVMCodeCreateCall : LLVMContextHandle handle, LLVMFunctionRef target -> integer ret = 0						[external("EpochLLVM.dll", "EpochLLVMCodeCreateCall")]
EpochLLVMCodeCreateCallThunk : LLVMContextHandle handle, integer target -> integer ret = 0							[external("EpochLLVM.dll", "EpochLLVMCodeCreateCallThunk")]
EpochLLVMCodeCreateRetVoid : LLVMContextHandle handle																[external("EpochLLVM.dll", "EpochLLVMCodeCreateRetVoid")]

EpochLLVMCodePushString : LLVMContextHandle context, integer handle													[external("EpochLLVM.dll", "EpochLLVMCodePushString")]
EpochLLVMCodePushBoolean : LLVMContextHandle context, boolean literal												[external("EpochLLVM.dll", "EpochLLVMCodePushBoolean")]


RoundUp : integer in -> integer out = ((in / 0x1000) + 1) * 0x1000			// TODO - this over-estimates if in is a perfect multiple of 0x1000
RoundUpFile : integer in -> integer out = ((in / 0x200) + 1) * 0x200		// TODO - this over-estimates if in is a perfect multiple of 0x200



structure ThunkTableEntry :
	string FunctionName,
	integer ThunkTableOffset,
	integer ThunkAddressOffset,
	integer ThunkAddressCopyOffset

structure ThunkTableLibrary :
	string LibraryName,
	listnode<ThunkTableEntry> Functions,
	integer StartOffset,
	integer NameOffset

structure ThunkTable :
	listnode<ThunkTableLibrary> Libraries,
	integer DescriptorOffset,
	integer TotalSize
	



MakeExe : EpochProject ref project
{
	IconDirectoryEntry dummydetails = 0, 0, 0, 0, 0
	IconReference dummyicon = "", 0, 0, 0, 0, dummydetails
	list<IconReference> dummyiconlist = dummyicon, nothing
	
	ManifestReference dummymanifest = "", 0
	list<ManifestReference> dummymanifestlist = dummymanifest, nothing

	list<MenuEntry> nomenuentries = MenuSentinel(0), nothing
	MenuResource emptymenu = 0, nomenuentries
	list<MenuResource> nomenus = emptymenu, nothing
	
	AcceleratorEntry nonaccel = 0, 0, 0
	list<AcceleratorEntry> accellist = nonaccel, nothing
	AcceleratorResource noaccel = 0, accellist
	list<AcceleratorResource> noaccels = noaccel, nothing

	ResourceDirectoryHeader resroot = 0, 0, 0, 0, nothing
	ResourceHandler res = resroot, 0, 0, dummyiconlist, dummymanifestlist, 0, nomenus, noaccels
	
	LoadResourceScripts(project.ResourceFiles, res)
	ComputeResourceOffsets(res)
	

	integer virtualoffsetthunk   = 0x1000
	integer offsetthunk          = 0x400
	integer sizethunk            = ThunkTableGetCompleteSize(GlobalThunkTable)
	
	integer virtualoffsetrsrc    = RoundUp(virtualoffsetthunk + sizethunk)
	integer offsetrsrc           = RoundUpFile(offsetthunk + sizethunk)
	integer sizersrc             = res.DirectorySize + res.DataSize + 1
	
	integer virtualoffsetstrings = RoundUp(virtualoffsetrsrc + sizersrc)
	integer offsetstrings        = RoundUpFile(offsetrsrc + sizersrc)
	integer sizestrings          = PreprocessStringPool(GlobalStringPool, GlobalStringOffsets)
	
	buffer codebinarybuffer = 0x100
	EpochLLVMInitialize()
	LLVMContextHandle llvm = EpochLLVMContextCreate()
	EpochLLVMSetThunkCallback(llvm, ThunkLookupMapper)
	EpochLLVMSetStringCallback(llvm, StringLookupMapper)
	
	SetUpBuiltInLLVMThunks(llvm)
	
	SetUpAllLLVMCode(llvm)
	
	integer sizecode = EpochLLVMEmitBinaryObject(llvm, codebinarybuffer, 0x100)
	EpochLLVMContextDestroy(llvm)
	
	integer virtualoffsetcode    = RoundUp(virtualoffsetstrings + sizestrings)
	integer offsetcode           = RoundUpFile(offsetstrings + sizestrings)

	integer sizeimage            = RoundUp(virtualoffsetcode + sizecode)


	integer GENERIC_WRITE = 0x40000000
	integer CREATE_ALWAYS = 2

	Win32Handle filehandle = CreateFile(project.OutputFileName, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0)
	if(filehandle == -1)
	{
		print("Cannot open " ; project.OutputFileName ; " to emit .EXE!")
		return()
	}

	integer16 subsystem = 2		// GUI
	if(project.UsesConsole)
	{
		subsystem = 3			// console
	}

	integer position = 0
	position += WritePEHeader(filehandle, sizeimage, sizersrc, subsystem, sizecode)

	position += WriteSectionHeader(filehandle, ".idata", offsetthunk, virtualoffsetthunk, sizethunk, sizethunk, 0xc0000040)
	position += WriteSectionHeader(filehandle, ".rsrc", offsetrsrc, virtualoffsetrsrc, sizersrc, sizersrc, 0x40000040)
	position += WriteSectionHeader(filehandle, ".data", offsetstrings, virtualoffsetstrings, sizestrings, sizestrings, 0x40000040)
	position += WriteSectionHeader(filehandle, ".text", offsetcode, virtualoffsetcode, sizecode, sizecode, 0x60000020)

	print("Writing thunk table...")
	position += WritePadding(filehandle, position, offsetthunk)
	position += WriteThunkTable(filehandle, virtualoffsetthunk)

	print("Writing resources...")
	position += WritePadding(filehandle, position, offsetrsrc)
	position += WriteResources(filehandle, res)

	print("Writing static data...")
	position += WritePadding(filehandle, position, offsetstrings)
	position += WriteStringTable(filehandle, sizestrings, GlobalStringOffsets)


	print("Writing code...")
	
	position += WritePadding(filehandle, position, offsetcode)

	integer written = 0
	WriteFile(filehandle, codebinarybuffer, sizecode, written, 0)

	CloseHandle(filehandle)

	print("Compilation complete.")
}

WriteStringTable : Win32Handle filehandle, integer finalsize, BinaryTreeRoot<integer> ref offsets -> integer writtenbytes = 0
{
	buffer tablebuffer = finalsize + 1

	StringPoolOutputState state = offsets, tablebuffer
	BinaryTreeWalkAllNodesWithParam<string, StringPoolOutputState>(GlobalStringPool.LookupMap.RootNode, CopySingleStringToBuffer, state)

	integer written = 0
	WriteFile(filehandle, state.OutputBuffer, finalsize, written, 0)

	writtenbytes = finalsize
}

WriteThunkTable : Win32Handle filehandle, integer virtualoffsetthunk -> integer writtenbytes = 0
{
	writtenbytes = ThunkTableEmit(filehandle, GlobalThunkTable, virtualoffsetthunk)
}


WritePadding : Win32Handle filehandle, integer startpos, integer desiredpos -> integer writtenbytes = 0
{
	writtenbytes = desiredpos - startpos
	buffer empty = writtenbytes
	integer written = 0
	WriteFile(filehandle, empty, writtenbytes, written, 0)
}


WriteSectionHeader : Win32Handle filehandle, string sectionname, integer location, integer virtuallocation, integer sectionsize, integer sectionvirtualsize, integer flags -> integer writtenbytes = 0
{
	print("Writing header for section '" ; sectionname ; "'...")

	buffer headerbuffer = 256
	integer headersize = 0

	// This is a pitiful hack.

	integer count = 0
	assert(length(sectionname) < 8)

	while(count < length(sectionname))
	{
		string char = charat(sectionname, count)
		ByteStreamEmitSubstring(headerbuffer, headersize, char, 1)

		++count
	}

	while(count < 8)
	{
		ByteStreamEmitByte(headerbuffer, headersize, 0)
		++count
	}

	// End hack.

	ByteStreamEmitInteger(headerbuffer, headersize, sectionsize)
	ByteStreamEmitInteger(headerbuffer, headersize, virtuallocation)
	ByteStreamEmitInteger(headerbuffer, headersize, sectionvirtualsize)
	ByteStreamEmitInteger(headerbuffer, headersize, location)
	ByteStreamEmitInteger(headerbuffer, headersize, 0)
	ByteStreamEmitInteger(headerbuffer, headersize, 0)
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)
	ByteStreamEmitInteger(headerbuffer, headersize, flags)

	integer written = 0
	WriteFile(filehandle, headerbuffer, headersize, written, 0)

	writtenbytes = headersize
}


WritePEHeader : Win32Handle filehandle, integer imagesize, integer resourcesize, integer16 subsystem, integer sizecode -> integer writtenbytes = 0
{
	print("Writing PE headers...")

	buffer headerbuffer = 1024
	integer headersize = 0

	// Begin DOS header
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x5a4d)	// e_magic
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x90)		// e_cblp
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x03)		// e_cp
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_crlc
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x04)		// e_cparhdr
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_minalloc
	ByteStreamEmitInteger16(headerbuffer, headersize, 0xffff)	// e_maxalloc
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_ss
	ByteStreamEmitInteger16(headerbuffer, headersize, 0xb8)		// e_sp
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_csum
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_ip
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_cs
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x40)		// e_lfarlc
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_ovno

	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res[0]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res[1]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res[2]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res[3]

	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_oemid
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_oeminfo

	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[0]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[1]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[2]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[3]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[4]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[5]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[6]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[7]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[8]
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)		// e_res2[9]

	ByteStreamEmitInteger(headerbuffer, headersize, 0xb0)		// e_lfanew


	// Begin DOS stub
	ByteStreamEmitByte(headerbuffer, headersize, 0x0e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x1f)
	ByteStreamEmitByte(headerbuffer, headersize, 0xba)
	ByteStreamEmitByte(headerbuffer, headersize, 0x0e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x00)
	ByteStreamEmitByte(headerbuffer, headersize, 0xb4)
	ByteStreamEmitByte(headerbuffer, headersize, 0x09)
	ByteStreamEmitByte(headerbuffer, headersize, 0xcd)
	ByteStreamEmitByte(headerbuffer, headersize, 0x21)
	ByteStreamEmitByte(headerbuffer, headersize, 0xb8)
	ByteStreamEmitByte(headerbuffer, headersize, 0x01)
	ByteStreamEmitByte(headerbuffer, headersize, 0x4c)
	ByteStreamEmitByte(headerbuffer, headersize, 0xcd)
	ByteStreamEmitByte(headerbuffer, headersize, 0x21)

	ByteStreamEmitByte(headerbuffer, headersize, 0x54)
	ByteStreamEmitByte(headerbuffer, headersize, 0x68)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x73)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x70)
	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6f)
	ByteStreamEmitByte(headerbuffer, headersize, 0x67)
	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x61)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6d)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)

	ByteStreamEmitByte(headerbuffer, headersize, 0x73)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x66)
	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6f)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6d)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x74)
	ByteStreamEmitByte(headerbuffer, headersize, 0x68)
	ByteStreamEmitByte(headerbuffer, headersize, 0x65)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x66)
	ByteStreamEmitByte(headerbuffer, headersize, 0x75)
	ByteStreamEmitByte(headerbuffer, headersize, 0x74)

	ByteStreamEmitByte(headerbuffer, headersize, 0x75)
	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x65)
	ByteStreamEmitByte(headerbuffer, headersize, 0x2e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x0d)
	ByteStreamEmitByte(headerbuffer, headersize, 0x0a)
	ByteStreamEmitByte(headerbuffer, headersize, 0x49)
	ByteStreamEmitByte(headerbuffer, headersize, 0x74)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x77)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6c)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6c)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)

	ByteStreamEmitByte(headerbuffer, headersize, 0x6e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6f)
	ByteStreamEmitByte(headerbuffer, headersize, 0x74)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x75)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6f)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x79)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6f)
	ByteStreamEmitByte(headerbuffer, headersize, 0x75)

	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x70)
	ByteStreamEmitByte(headerbuffer, headersize, 0x72)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6d)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x74)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x76)
	ByteStreamEmitByte(headerbuffer, headersize, 0x65)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x63)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6f)

	ByteStreamEmitByte(headerbuffer, headersize, 0x6d)
	ByteStreamEmitByte(headerbuffer, headersize, 0x70)
	ByteStreamEmitByte(headerbuffer, headersize, 0x75)
	ByteStreamEmitByte(headerbuffer, headersize, 0x74)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x6e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x67)
	ByteStreamEmitByte(headerbuffer, headersize, 0x20)
	ByteStreamEmitByte(headerbuffer, headersize, 0x64)
	ByteStreamEmitByte(headerbuffer, headersize, 0x65)
	ByteStreamEmitByte(headerbuffer, headersize, 0x76)
	ByteStreamEmitByte(headerbuffer, headersize, 0x69)
	ByteStreamEmitByte(headerbuffer, headersize, 0x63)
	ByteStreamEmitByte(headerbuffer, headersize, 0x65)

	ByteStreamEmitByte(headerbuffer, headersize, 0x2e)
	ByteStreamEmitByte(headerbuffer, headersize, 0x0d)
	ByteStreamEmitByte(headerbuffer, headersize, 0x0a)
	ByteStreamEmitByte(headerbuffer, headersize, 0x24)

	ByteStreamEmitPadding(headerbuffer, headersize, 0xb0)


	// Begin NT headers
	ByteStreamEmitInteger(headerbuffer, headersize, 0x00004550)
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x014c)						// Machine
	ByteStreamEmitInteger16(headerbuffer, headersize, 4)							// NumberOfSections
	ByteStreamEmitInteger(headerbuffer, headersize, 0x00000000)						// TimeDateStamp
	ByteStreamEmitInteger(headerbuffer, headersize, 0)								// PointerToSymbolTable
	ByteStreamEmitInteger(headerbuffer, headersize, 0)								// NumberOfSymbols
	ByteStreamEmitInteger16(headerbuffer, headersize, 0xe0)							// SizeOfOptionalHeader
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x0103)						// Characteristics

	ByteStreamEmitInteger16(headerbuffer, headersize, 0x010b)						// Magic
	ByteStreamEmitByte(headerbuffer, headersize, 0x02)								// MajorLinkerVersion
	ByteStreamEmitByte(headerbuffer, headersize, 0x00)								// MinorLinkerVersion

	ByteStreamEmitInteger(headerbuffer, headersize, RoundUp(sizecode))				// SizeOfCode
	ByteStreamEmitInteger(headerbuffer, headersize, 0x1000)							// SizeOfInitializedData		// TODO - real data section size
	ByteStreamEmitInteger(headerbuffer, headersize, 0)								// SizeOfUninitializedData
	ByteStreamEmitInteger(headerbuffer, headersize, 0x4000)							// AddressOfEntryPoint			// TODO - unhardcode this stuff
	ByteStreamEmitInteger(headerbuffer, headersize, 0x1000)							// BaseOfCode
	ByteStreamEmitInteger(headerbuffer, headersize, 0xc00)							// BaseOfData

	ByteStreamEmitInteger(headerbuffer, headersize, 0x400000)						// ImageBase
	ByteStreamEmitInteger(headerbuffer, headersize, 0x1000)							// SectionAlignment
	ByteStreamEmitInteger(headerbuffer, headersize, 0x200)							// FileAlignment

	ByteStreamEmitInteger16(headerbuffer, headersize, 0x04)							// MajorOperatingSystemVersion
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x00)							// MinorOperatingSystemVersion
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)							// MajorImageVersion
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)							// MinorImageVersion
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x04)							// MajorSubsystemVersion
	ByteStreamEmitInteger16(headerbuffer, headersize, 0x00)							// MinorSubsystemVersion

	ByteStreamEmitInteger(headerbuffer, headersize, 0)								// Win32VersionValue
	ByteStreamEmitInteger(headerbuffer, headersize, imagesize)						// SizeOfImage
	ByteStreamEmitInteger(headerbuffer, headersize, 0x400)							// SizeOfHeaders
	ByteStreamEmitInteger(headerbuffer, headersize, 0xf00d)							// Checksum

	ByteStreamEmitInteger16(headerbuffer, headersize, subsystem)					// Subsystem
	ByteStreamEmitInteger16(headerbuffer, headersize, 0)							// DllCharacteristics

	ByteStreamEmitInteger(headerbuffer, headersize, 0x800000)						// SizeOfStackReserve
	ByteStreamEmitInteger(headerbuffer, headersize, 0x80000)						// SizeOfStackCommit
	ByteStreamEmitInteger(headerbuffer, headersize, 0x500000)						// SizeOfHeapReserve
	ByteStreamEmitInteger(headerbuffer, headersize, 0x50000)						// SizeOfHeapCommit
	ByteStreamEmitInteger(headerbuffer, headersize, 0)								// LoaderFlags
	ByteStreamEmitInteger(headerbuffer, headersize, 0x10)							// NumberOfRvaAndSizes

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 1
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0x1200)				// RVA virtual address 2		// TODO - unhardcode
	ByteStreamEmitInteger(headerbuffer, headersize, 0x28)				// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0x2000)				// RVA virtual address 3		// TODO - unhardcode
	ByteStreamEmitInteger(headerbuffer, headersize, resourcesize)		// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 4
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 5
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 6
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 7
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 8
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 9
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 10
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 11
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 12
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 13
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 14
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 15
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size

	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// RVA virtual address 16
	ByteStreamEmitInteger(headerbuffer, headersize, 0)					// Size


	integer written = 0
	WriteFile(filehandle, headerbuffer, headersize, written, 0)

	writtenbytes = headersize
}


structure StringPoolPreprocessState :
	BinaryTreeRoot<integer> ref Offsets,
	integer CurrentOffset
	
structure StringPoolOutputState :
	BinaryTreeRoot<integer> ref Offsets,
	buffer OutputBuffer

PreprocessStringPool : StringPool ref pool, BinaryTreeRoot<integer> ref outoffsets -> integer totallength = 0
{
	StringPoolPreprocessState state = outoffsets, 0
	BinaryTreeWalkAllNodesWithParam<string, StringPoolPreprocessState>(pool.LookupMap.RootNode, PreprocessSingleString, state)
	
	totallength = state.CurrentOffset
}

PreprocessSingleString : integer handle, string ref strpayload, StringPoolPreprocessState ref state -> boolean ret = true
{
	BinaryTreeCreateOrInsert<integer>(state.Offsets, handle, state.CurrentOffset)
	state.CurrentOffset = state.CurrentOffset + length(strpayload) + 1
}


CopySingleStringToBuffer : integer handle, string ref strpayload, StringPoolOutputState ref state -> boolean ret = true
{
	integer offset = 0
	boolean found = BinaryTreeCopyPayload<integer>(state.Offsets.RootNode, handle, offset)
	assert(found)
	
	integer len = length(strpayload)
	integer counter = offset
	
	while(counter < offset + len)
	{
		integer value = subchar(strpayload, counter - offset)
		writebuffer(state.OutputBuffer, counter, (value) & 0xff)
		
		++counter
	}
	
	writebuffer(state.OutputBuffer, counter, 0x00)
}




ThunkTableGetCompleteSize : ThunkTable ref table -> integer totalsize = 0
{
	ThunkTableLibrariesWalkForSize(table.Libraries, table.TotalSize)
	
	integer namelistsize = table.TotalSize
	ThunkTableLibrariesWalkForAddressHolders(table.Libraries, namelistsize)
	namelistsize += 4
	ThunkTableLibrariesWalkForAddressCopyHolders(table.Libraries, namelistsize)
	
	totalsize = RoundUpFile(table.TotalSize)
	table.DescriptorOffset = totalsize
	
	ThunkAddressesWalkLibrariesForOffsets(table.Libraries, totalsize)
}

ThunkTableLibrariesWalkForSize : list<ThunkTableLibrary> ref libraries, integer ref startoffset
{
	libraries.value.StartOffset = startoffset
	ThunkTableFunctionsWalkForSize(libraries.value.Functions, startoffset)
	
	libraries.value.NameOffset = startoffset
	
	startoffset += length(libraries.value.LibraryName) + 1				// NULL terminator
	
	ThunkTableLibrariesWalkForSize(libraries.next, startoffset)
}

ThunkTableLibrariesWalkForSize : nothing, integer ref startoffset


ThunkTableFunctionsWalkForSize : list<ThunkTableEntry> ref functions, integer ref startoffset
{
	integer funclength = length(functions.value.FunctionName) + 3		// NULL terminator plus the 16-bit hint word
	functions.value.ThunkTableOffset = startoffset
	
	startoffset += funclength
	
	ThunkTableFunctionsWalkForSize(functions.next, startoffset)
}

ThunkTableFunctionsWalkForSize : nothing, integer ref startoffset


ThunkAddressesWalkLibrariesForOffsets : list<ThunkTableLibrary> ref libraries, integer ref startoffset
{
	startoffset += 20
	ThunkAddressesWalkLibrariesForOffsets(libraries.next, startoffset)
}

ThunkAddressesWalkLibrariesForOffsets : nothing, integer ref startoffset
{
	startoffset += 20			// Final "null" import descriptor
}



ThunkTableLibrariesWalkForAddressHolders : list<ThunkTableLibrary> ref libraries, integer ref offset
{
	ThunkTableFunctionsWalkForAddressHolders(libraries.value.Functions, offset)
	ThunkTableLibrariesWalkForAddressHolders(libraries.next, offset)
}

ThunkTableLibrariesWalkForAddressHolders : nothing, integer ref offset


ThunkTableFunctionsWalkForAddressHolders : list<ThunkTableEntry> ref functions, integer ref offset
{
	functions.value.ThunkAddressOffset = offset
	offset += 4

	ThunkTableFunctionsWalkForAddressHolders(functions.next, offset)
}

ThunkTableFunctionsWalkForAddressHolders : nothing, integer ref offset



ThunkTableLibrariesWalkForAddressCopyHolders : list<ThunkTableLibrary> ref libraries, integer ref offset
{
	ThunkTableFunctionsWalkForAddressCopyHolders(libraries.value.Functions, offset)
	ThunkTableLibrariesWalkForAddressCopyHolders(libraries.next, offset)
}

ThunkTableLibrariesWalkForAddressCopyHolders : nothing, integer ref offset


ThunkTableFunctionsWalkForAddressCopyHolders : list<ThunkTableEntry> ref functions, integer ref offset
{
	functions.value.ThunkAddressCopyOffset = offset
	offset += 4

	ThunkTableFunctionsWalkForAddressCopyHolders(functions.next, offset)
}

ThunkTableFunctionsWalkForAddressCopyHolders : nothing, integer ref offset




ThunkTableEmit : Win32Handle filehandle, ThunkTable ref table, integer virtualbase -> integer byteswritten = 0
{
	byteswritten += ThunkTableEmitLibraries(filehandle, table.Libraries)
	byteswritten += ThunkTableEmitThunkHolders(filehandle, table.Libraries, virtualbase)
	byteswritten += WritePadding(filehandle, 0, 4)
	byteswritten += ThunkTableEmitThunkHolders(filehandle, table.Libraries, virtualbase)		// Second (copy) holders
	
	byteswritten += WritePadding(filehandle, byteswritten, table.DescriptorOffset)
	
	byteswritten += ThunkTableEmitDescriptors(filehandle, table.Libraries, virtualbase)
}

ThunkTableEmitLibraries : Win32Handle filehandle, list<ThunkTableLibrary> ref libraries -> integer byteswritten = 0
{
	byteswritten += ThunkTableEmitFunctions(filehandle, libraries.value.Functions)
	
	buffer libname = narrowstring(libraries.value.LibraryName)
	integer written = 0
	WriteFile(filehandle, libname, length(libraries.value.LibraryName) + 1, written, 0)
	
	byteswritten += written
	

	ThunkTableEmitLibraries(filehandle, libraries.next)
}

ThunkTableEmitLibraries : Win32Handle filehandle, nothing -> 0


ThunkTableEmitFunctions : Win32Handle filehandle, list<ThunkTableEntry> ref functions -> integer byteswritten = 0
{
	integer zerooffset = 0
	buffer dummy16 = 2
	
	zerooffset = 0
	ByteStreamEmitInteger16(dummy16, zerooffset, 0x0000)
	
	integer written = 0
	WriteFile(filehandle, dummy16, 2, written, 0)
	byteswritten += written
	
	written = 0
	buffer funcname = narrowstring(functions.value.FunctionName)
	WriteFile(filehandle, funcname, length(functions.value.FunctionName) + 1, written, 0)
	byteswritten += written	
	

	byteswritten += ThunkTableEmitFunctions(filehandle, functions.next)
}

ThunkTableEmitFunctions : Win32Handle filehandle, nothing -> integer byteswritten = 0


ThunkTableEmitThunkHolders : Win32Handle filehandle, list<ThunkTableLibrary> ref libraries, integer virtualbase -> integer byteswritten = 0
{
	byteswritten = ThunkTableEmitThunkHoldersPerFunction(filehandle, libraries.value.Functions, virtualbase)

	byteswritten += ThunkTableEmitThunkHolders(filehandle, libraries.next, virtualbase)
}

ThunkTableEmitThunkHolders : Win32Handle filehandle, nothing, integer virtualbase -> 0


ThunkTableEmitThunkHoldersPerFunction : Win32Handle filehandle, list<ThunkTableEntry> ref functions, integer virtualbase -> integer byteswritten = 0
{
	buffer thunkbuffer = 8
	integer thunksize = 0
	
	ByteStreamEmitInteger(thunkbuffer, thunksize, functions.value.ThunkTableOffset + virtualbase)

	integer written = 0
	WriteFile(filehandle, thunkbuffer, thunksize, written, 0)
	
	byteswritten = written
	byteswritten += ThunkTableEmitThunkHoldersPerFunction(filehandle, functions.next, virtualbase)
}

ThunkTableEmitThunkHoldersPerFunction : Win32Handle filehandle, nothing, integer virtualbase -> 0



ThunkTableEmitDescriptors : Win32Handle filehandle, list<ThunkTableLibrary> ref libraries, integer virtualbase -> integer byteswritten = 0
{
	buffer thunkbuffer = 128
	integer thunksize = 0
	
	ByteStreamEmitInteger(thunkbuffer, thunksize, virtualbase + ThunkTableGetLibFirstThunkOffset(libraries.value))
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	ByteStreamEmitInteger(thunkbuffer, thunksize, virtualbase + libraries.value.NameOffset)
	ByteStreamEmitInteger(thunkbuffer, thunksize, virtualbase + ThunkTableGetLibFirstThunkCopyOffset(libraries.value))	
	
	integer written = 0
	WriteFile(filehandle, thunkbuffer, thunksize, written, 0)

	byteswritten = thunksize
	

	byteswritten += ThunkTableEmitDescriptors(filehandle, libraries.next, virtualbase)
}

ThunkTableEmitDescriptors : Win32Handle filehandle, nothing, integer virtualbase -> integer byteswritten = 0
{
	buffer thunkbuffer = 128
	integer thunksize = 0
	
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	ByteStreamEmitInteger(thunkbuffer, thunksize, 0)
	
	integer written = 0
	WriteFile(filehandle, thunkbuffer, thunksize, written, 0)

	byteswritten = thunksize
}


ThunkTableGetLibFirstThunkOffset : ThunkTableLibrary ref lib -> integer offset = ThunkTableEntryGetFirstThunkOffset(lib.Functions)
ThunkTableEntryGetFirstThunkOffset : list<ThunkTableEntry> ref functions -> integer offset = functions.value.ThunkAddressOffset

ThunkTableGetLibFirstThunkCopyOffset : ThunkTableLibrary ref lib -> integer offset = ThunkTableEntryGetFirstThunkCopyOffset(lib.Functions)
ThunkTableEntryGetFirstThunkCopyOffset : list<ThunkTableEntry> ref functions -> integer offset = functions.value.ThunkAddressCopyOffset



ThunkLookupMapper : string funcname -> integer thunkoffset = 0
{
	// TODO - don't hard code base address
	integer baseaddress = 0x401000
	
	thunkoffset = baseaddress + SearchThunkTableForFunctionOffset(GlobalThunkTable.Libraries, funcname)
	
	if(thunkoffset < baseaddress)
	{
		thunkoffset = 0
	}
}

SearchThunkTableForFunctionOffset : list<ThunkTableLibrary> ref libraries, string funcname -> integer offset = -1
{
	offset = SearchThunkLibForFunctionOffset(libraries.value.Functions, funcname)
	if(offset < 0)
	{
		offset = SearchThunkTableForFunctionOffset(libraries.next, funcname)
	}
}

SearchThunkTableForFunctionOffset : nothing, string funcname -> integer offset = -1

SearchThunkLibForFunctionOffset : list<ThunkTableEntry> ref functions, string funcname -> integer offset = -1
{
	if(functions.value.FunctionName == funcname)
	{
		offset = functions.value.ThunkAddressCopyOffset
	}
	else
	{
		offset = SearchThunkLibForFunctionOffset(functions.next, funcname)
	}
}

SearchThunkLibForFunctionOffset : nothing, string funcname -> integer offset = -1


StringLookupMapper : integer stringhandle -> integer offset = 0
{
	// TODO - don't hard code base address
	integer baseaddress = 0x403000
	
	BinaryTreeCopyPayload<integer>(GlobalStringOffsets.RootNode, stringhandle, offset)
	
	offset += baseaddress
}



SetUpAllLLVMCode : LLVMContextHandle context
{
	EmitAllFunctionsToLLVM(context, Functions)
}

EmitAllFunctionsToLLVM : LLVMContextHandle context, list<FunctionDefinition> ref funcs
{
	if(!funcs.value.IsTemplate)
	{
		if(funcs.value.Name != 0)
		{
			EmitSingleFunctionToLLVM(context, funcs.value)
		}
	}

	EmitAllFunctionsToLLVM(context, funcs.next)
}

EmitAllFunctionsToLLVM : LLVMContextHandle context, nothing


EmitSingleFunctionToLLVM : LLVMContextHandle context, FunctionDefinition ref func
{
	string funcname = GetPooledString(func.Name)

	LLVMType funcrettype = EpochLLVMTypeGetVoid(context) // TODO - select actual function return type
	
	// TODO - set up parameter types
	
	LLVMFunctionType functype = EpochLLVMFunctionTypeCreate(context, funcrettype)
	LLVMFunctionRef llvmfunc = EpochLLVMFunctionCreate(context, funcname, functype)
	
	LLVMBasicBlock funcbody = EpochLLVMCodeCreateBasicBlock(context, llvmfunc)
	
	// TODO - emit return value initializer
	
	// TODO - emit call for @invoke tags
	
	EmitCodeBlockToLLVM(context, func.Code)
	
	if(listcontains(CustomConstructors, func.Name))
	{
		// TODO - bind return variable value
		
		//BytecodePushVarValueNoCopy(stream, FindReturnVariableName())
		//BytecodeBindReference(stream, 0, 0)			// TODO - kind of a hack
		//BytecodeAssign(stream)
	}
	else
	{
		if(func.AnonymousReturn)
		{
			// TODO - emit return register bindings
			//EmitReturnRegisterToLLVMAnonymous(context, func.Return)
		}
		else
		{
			EmitReturnRegisterToLLVM(context, func.Return)
		}
	}
	
	// TODO - finalize function?
	
	
	if(funcname == "entrypoint")
	{
		EpochLLVMFunctionSetEntry(context, llvmfunc)
	}
}

EmitCodeBlockToLLVM : LLVMContextHandle context, CodeBlock ref code
{
	EmitCodeBlockEntriesToLLVM(context, code.Entries)
}

EmitCodeBlockToLLVM : LLVMContextHandle context, nothing


EmitReturnRegisterToLLVM : LLVMContextHandle context, Expression ref expr
{
	// TODO - set return value
}

EmitReturnRegisterToLLVM : LLVMContextHandle context, nothing
{
	EpochLLVMCodeCreateRetVoid(context)
}


EmitCodeBlockEntriesToLLVM : LLVMContextHandle context, list<CodeBlockEntry> ref entries
{
	EmitSingleCodeBlockEntryToLLVM(context, entries.value)
	EmitCodeBlockEntriesToLLVM(context, entries.next)
}

EmitCodeBlockEntriesToLLVM : LLVMContextHandle context, nothing



EmitSingleCodeBlockEntryToLLVM : LLVMContextHandle context, Statement ref entry
{
	// TODO - map over the remaining code from CodeGenEmitSingleCodeBlockEntry for statements
	
	EmitExpressionListToLLVM(context, entry.Parameters)

	if(IsRecognizedBuiltIn(entry.Name))
	{
		integer thunk = 0
		BinaryTreeCopyPayload<integer>(LLVMGlobalThunks.RootNode, entry.Name, thunk)
		EpochLLVMCodeCreateCallThunk(context, thunk)
	}
}

EmitSingleCodeBlockEntryToLLVM : LLVMContextHandle context, EntityChain ref entry
{
	// TODO - build LLVM version of the entity
}

// TODO - remaining code block entry types


EmitExpressionListToLLVM : LLVMContextHandle context, nothing

EmitExpressionListToLLVM : LLVMContextHandle context, ExpressionList ref exprs
{
	EmitExpressionListToLLVM(context, exprs.Expressions)
}

EmitExpressionListToLLVM : LLVMContextHandle context, list<Expression> ref exprs
{
	EmitExpressionAtomsToLLVM(context, exprs.value.Atoms)
	EmitExpressionListToLLVM(context, exprs.next)
}

EmitExpressionAtomsToLLVM : LLVMContextHandle context, list<ExpressionAtom> ref atoms
{
	// TODO - expand this to support all the nifty stuff atoms can do
	
	EmitSingleAtomToLLVM(context, atoms.value)
	EmitExpressionAtomsToLLVM(context, atoms.next)
}

EmitExpressionAtomsToLLVM : LLVMContextHandle context, nothing


EmitSingleAtomToLLVM : LLVMContextHandle context, AtomSentinel ref sentinel


EmitSingleAtomToLLVM : LLVMContextHandle context, integer ref literal
{
	// TODO - support literals
}

EmitSingleAtomToLLVM : LLVMContextHandle context, boolean ref literal
{
	EpochLLVMCodePushBoolean(context, literal)
}

EmitSingleAtomToLLVM : LLVMContextHandle context, StringHandleAtom ref literal
{
	EpochLLVMCodePushString(context, literal.Handle)
}


SetUpBuiltInLLVMThunks : LLVMContextHandle context
{
	BuiltInThunkCreateAssert(context)
	BuiltInThunkCreatePasstest(context)
	BuiltInThunkCreatePrint(context)
}

BuiltInThunkCreateAssert : LLVMContextHandle context
{
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetBoolean(context))
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_assert", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForAssert, thunk)
}

BuiltInThunkCreatePasstest : LLVMContextHandle context
{
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_passtest", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForPassTest, thunk)
}

BuiltInThunkCreatePrint : LLVMContextHandle context
{
	EpochLLVMFunctionQueueParamType(context, EpochLLVMTypeGetString(context))
	LLVMFunctionType fty = EpochLLVMFunctionTypeCreate(context, EpochLLVMTypeGetVoid(context))
	integer thunk = EpochLLVMFunctionCreateThunk(context, "ERT_print", fty)

	BinaryTreeCreateOrInsert<integer>(LLVMGlobalThunks, PooledStringHandleForPrint, thunk)
}

