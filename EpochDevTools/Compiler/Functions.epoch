
AttachContextToFunction : FunctionDefinition ref funcraw, integer mangledfuncname, FunctionDefinition ref func
{
	AttachContextToOverload(funcraw.Overloads, mangledfuncname, func)
}


IRRegisterFunctionParam : integer paramname, integer paramtypename, boolean isref, boolean templated
{
	UnresolvedParameter p = paramname, paramtypename, 0, isref, nothing, nothing

	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		p.TemplateArgs = ScratchTemplateArgumentStack.value

		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}

	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)
}

AppendUnresolvedParameterToFunction : FunctionDefinition ref func, FunctionParams ref params, UnresolvedParameter ref p
{
	AppendUnresolvedParameter(params.Params, params.Params.next, p)
}

AppendUnresolvedParameterToFunction : FunctionDefinition ref func, nothing, UnresolvedParameter ref p
{
	list<UnresolvedParameter> newlist = p, nothing
	FunctionParams fp = newlist
	OptionalParameters params = fp
	func.Params = params
}


AppendUnresolvedParameter : list<UnresolvedParameter> ref thelist, list<UnresolvedParameter> ref tail, UnresolvedParameter ref p
{
	AppendUnresolvedParameter(tail, tail.next, p)
}

AppendUnresolvedParameter : list<UnresolvedParameter> ref thelist, nothing, UnresolvedParameter ref p
{
	list<UnresolvedParameter> newlist = p, nothing
	thelist.next = newlist
}



FunctionIsAutoGenOrHasIR : integer funcname -> boolean ret = false
{
	if(IsRecognizedBuiltIn(funcname))
	{
		return()
	}

	if(SearchBinaryTree<FunctionDefinition>(GlobalRootNamespace.Functions.RootNode, funcname))
	{
		ret = true
	}
	elseif(FunctionIsAutoGen(AutoGeneratedFunctionNames, funcname))
	{
		ret = true
	}
	elseif(TypeMatcherExists(TypeMatchers, funcname))
	{
		ret = true
	}
	elseif(PatternMatcherExists(PendingPatternMatchers, funcname))
	{
		ret = true
	}
}

FunctionIsAutoGen : simplelist<integer> ref genlist, integer target -> boolean ret = false [nogc]
{
	if(genlist.value == target)
	{
		ret = true
	}
	else
	{
		ret = FunctionIsAutoGen(genlist.next, target)
	}
}

FunctionIsAutoGen : nothing, integer target -> boolean ret = false [nogc]


AppendParameter : list<Parameter> ref params, Parameter ref p
{
	AppendParameterRecurse(params, params.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, list<Parameter> ref tail, Parameter ref p
{
	AppendParameterRecurse(tail, tail.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, nothing, Parameter ref p
{
	list<Parameter> newlist = p, nothing
	params.next = newlist
}



CountParameters : list<Parameter> ref params -> integer count = 0 [nogc]
{
	count = CountParameters(params.next)

	if(params.value.Type != 0)
	{
		++count
	}
}

CountParameters : nothing -> integer count = 0 [nogc]


FindFunctionAndSetInvokeTag : list<FunctionDefinition> ref functions, integer funcname, integer invoketarget [nogc]
{
	if(functions.value.Name == funcname)
	{
		functions.value.InvokeTag = invoketarget
	}
	else
	{
		FindFunctionAndSetInvokeTag(functions.next, funcname, invoketarget)
	}
}

FindFunctionAndSetInvokeTag : nothing, integer funcname, integer invoketarget [nogc]
{
	print("Cannot tag non-existent function")
	assert(false)
}


AppendFunctionTagParam : list<string> ref params, list<string> ref tail, string param
{
	AppendFunctionTagParam(tail, tail.next, param)
}

AppendFunctionTagParam : list<string> ref params, nothing, string param
{
	list<string> newlist = param, nothing
	params.next = newlist
}


SetReturnExpression : FunctionDefinition ref funcdef, Expression ref expr
{
	funcdef.Return = expr

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}


GetFunctionWrapperParameterCount : FunctionDefinition ref func, integer mangledname -> integer count = 0
{
	count = CountUnresolvedParameters(func.Params)
}

GetFunctionWrapperParameterCount : nothing, integer mangledname -> integer count = 0
{
	count = GetFunctionParameterCount(mangledname)
}


CountUnresolvedParameters : FunctionParams ref params -> integer count = CountUnresolvedParametersUnwrapped(params.Params) [nogc]
CountUnresolvedParameters : nothing -> 0 [nogc]

CountUnresolvedParametersUnwrapped : list<UnresolvedParameter> ref params -> integer count = 0 [nogc]
{
	if(params.value.NameHandle != 0)
	{
		++count
	}
	elseif(GetOptionalExpressionType(params.value.PatternMatchValue) != 0)
	{
		++count
	}

	count += CountUnresolvedParametersUnwrapped(params.next)
}

CountUnresolvedParametersUnwrapped : nothing -> 0 [nogc]




FunctionWrapperMatchesParameterTypes : FunctionDefinition ref func, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	match = CheckParameterTypesForMatch(func.Params, types)
}

FunctionWrapperMatchesParameterTypes : nothing, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	match = FunctionMatchesParameterTypes(Functions, funcname, types)
}


FunctionMatchesParameterTypes : list<FunctionDefinition> ref functions, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	ContextNode<FunctionDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(GlobalRootNamespace.Functions.RootNode, funcname, wrap)
	if(found)
	{
		match = CheckParameterTypesForMatch(wrap, types)
	}
	else
	{
		match = FunctionMatchesParameterTypes(nothing, funcname, types)
	}
}

FunctionMatchesParameterTypes : nothing, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	if(funcname == PooledStringHandleForSubstringWithLength)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForSubstringNoLength)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForSubchar)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBuffer)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		simplelist<integer> ptypes = 0x01000004, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForUnescape)
	{
		simplelist<integer> ptypes = 0x02000000, nothing
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForBuffer)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForBufferCopy)
	{
		simplelist<integer> ptypes = 0x02000001, nothing
		simpleprepend<integer>(ptypes, 0x01000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	else
	{
		boolean ignored = false
		match = ConstructorMatchesParameterTypes(Structures, funcname, types, ignored)
	}
}

GatherAllPossibleParamTypes : integer funcname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo -> boolean found = false
{
	ContextNode<FunctionDefinition> wrap = nothing
	found = SearchBinaryTreeForPayload<FunctionDefinition>(GlobalRootNamespace.Functions.RootNode, funcname, wrap)
	if(found)
	{
		InferAllFunctionParameterTypes(wrap, numparams, toplevel, outinfo)
		EnumerateOverloadsAndAddAllParameterTypes(wrap, numparams, toplevel, outinfo)
	}
	else
	{
		found = GatherAllPossibleParamTypesForConstructor(Structures, funcname, numparams, toplevel, outinfo)
	}
}

InferAllFunctionParameterTypes : FunctionDefinition ref function, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	if(!function.InferenceDone)
	{
		TypeInference(function, DummyContextForFunctions)
	}

	UnwrapAllParamsForTypeRetrieval(function.Params, numparams, outinfo)
}


UnwrapAllParamsForTypeRetrieval : FunctionParams ref params, integer paramcount, list<ParameterTypeList> ref outinfo
{
	if(CountUnresolvedParameters(params) == paramcount)
	{
		RetrieveAllParamTypes(params.Params, outinfo)
	}
}

UnwrapAllParamsForTypeRetrieval : nothing, integer paramcount, list<ParameterTypeList> ref outinfo


RetrieveAllParamTypes : list<UnresolvedParameter> ref params, list<ParameterTypeList> ref outinfo [nogc]
{
	simpleprepend<integer>(outinfo.value.Types, params.value.ResolvedType)
	RetrieveAllParamTypes(params.next, outinfo.next)
}

RetrieveAllParamTypes : nothing, nothing [nogc]


PrependFunctionParameter : list<FunctionDefinition> ref functions, integer funcname, integer paramname, integer paramtype
{
	if(functions.value.Name == funcname)
	{
		assert(paramtype != 0)
		UnresolvedParameter p = paramname, GetNameOfType(paramtype), paramtype, IsReferenceType(paramtype), nothing, nothing
		PrependUnresolvedParameter(functions.value.Params, p)
	}
	else
	{
		PrependFunctionParameter(functions.next, funcname, paramname, paramtype)
	}
}

PrependUnresolvedParameter : FunctionParams ref params, UnresolvedParameter ref p
{
	PrependUnresolvedParameter(params.Params, p)
}

PrependUnresolvedParameter : list<UnresolvedParameter> ref thelist, UnresolvedParameter ref p
{
	prepend<UnresolvedParameter>(thelist, p)
}

PrependUnresolvedParameter : nothing, UnresolvedParameter ref p
{
	print("Cannot set constructor tag on function with no parameters")
	assert(false)
}



GetSignatureReturnType : list<FunctionSignature> ref signatures, integer functype -> integer rettype = 0
{
	if(signatures.value.Name == functype)		// stupid overload of "name" to also mean "type"
	{
		rettype = GetTypeByName(signatures.value.ReturnTypeName)
	}
	else
	{
		rettype = GetSignatureReturnType(signatures.next, functype)
	}
}


GetFunctionSignatureParamType : list<FunctionSignature> ref signatures, integer functype, integer paramindex -> integer rettype = 0
{
	if(signatures.value.Name == functype)
	{
		rettype = GetSignatureParamType(signatures.value.Parameters, paramindex)
	}
	else
	{
		rettype = GetFunctionSignatureParamType(signatures.next, functype, paramindex)
	}
}

GetFunctionSignatureParamType : nothing, integer functype, integer paramindex -> 0



GetSignatureParamType : list<Parameter> ref params, integer paramindex -> integer rettype = 0
{
	if(paramindex == 0)
	{
		if(params.value.Name != 0)
		{
			rettype = params.value.Type
			if(params.value.Name == 2)			// Horrifying hack
			{
				rettype = MakeReferenceType(rettype)
			}
			return()
		}
	}

	if(params.value.Name == 0)
	{
		rettype = GetSignatureParamType(params.next, paramindex)
	}
	else
	{
		rettype = GetSignatureParamType(params.next, paramindex - 1)
	}
}

GetSignatureParamType : nothing, integer paramindex -> 0


FindOrCreateFunctionSignatureType : FunctionSignature ref signature -> integer typeid = 0
{
	typeid = FindMatchingSignature(FunctionSignatures, signature)
	if(typeid == 0)
	{
		FunctionSignature newsig = signature
		newsig.Name = (++GlobalFunctionTypeCounter)
		prepend<FunctionSignature>(FunctionSignatures, newsig)

		typeid = newsig.Name
	}
}

FindOrCreateFunctionSignatureType : simplelist<integer> ref paramtypenames, simplelist<boolean> ref paramrefflags, integer returntypename -> integer typeid = 0
{
	typeid = FindFunctionSignatureType(FunctionSignatures, paramtypenames, paramrefflags, returntypename)
	if(typeid == 0)
	{
		OnCodeGenRegisterFunctionSig((++GlobalFunctionTypeCounter), returntypename)
		OnCodeGenRegisterFunctionSigParamList(paramtypenames, paramrefflags)

		typeid = GlobalFunctionTypeCounter
	}
}

FindFunctionSignatureType : list<FunctionSignature> ref signatures, simplelist<integer> ref paramtypes, simplelist<boolean> ref paramrefflags, integer returntypename -> integer typeid = 0
{
	if(signatures.value.ReturnTypeName == returntypename)
	{
		if(SignatureMatchesParams(signatures.value.Parameters, paramtypes, paramrefflags))
		{
			typeid = signatures.value.Name
			return()
		}
	}

	typeid = FindFunctionSignatureType(signatures.next, paramtypes, paramrefflags, returntypename)
}

FindFunctionSignatureType : nothing, simplelist<integer> ref paramtypes, simplelist<boolean> ref paramrefflags, integer returntypename -> 0



FindFunctionAndGetSignatureType : list<FunctionDefinition> ref functions, integer funcname -> integer typeid = 0
{
	if(functions.value.Name == funcname)
	{
		if(!functions.value.InferenceDone)
		{
			TypeInference(functions.value, DummyContextForFunctions)
		}
	
		simplelist<integer> paramtypes = 0, nothing
		simplelist<boolean> paramrefflags = false, nothing
		GetFunctionParameterTypes(functions.value.Params, paramtypes, paramrefflags)

		integer rettypename = 0
		integer rettype = InferFunctionReturnType(functions.value)
		if(rettype != 0)
		{
			rettypename = GetNameOfType(rettype)
		}
		typeid = FindOrCreateFunctionSignatureType(paramtypes, paramrefflags, rettypename)
	}
	else
	{
		typeid = FindFunctionAndGetSignatureType(functions.next, funcname)
	}
}


GetFunctionParameterTypes : FunctionParams ref params, simplelist<integer> ref outtypenames, simplelist<boolean> ref outrefflags
{
	GetFunctionParameterTypes(params.Params, outtypenames, outrefflags)
}

GetFunctionParameterTypes : list<UnresolvedParameter> ref params, simplelist<integer> ref outtypenames, simplelist<boolean> ref outrefflags
{
	GetFunctionParameterTypes(params.next, outtypenames, outrefflags)

	if(params.value.ResolvedType == 0)
	{
		print("Internal error: function parameter has unresolved type")
		print(GetPooledString(params.value.NameHandle))
		print(GetPooledString(params.value.TypeNameHandle))
		assert(false)
	}

	simpleprepend<integer>(outtypenames, GetNameOfType(params.value.ResolvedType))
	simpleprepend<boolean>(outrefflags, IsReferenceType(params.value.ResolvedType))
}

GetFunctionParameterTypes : nothing, simplelist<integer> ref outtypenames, simplelist<boolean> ref outrefflags


FindMatchingSignature : list<FunctionSignature> ref signatures, FunctionSignature ref targetsig -> integer typeid = 0
{
	if(signatures.value.ReturnTypeName == targetsig.ReturnTypeName)
	{
		if(SignaturesMatch(signatures.value.Parameters, targetsig.Parameters))
		{
			typeid = signatures.value.Name
			return()
		}
	}

	typeid = FindMatchingSignature(signatures.next, targetsig)
}

FindMatchingSignature : nothing, FunctionSignature ref targetsig -> 0


SignaturesMatch : list<Parameter> ref a, list<Parameter> ref b -> boolean match = true
{
	if(a.value.Type != b.value.Type)
	{
		match = false
	}
	else
	{
		match = SignaturesMatch(a.next, b.next)
	}
}

SignaturesMatch : nothing, list<Parameter> ref b -> (b.value.Name == 0)
SignaturesMatch : list<Parameter> ref a, nothing -> (a.value.Name == 0)

SignaturesMatch : nothing, nothing -> true



SetFunctionReturnType : FunctionDefinition ref func, integer funcname, integer rettype [nogc]
{
	SetOptionalExpressionType(func.Return, rettype)
}


FunctionSignatureHasLiterals : FunctionParams ref params -> boolean hasliterals = FunctionSignatureHasLiterals(params.Params) [nogc]

FunctionSignatureHasLiterals : list<UnresolvedParameter> ref params -> boolean hasliterals = false [nogc]
{
	integer exprtype = GetOptionalExpressionType(params.value.PatternMatchValue)
	if((exprtype != 0) && (exprtype != 0x00000002))
	{
		hasliterals = true
		return()
	}

	if(FunctionSignatureHasLiterals(params.next))
	{
		hasliterals = true
	}
}

FunctionSignatureHasLiterals : nothing -> false [nogc]




RegisterLiteralFunctionParam : integer literalvalue
{
	ExpressionAtom atom = literalvalue
	list<ExpressionAtom> atoms = atom, nothing
	Expression expr = atoms, 0x01000001		// integer type signature

	UnresolvedParameter p = 0, GetNameOfType(expr.Type), expr.Type, false, expr, nothing
	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)
}

RegisterLiteralFunctionParam : real literalvalue
{
	ExpressionAtom atom = literalvalue
	list<ExpressionAtom> atoms = atom, nothing
	Expression expr = atoms, 0x01000004		// real type signature

	UnresolvedParameter p = 0, GetNameOfType(expr.Type), expr.Type, false, expr, nothing
	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)
}

DisableAnonymousReturnOnCurrentFunction :
{
	Functions.value.AnonymousReturn = false
}

FlagFunctionAsExternal : integer functionname
{
	FindFunctionAndSetInvokeTag(Functions, functionname, PoolString("@@external"))
}




CountTagParams : list<string> ref params -> integer count = 0 [nogc]
{
	count = CountTagParams(params.next)
	if(params.value != "")
	{
		++count
	}
}

CountTagParams : nothing -> integer count = 0 [nogc]

