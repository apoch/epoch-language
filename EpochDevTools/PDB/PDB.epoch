//
// Test bed for PDB emission from Epoch code
//



structure PDBFileLayout :
	integer BlockSize,
	integer BlockCount,
	integer DirectoryHintBlock,
	integer DirectoryStartBlock,
	integer PDBInfoStartBlock,
	integer TPIStartBlock,
	integer DBIStartBlock,
	integer IPIStartBlock,
	integer GlobalsStartBlock,
	integer PublicsStartBlock,
	integer SymbolsStartBlock
	

structure PDBOutputStream :
	string            FileName,
	Win32Handle       FileHandle,
	integer           FilePosition,
	PDBFileLayout ref Layout



type Win32Handle : integer


CreateFile :
	string  filename,
	integer access,
	integer sharemode,
	integer attributes,
	integer creation,
	integer flags,
	integer template
 ->
	Win32Handle ret = 0
 [external("Kernel32.dll", "CreateFileW", "stdcall")]
 

CloseHandle : Win32Handle handle -> boolean ret = false [external("Kernel32.dll", "CloseHandle", "stdcall")]


WriteFile :
	Win32Handle handle,
	buffer ref data,
	integer numbytes,
	integer ref written,
	integer ignored2
 ->
	boolean ret = false
 [external("Kernel32.dll", "WriteFile", "stdcall")]
 
WriteFile :
	Win32Handle handle,
	integer ptr,
	integer numbytes,
	integer ref written,
	integer ignored2
 ->
	boolean ret = false
 [external("Kernel32.dll", "WriteFile", "stdcall")]
  
 

CreateFileMapping :
	Win32Handle filehandle,
	integer attributes,
	integer protection,
	integer maxsizehigh,
	integer maxsizelow,
	integer name
 ->
	Win32Handle ret = 0
 [external("Kernel32.dll", "CreateFileMappingW", "stdcall")]
 

GetFileSize :
	Win32Handle handle,
	integer ignored
 ->
	integer size = 0
 [external("Kernel32.dll", "GetFileSize", "stdcall")]
 

MapViewOfFile :
	Win32Handle handle,
	integer access,
	integer offsethigh,
	integer offsetlow,
	integer bytestomap
 ->
	integer ptr = 0
 [external("Kernel32.dll", "MapViewOfFile", "stdcall")]


UnmapViewOfFile : integer ptr -> boolean ret = false [external("Kernel32.dll", "UnmapViewOfFile", "stdcall")]



entrypoint :
{
	integer GENERIC_WRITE = 0x40000000
	integer CREATE_ALWAYS = 2
	
	Win32Handle invalidhandle = -1
	PDBFileLayout layout = 1024, 12, 2, 3, 6, 7, 8, 9, 10, 11, 12
	PDBOutputStream stream = "TestSuite.pdb", invalidhandle, 0, layout

	stream.FileHandle = CreateFile(stream.FileName, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0)
	if(stream.FileHandle == -1)
	{
		print("Cannot open " ; stream.FileName ; " to emit .PDB!")
		assert(false)
	}
	
	WriteMagic(stream)
	WriteSuperBlock(stream)
	
	// This is some kind of indirection that points to the actual directory block??
	PadToBeginningOfBlock(stream, layout.DirectoryHintBlock)
	stream.FilePosition += WriteDirectoryHint(stream.FileHandle)
	
	// Move up to the block for the directory data
	PadToBeginningOfBlock(stream, layout.DirectoryStartBlock)
	WriteDirectory(stream)
	
	// Move up to the block for the PDB info stream
	PadToBeginningOfBlock(stream, layout.PDBInfoStartBlock)
	stream.FilePosition = WritePDBInfoStream(stream.FileHandle, stream.FilePosition)
	
	// Move up and write the TPI stream
	PadToBeginningOfBlock(stream, layout.TPIStartBlock)
	stream.FilePosition = WriteTPIStream(stream.FileHandle, stream.FilePosition)
	
	// Move up and write the DBI stream
	PadToBeginningOfBlock(stream, layout.DBIStartBlock)
	stream.FilePosition = WriteDBIStream(stream.FileHandle, stream.FilePosition)

	// Move up and write the IPI stream
	PadToBeginningOfBlock(stream, layout.IPIStartBlock)
	stream.FilePosition = WriteIPIStream(stream.FileHandle, stream.FilePosition)

	// Move up and write the globals (DBI) stream
	PadToBeginningOfBlock(stream, layout.GlobalsStartBlock)
	stream.FilePosition = WriteGlobalsStream(stream.FileHandle, stream.FilePosition)
	
	// Move up and write the publics (DBI) stream
	PadToBeginningOfBlock(stream, layout.PublicsStartBlock)
	stream.FilePosition = WritePublicsStream(stream.FileHandle, stream.FilePosition)
	
	// Move up and write the symbol records (DBI) stream
	PadToBeginningOfBlock(stream, layout.SymbolsStartBlock)
	stream.FilePosition = WriteSymbolRecordsStream(stream.FileHandle, stream.FilePosition)
	
	// Pad to the end of the file
	PadToBeginningOfBlock(stream, layout.BlockCount + 1)

	CloseHandle(stream.FileHandle)
}



PadToBeginningOfBlock : PDBOutputStream ref stream, integer blockindex
{
	// TODO - lame compiler bug workaround in the 32-bit compiler
	integer fpos = stream.FilePosition
	fpos += WritePadding(stream.FileHandle, stream.FilePosition, stream.Layout.BlockSize * blockindex)
	stream.FilePosition = fpos
}



WriteDirectoryHint : Win32Handle pdbfilehandle -> integer written = 0
{
	buffer hack = 32
	integer hacksize = 0
	
	ByteStreamEmitInteger(hack, hacksize, 3)		// Block index of where the directory actually lives
	
	WriteFile(pdbfilehandle, hack, hacksize, written, 0)
}



WriteMagic : PDBOutputStream ref stream
{
	buffer magic = 64
	integer magicsize = 0
	
	string magicstring = "Microsoft C/C++ MSF 7.00"	// Magic header start
	
	integer count = 0
	while(count < length(magicstring))
	{
		string char = charat(magicstring, count)
		ByteStreamEmitSubstring(magic, magicsize, char, 1)

		++count
	}
	
	ByteStreamEmitByte(magic, magicsize, 13)		// Carriage return
	ByteStreamEmitByte(magic, magicsize, 10)		// Linefeed
	ByteStreamEmitByte(magic, magicsize, 26)		// Magic?
	ByteStreamEmitByte(magic, magicsize, 68)		// 'D'
	ByteStreamEmitByte(magic, magicsize, 83)		// 'S'
	ByteStreamEmitByte(magic, magicsize, 0)			// Null magic
	ByteStreamEmitByte(magic, magicsize, 0)			// Null magic
	ByteStreamEmitByte(magic, magicsize, 0)			// Null magic
	
	WriteFile(stream.FileHandle, magic, magicsize, stream.FilePosition, 0)
}


WriteSuperBlock : PDBOutputStream ref stream
{
	buffer sbheader = 128
	integer headersize = 0
	
	ByteStreamEmitInteger(sbheader, headersize, stream.Layout.BlockSize)
	ByteStreamEmitInteger(sbheader, headersize, 4)			// Free block map index
	ByteStreamEmitInteger(sbheader, headersize, stream.Layout.BlockCount)
	ByteStreamEmitInteger(sbheader, headersize, 68)			// Directory bytes
	ByteStreamEmitInteger(sbheader, headersize, 0)			// Unknown
	ByteStreamEmitInteger(sbheader, headersize, stream.Layout.DirectoryHintBlock)
	
	integer written = 0
	WriteFile(stream.FileHandle, sbheader, headersize, written, 0)
	
	integer endfileposition = stream.FilePosition + written
	endfileposition += WritePadding(stream.FileHandle, endfileposition, stream.Layout.BlockSize)
	
	stream.FilePosition = endfileposition
}



WriteDirectory : PDBOutputStream ref stream
{
	buffer directory = 128
	integer directorysize = 0
	
	// Number of streams
	ByteStreamEmitInteger(directory, directorysize, 8)

	// Stream sizes
	ByteStreamEmitInteger(directory, directorysize, 1)			// These 1s are placeholders saying we don't know a valid length; can't use 0 or things barf
	ByteStreamEmitInteger(directory, directorysize, 48)		// TODO - pull PDB stream datasize from a real structure, don't hardcode it
	ByteStreamEmitInteger(directory, directorysize, 56)		// TODO - real TPI stream size
	ByteStreamEmitInteger(directory, directorysize, 64)		// TODO - real DBI stream
	ByteStreamEmitInteger(directory, directorysize, 56)		// TODO - real IPI stream (?)
	
	ByteStreamEmitInteger(directory, directorysize, 44 + 516)		// globals stream
	ByteStreamEmitInteger(directory, directorysize, 44 + 516)		// publics stream
	ByteStreamEmitInteger(directory, directorysize, 26)		// symbol records stream [TODO]
	

	// Stream blocks
	ByteStreamEmitInteger(directory, directorysize, 5)		// Old MSF directory, unused (TODO - unhardcode)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.PDBInfoStartBlock)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.TPIStartBlock)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.DBIStartBlock)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.IPIStartBlock)
	
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.GlobalsStartBlock)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.PublicsStartBlock)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.SymbolsStartBlock)
	
	integer written = 0
	WriteFile(stream.FileHandle, directory, directorysize, written, 0)
	
	stream.FilePosition = stream.FilePosition + written
}



WritePDBInfoStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	buffer header = 128
	integer headersize = 0
	
	integer version = 20140508
	integer signature = 0 // TODO - timestamp?
	integer age = 1
	
	ByteStreamEmitInteger(header, headersize, version)
	ByteStreamEmitInteger(header, headersize, signature)
	ByteStreamEmitInteger(header, headersize, age)

	// GUID (16 bytes)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)

	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)

	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)

	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)


	// String table thingy
	ByteStreamEmitInteger(header, headersize, 0)
	ByteStreamEmitInteger(header, headersize, 0)
	ByteStreamEmitInteger(header, headersize, 0)
	ByteStreamEmitInteger(header, headersize, 0)
	ByteStreamEmitInteger(header, headersize, 0)


	integer written = 0
	WriteFile(pdbfilehandle, header, headersize, written, 0)
	
	endfileposition = startfileposition + written
}



WriteTPIStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	buffer header = 128
	integer headersize = 0
	
	integer version = 20040203

	ByteStreamEmitInteger(header, headersize, version)
	ByteStreamEmitInteger(header, headersize, 56)			// TODO - hardcoded magic size
	ByteStreamEmitInteger(header, headersize, 0)		// Type index begin
	ByteStreamEmitInteger(header, headersize, 0)		// Type index end
	ByteStreamEmitInteger(header, headersize, 0)		// Type record bytes

	ByteStreamEmitInteger16(header, headersize, 0)		// Hash stream index
	ByteStreamEmitInteger16(header, headersize, 0)		// Hash aux stream index
	
	// These values seem fixed?
	ByteStreamEmitInteger(header, headersize, 4)		// Hash key size
	ByteStreamEmitInteger(header, headersize, 4096)		// Number of hash buckets
	
	ByteStreamEmitInteger(header, headersize, 0)		// Hash value buffer offset
	ByteStreamEmitInteger(header, headersize, 0)		// Hash value buffer length
	
	ByteStreamEmitInteger(header, headersize, 0)		// Index offset buffer offset
	ByteStreamEmitInteger(header, headersize, 0)		// Index offset buffer length
	
	ByteStreamEmitInteger(header, headersize, 0)		// Hash adjustment buffer offset
	ByteStreamEmitInteger(header, headersize, 0)		// Hash adjustment buffer length


	integer written = 0
	WriteFile(pdbfilehandle, header, headersize, written, 0)
	
	endfileposition = startfileposition + written	
}



WriteDBIStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	buffer header = 128
	integer headersize = 0
	
	integer signature = 0xffffffff
	integer version = 20091201
	
	ByteStreamEmitInteger(header, headersize, signature)
	ByteStreamEmitInteger(header, headersize, version)

	ByteStreamEmitInteger(header, headersize, 1)		// age (must match PDB age)
	ByteStreamEmitInteger16(header, headersize, 5)		// stream index of global symbols
	ByteStreamEmitInteger16(header, headersize, 0)		// build number
	ByteStreamEmitInteger16(header, headersize, 6)		// stream index of public symbols
	ByteStreamEmitInteger16(header, headersize, 0)		// PDB DLL version (MSPDBxxx.DLL)
	ByteStreamEmitInteger16(header, headersize, 7)		// stream index of symbol records
	ByteStreamEmitInteger16(header, headersize, 0)		// rebuild number of PDB DLL
	ByteStreamEmitInteger(header, headersize, 0)		// module info substream size
	ByteStreamEmitInteger(header, headersize, 0)		// section contribution substream size
	ByteStreamEmitInteger(header, headersize, 0)		// section map substream size
	ByteStreamEmitInteger(header, headersize, 0)		// file info substream size
	ByteStreamEmitInteger(header, headersize, 0)		// type server map size
	ByteStreamEmitInteger(header, headersize, 0)		// index of MFC type server
	ByteStreamEmitInteger(header, headersize, 0)		// DbgHeader info size
	ByteStreamEmitInteger(header, headersize, 0)		// EC substream size (?)
	ByteStreamEmitInteger16(header, headersize, 0)		// flags
	ByteStreamEmitInteger16(header, headersize, 0)		// machine type
	ByteStreamEmitInteger(header, headersize, 0)		// pad

	integer written = 0
	WriteFile(pdbfilehandle, header, headersize, written, 0)
	
	endfileposition = startfileposition + written	
}



WriteIPIStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	buffer header = 128
	integer headersize = 0
	
	integer version = 20040203

	ByteStreamEmitInteger(header, headersize, version)
	ByteStreamEmitInteger(header, headersize, 56)			// TODO - hardcoded magic size
	ByteStreamEmitInteger(header, headersize, 0)		// Type index begin
	ByteStreamEmitInteger(header, headersize, 0)		// Type index end
	ByteStreamEmitInteger(header, headersize, 0)		// Type record bytes

	ByteStreamEmitInteger16(header, headersize, 0)		// Hash stream index
	ByteStreamEmitInteger16(header, headersize, 0)		// Hash aux stream index
	
	// These values seem fixed?
	ByteStreamEmitInteger(header, headersize, 4)		// Hash key size
	ByteStreamEmitInteger(header, headersize, 4096)		// Number of hash buckets
	
	ByteStreamEmitInteger(header, headersize, 0)		// Hash value buffer offset
	ByteStreamEmitInteger(header, headersize, 0)		// Hash value buffer length
	
	ByteStreamEmitInteger(header, headersize, 0)		// Index offset buffer offset
	ByteStreamEmitInteger(header, headersize, 0)		// Index offset buffer length
	
	ByteStreamEmitInteger(header, headersize, 0)		// Hash adjustment buffer offset
	ByteStreamEmitInteger(header, headersize, 0)		// Hash adjustment buffer length


	integer written = 0
	WriteFile(pdbfilehandle, header, headersize, written, 0)
	
	endfileposition = startfileposition + written	
}



WriteGlobalsStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	buffer header = 1024
	integer headersize = 0
	
	ByteStreamEmitInteger(header, headersize, 0)		// hash
	ByteStreamEmitInteger(header, headersize, 0)		// address map
	ByteStreamEmitInteger(header, headersize, 0)		// num thunks
	ByteStreamEmitInteger(header, headersize, 0)		// size of thunk
	ByteStreamEmitInteger16(header, headersize, 0)		// section index thunk table
	ByteStreamEmitInteger16(header, headersize, 0)		// padding
	ByteStreamEmitInteger(header, headersize, 0)		// offset of thunk table
	ByteStreamEmitInteger(header, headersize, 0)		// number of sections

	// Hash header
	ByteStreamEmitInteger(header, headersize, 0xffffffff)		// signature
	ByteStreamEmitInteger(header, headersize, 0xeffe0000 + 19990810)		// version
	ByteStreamEmitInteger(header, headersize, 0)		// size
	ByteStreamEmitInteger(header, headersize, 0)		// num buckets
	
	
	// Magic bitmap
	integer count = 0
	while(count < 516)
	{
		ByteStreamEmitByte(header, headersize, 0)
		
		++count
	}
	

	integer written = 0
	WriteFile(pdbfilehandle, header, headersize, written, 0)
	
	endfileposition = startfileposition + written	
}


WritePublicsStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	endfileposition = WriteGlobalsStream(pdbfilehandle, startfileposition)
}


WriteSymbolRecordsStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	buffer symbols = 1024
	integer symbolssize = 0


	SymbolSection sectionsymbol = 8, 0x8000, 0x1000, 0x60000020, ".text"
	ByteStreamEmitSymbol(symbols, symbolssize, sectionsymbol)


	integer written = 0
	WriteFile(pdbfilehandle, symbols, symbolssize, written, 0)
	endfileposition = startfileposition + written
}



// TODO - replace with better option
charat : string in, integer index -> string c = substring(in, index, 1) [nogc]



WritePadding : Win32Handle filehandle, integer startpos, integer desiredpos -> integer writtenbytes = 0
{
	writtenbytes = desiredpos - startpos

	if(writtenbytes < 0)
	{
		assert(false)
	}

	buffer empty = writtenbytes
	integer written = 0
	WriteFile(filehandle, empty, writtenbytes, written, 0)
}


