//
// Test bed for PDB emission from Epoch code
//


structure PDBStream :
	simplelist<integer> Blocks,
	integer Length

structure PDBDirectory :
	integer NumStreams,
	PDBStream ref OldMSFDirectory,
	PDBStream ref PDB,
	PDBStream ref TPI,
	PDBStream ref DBI,
	PDBStream ref IPI,
	PDBStream ref Globals,
	PDBStream ref Publics,
	PDBStream ref Symbols,
	PDBStream ref TemporaryHack


structure PDBFileLayout :
	integer BlockSize,
	integer BlockCount,
	PDBStream ref DirectoryHints,
	PDBStream ref DirectoryStream,
	PDBDirectory ref Directory
	

structure PDBOutputStream :
	string            FileName,
	Win32Handle       FileHandle,
	integer           FilePosition,
	PDBFileLayout ref Layout,
	DBISection        DBI

	
structure DBISection :
	integer ModuleSubstreamSize,
	list<DBIModule> Modules


structure DBIModule :
	string SourceFile,
	string ObjectFile,
	integer SymbolSize,
	list<PDBSymbol> Symbols



type Win32Handle : integer


CreateFile :
	string  filename,
	integer access,
	integer sharemode,
	integer attributes,
	integer creation,
	integer flags,
	integer template
 ->
	Win32Handle ret = 0
 [external("Kernel32.dll", "CreateFileW", "stdcall")]
 

CloseHandle : Win32Handle handle -> boolean ret = false [external("Kernel32.dll", "CloseHandle", "stdcall")]


WriteFile :
	Win32Handle handle,
	buffer ref data,
	integer numbytes,
	integer ref written,
	integer ignored2
 ->
	boolean ret = false
 [external("Kernel32.dll", "WriteFile", "stdcall")]
 
WriteFile :
	Win32Handle handle,
	integer ptr,
	integer numbytes,
	integer ref written,
	integer ignored2
 ->
	boolean ret = false
 [external("Kernel32.dll", "WriteFile", "stdcall")]
  
 

CreateFileMapping :
	Win32Handle filehandle,
	integer attributes,
	integer protection,
	integer maxsizehigh,
	integer maxsizelow,
	integer name
 ->
	Win32Handle ret = 0
 [external("Kernel32.dll", "CreateFileMappingW", "stdcall")]
 

GetFileSize :
	Win32Handle handle,
	integer ignored
 ->
	integer size = 0
 [external("Kernel32.dll", "GetFileSize", "stdcall")]
 

MapViewOfFile :
	Win32Handle handle,
	integer access,
	integer offsethigh,
	integer offsetlow,
	integer bytestomap
 ->
	integer ptr = 0
 [external("Kernel32.dll", "MapViewOfFile", "stdcall")]


UnmapViewOfFile : integer ptr -> boolean ret = false [external("Kernel32.dll", "UnmapViewOfFile", "stdcall")]



entrypoint :
{
	integer GENERIC_WRITE = 0x40000000
	integer CREATE_ALWAYS = 2
	
	SymbolSection sectionsymbol = 8, 0x8000, 0x1000, 0x60000020, ".text"
	SymbolProcStart initsymbolps = 0, 0, 0, 65, 0, 0, 0, 8, 0, "init"
	SymbolBlockEnd endsymbolps = 0
	PDBSymbol initsymbol = initsymbolps
	PDBSymbol endsymbol = endsymbolps
	
	list<PDBSymbol> symbollist = sectionsymbol, nothing
	append<PDBSymbol>(symbollist, initsymbol)
	append<PDBSymbol>(symbollist, endsymbol)
	
	DBIModule testmodule = "D:\Test.epoch", "D:\Test.obj", 0, symbollist
	
	ComputeSymbolSize(testmodule)
	
	list<DBIModule> modulelist = testmodule, nothing
	
	integer dbimodinfolen = 64 + length(testmodule.SourceFile) + 1 + length(testmodule.ObjectFile) + 1
	while((dbimodinfolen & 3) != 0)
	{
		++dbimodinfolen
	}

	DBISection dbisection = dbimodinfolen, modulelist

	
	PDBStream directoryhint = simplelist<integer>(3, nothing), 0
	PDBStream directorystream = simplelist<integer>(4, nothing), 76
	
	PDBStream msf = simplelist<integer>(5, nothing), 1					// Placeholder; 0 is invalid but we have nothing to put here
	PDBStream pdb = simplelist<integer>(6, nothing), 196  				// TODO - pull real PDB stream size [was 48]
	PDBStream tpi = simplelist<integer>(7, nothing), 56					// TODO - real TPI stream
	PDBStream dbi = simplelist<integer>(8, nothing), 64	+ dbimodinfolen	// TODO - real DBI stream
	PDBStream ipi = simplelist<integer>(9, nothing), 56					// TODO - real IPI stream (?)
	PDBStream globals = simplelist<integer>(10, nothing), 44 + 516		// TODO - real globals stream
	PDBStream publics = simplelist<integer>(11, nothing), 44 + 516		// TODO - real publics stream
	PDBStream symbols = simplelist<integer>(12, nothing), 26			// TODO - real symbol records size
	
	PDBStream hackstream = simplelist<integer>(13, nothing), testmodule.SymbolSize + 8			// TODO - real stream
	
	PDBDirectory pdbdir = 9, msf, pdb, tpi, dbi, ipi, globals, publics, symbols, hackstream

	
	Win32Handle invalidhandle = -1
	PDBFileLayout layout = 1024, 14, directoryhint, directorystream, pdbdir
	PDBOutputStream stream = "TestSuite.pdb", invalidhandle, 0, layout, dbisection

	stream.FileHandle = CreateFile(stream.FileName, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0)
	if(stream.FileHandle == -1)
	{
		print("Cannot open " ; stream.FileName ; " to emit .PDB!")
		assert(false)
	}
	
	WriteMagic(stream)
	WriteSuperBlock(stream)
	
	WriteBlockMap(stream)
	
	// This is some kind of indirection that points to the actual directory block??
	PadToBeginningOfBlock(stream, layout.DirectoryHints.Blocks.value)
	stream.FilePosition += WriteDirectoryHint(stream.FileHandle, layout.DirectoryStream.Blocks.value)
	
	// Move up to the block for the directory data
	PadToBeginningOfBlock(stream, layout.DirectoryStream.Blocks.value)
	WriteDirectory(stream)
	
	// Move up to the block for the PDB info stream
	PadToBeginningOfBlock(stream, layout.Directory.PDB.Blocks.value)
	stream.FilePosition = WritePDBInfoStream(stream.FileHandle, stream.FilePosition)
	
	// Move up and write the TPI stream
	PadToBeginningOfBlock(stream, layout.Directory.TPI.Blocks.value)
	stream.FilePosition = WriteTPIStream(stream.FileHandle, stream.FilePosition)
	
	// Move up and write the DBI stream
	PadToBeginningOfBlock(stream, layout.Directory.DBI.Blocks.value)
	WriteDBIStream(stream)

	// Move up and write the IPI stream
	PadToBeginningOfBlock(stream, layout.Directory.IPI.Blocks.value)
	stream.FilePosition = WriteIPIStream(stream.FileHandle, stream.FilePosition)

	// Move up and write the globals (DBI) stream
	PadToBeginningOfBlock(stream, layout.Directory.Globals.Blocks.value)
	stream.FilePosition = WriteGlobalsStream(stream.FileHandle, stream.FilePosition)
	
	// Move up and write the publics (DBI) stream
	PadToBeginningOfBlock(stream, layout.Directory.Publics.Blocks.value)
	stream.FilePosition = WritePublicsStream(stream.FileHandle, stream.FilePosition)
	
	// Move up and write the symbol records (DBI) stream
	PadToBeginningOfBlock(stream, layout.Directory.Symbols.Blocks.value)
	stream.FilePosition = WriteSymbolRecordsStream(stream.FileHandle, stream.FilePosition)
	
	// HACK - TODO
	PadToBeginningOfBlock(stream, 13)
	WriteDBIModuleSymbols(stream, stream.DBI.Modules.value)
	
	// Pad to the end of the file
	PadToBeginningOfBlock(stream, layout.BlockCount + 1)

	CloseHandle(stream.FileHandle)
}


WriteBlockMap : PDBOutputStream ref stream
{
	buffer ff = 1
	integer ffsize = 0
	
	ByteStreamEmitByte(ff, ffsize, 0xff)
	
	while(stream.FilePosition < stream.Layout.BlockSize * 3)
	{
		integer written = 0
		WriteFile(stream.FileHandle, ff, ffsize, written, 0)
		stream.FilePosition = stream.FilePosition + 1
	}
}


PadToBeginningOfBlock : PDBOutputStream ref stream, integer blockindex
{
	// TODO - lame compiler bug workaround in the 32-bit compiler
	integer fpos = stream.FilePosition
	fpos += WritePadding(stream.FileHandle, stream.FilePosition, stream.Layout.BlockSize * blockindex)
	stream.FilePosition = fpos
}



WriteDirectoryHint : Win32Handle pdbfilehandle, integer hint -> integer written = 0
{
	buffer hack = 32
	integer hacksize = 0
	
	ByteStreamEmitInteger(hack, hacksize, hint)		// Block index of where the directory actually lives
	
	WriteFile(pdbfilehandle, hack, hacksize, written, 0)
}



WriteMagic : PDBOutputStream ref stream
{
	buffer magic = 64
	integer magicsize = 0
	
	string magicstring = "Microsoft C/C++ MSF 7.00"	// Magic header start
	
	integer count = 0
	while(count < length(magicstring))
	{
		string char = charat(magicstring, count)
		ByteStreamEmitSubstring(magic, magicsize, char, 1)

		++count
	}
	
	ByteStreamEmitByte(magic, magicsize, 13)		// Carriage return
	ByteStreamEmitByte(magic, magicsize, 10)		// Linefeed
	ByteStreamEmitByte(magic, magicsize, 26)		// Magic?
	ByteStreamEmitByte(magic, magicsize, 68)		// 'D'
	ByteStreamEmitByte(magic, magicsize, 83)		// 'S'
	ByteStreamEmitByte(magic, magicsize, 0)			// Null magic
	ByteStreamEmitByte(magic, magicsize, 0)			// Null magic
	ByteStreamEmitByte(magic, magicsize, 0)			// Null magic
	
	WriteFile(stream.FileHandle, magic, magicsize, stream.FilePosition, 0)
}


WriteSuperBlock : PDBOutputStream ref stream
{
	buffer sbheader = 128
	integer headersize = 0
	
	ByteStreamEmitInteger(sbheader, headersize, stream.Layout.BlockSize)
	ByteStreamEmitInteger(sbheader, headersize, 1)			// Free block map index
	ByteStreamEmitInteger(sbheader, headersize, stream.Layout.BlockCount)
	ByteStreamEmitInteger(sbheader, headersize, stream.Layout.DirectoryStream.Length)
	ByteStreamEmitInteger(sbheader, headersize, 0)			// Unknown
	ByteStreamEmitInteger(sbheader, headersize, stream.Layout.DirectoryHints.Blocks.value)
	
	integer written = 0
	WriteFile(stream.FileHandle, sbheader, headersize, written, 0)
	
	integer endfileposition = stream.FilePosition + written
	endfileposition += WritePadding(stream.FileHandle, endfileposition, stream.Layout.BlockSize)
	
	stream.FilePosition = endfileposition
}



WriteDirectory : PDBOutputStream ref stream
{
	buffer directory = 128
	integer directorysize = 0
	
	// Number of streams
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.NumStreams)	

	// Stream sizes
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.OldMSFDirectory.Length)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.PDB.Length)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.TPI.Length)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.DBI.Length)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.IPI.Length)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.Globals.Length)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.Publics.Length)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.Symbols.Length)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.TemporaryHack.Length)

	// Stream blocks
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.OldMSFDirectory.Blocks.value)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.PDB.Blocks.value)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.TPI.Blocks.value)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.DBI.Blocks.value)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.IPI.Blocks.value)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.Globals.Blocks.value)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.Publics.Blocks.value)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.Symbols.Blocks.value)
	ByteStreamEmitInteger(directory, directorysize, stream.Layout.Directory.TemporaryHack.Blocks.value)
	
	integer written = 0
	WriteFile(stream.FileHandle, directory, directorysize, written, 0)
	
	stream.FilePosition = stream.FilePosition + written
}



WritePDBInfoStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	buffer header = 256
	integer headersize = 0
	
	integer version = 20000404
	integer signature = 0 // TODO - timestamp?
	integer age = 1
	
	ByteStreamEmitInteger(header, headersize, version)
	ByteStreamEmitInteger(header, headersize, signature)
	ByteStreamEmitInteger(header, headersize, age)

	// GUID (16 bytes)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)

	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)

	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)

	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)
	ByteStreamEmitByte(header, headersize, 0xf0)


	// String table thingy
	ByteStreamEmitInteger(header, headersize, 80)		// Hack
	ByteStreamEmitInteger(header, headersize, 4096)
	ByteStreamEmitInteger(header, headersize, 4097)
	ByteStreamEmitInteger(header, headersize, 4098)
	ByteStreamEmitInteger(header, headersize, 4099)
	
	
	// DUMB TEMPORARY HACK
	ByteStreamEmitInteger(header, headersize, 0xfe)
	ByteStreamEmitInteger(header, headersize, 0xfd)
	ByteStreamEmitInteger(header, headersize, 0xfc)
	ByteStreamEmitInteger(header, headersize, 0xfb)

	ByteStreamEmitInteger(header, headersize, 0xee)
	ByteStreamEmitInteger(header, headersize, 0xed)
	ByteStreamEmitInteger(header, headersize, 0xec)
	ByteStreamEmitInteger(header, headersize, 0xeb)

	ByteStreamEmitInteger(header, headersize, 0xde)
	ByteStreamEmitInteger(header, headersize, 0xdd)
	ByteStreamEmitInteger(header, headersize, 0xdc)
	ByteStreamEmitInteger(header, headersize, 0xdb)

	ByteStreamEmitInteger(header, headersize, 0xce)
	ByteStreamEmitInteger(header, headersize, 0xcd)
	ByteStreamEmitInteger(header, headersize, 0xcc)
	ByteStreamEmitInteger(header, headersize, 0xcb)

	ByteStreamEmitInteger(header, headersize, 0xbe)
	ByteStreamEmitInteger(header, headersize, 0xbd)
	ByteStreamEmitInteger(header, headersize, 0)		// DE-POISONED: this is an array size of some kind
	ByteStreamEmitInteger(header, headersize, 0)		// same as above

	ByteStreamEmitInteger(header, headersize, 0xae)
	ByteStreamEmitInteger(header, headersize, 0xad)
	ByteStreamEmitInteger(header, headersize, 0xac)
	ByteStreamEmitInteger(header, headersize, 0xab)

	ByteStreamEmitInteger(header, headersize, 0x9e)
	ByteStreamEmitInteger(header, headersize, 0x9d)
	ByteStreamEmitInteger(header, headersize, 0x9c)
	ByteStreamEmitInteger(header, headersize, 0x9b)

	ByteStreamEmitInteger(header, headersize, 0x8e)
	ByteStreamEmitInteger(header, headersize, 0x8d)
	ByteStreamEmitInteger(header, headersize, 0x8c)
	ByteStreamEmitInteger(header, headersize, 0x8b)

	ByteStreamEmitInteger(header, headersize, 0x7e)
	ByteStreamEmitInteger(header, headersize, 0x7d)
	ByteStreamEmitInteger(header, headersize, 0x7c)
	ByteStreamEmitInteger(header, headersize, 0x7b)

	ByteStreamEmitInteger(header, headersize, 0x6e)
	ByteStreamEmitInteger(header, headersize, 0x6d)
	ByteStreamEmitInteger(header, headersize, 0x6c)
	ByteStreamEmitInteger(header, headersize, 0x6b)

	ByteStreamEmitInteger(header, headersize, 0x5e)
	ByteStreamEmitInteger(header, headersize, 0x5d)
	ByteStreamEmitInteger(header, headersize, 0x5c)
	ByteStreamEmitInteger(header, headersize, 0x5b)


	integer written = 0
	WriteFile(pdbfilehandle, header, headersize, written, 0)
	
	endfileposition = startfileposition + written
}



WriteTPIStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	buffer header = 128
	integer headersize = 0
	
	integer version = 20040203

	ByteStreamEmitInteger(header, headersize, version)
	ByteStreamEmitInteger(header, headersize, 56)			// TODO - hardcoded magic size
	ByteStreamEmitInteger(header, headersize, 0)		// Type index begin
	ByteStreamEmitInteger(header, headersize, 0)		// Type index end
	ByteStreamEmitInteger(header, headersize, 0)		// Type record bytes

	ByteStreamEmitInteger16(header, headersize, 0)		// Hash stream index
	ByteStreamEmitInteger16(header, headersize, 0)		// Hash aux stream index
	
	// These values seem fixed?
	ByteStreamEmitInteger(header, headersize, 4)		// Hash key size
	ByteStreamEmitInteger(header, headersize, 262143)	// Number of hash buckets
	
	ByteStreamEmitInteger(header, headersize, 0)		// Hash value buffer offset
	ByteStreamEmitInteger(header, headersize, 0)		// Hash value buffer length
	
	ByteStreamEmitInteger(header, headersize, 0)		// Index offset buffer offset
	ByteStreamEmitInteger(header, headersize, 0)		// Index offset buffer length
	
	ByteStreamEmitInteger(header, headersize, 0)		// Hash adjustment buffer offset
	ByteStreamEmitInteger(header, headersize, 0)		// Hash adjustment buffer length


	integer written = 0
	WriteFile(pdbfilehandle, header, headersize, written, 0)
	
	endfileposition = startfileposition + written	
}



WriteDBIStream : PDBOutputStream ref stream
{
	buffer header = 128
	integer headersize = 0
	
	integer signature = 0xffffffff
	integer version = 19990903
	
	ByteStreamEmitInteger(header, headersize, signature)
	ByteStreamEmitInteger(header, headersize, version)

	ByteStreamEmitInteger(header, headersize, 1)		// age (must match PDB age)
	ByteStreamEmitInteger16(header, headersize, 5)		// stream index of global symbols			// TODO - get this from the PDBDirectory
	ByteStreamEmitInteger16(header, headersize, 0)		// build number
	ByteStreamEmitInteger16(header, headersize, 6)		// stream index of public symbols			// TODO - get this from the PDBDirectory
	ByteStreamEmitInteger16(header, headersize, 0)		// PDB DLL version (MSPDBxxx.DLL)
	ByteStreamEmitInteger16(header, headersize, 7)		// stream index of symbol records			// TODO - get this from the PDBDirectory
	ByteStreamEmitInteger16(header, headersize, 0)		// rebuild number of PDB DLL
	ByteStreamEmitInteger(header, headersize, stream.DBI.ModuleSubstreamSize)
	ByteStreamEmitInteger(header, headersize, 0)		// section contribution substream size
	ByteStreamEmitInteger(header, headersize, 0)		// section map substream size
	ByteStreamEmitInteger(header, headersize, 0)		// file info substream size
	ByteStreamEmitInteger(header, headersize, 0)		// type server map size
	ByteStreamEmitInteger(header, headersize, 0)		// index of MFC type server
	ByteStreamEmitInteger(header, headersize, 0)		// DbgHeader info size
	ByteStreamEmitInteger(header, headersize, 0)		// EC substream size (?)
	ByteStreamEmitInteger16(header, headersize, 0)		// flags
	ByteStreamEmitInteger16(header, headersize, 0x8664)	// machine type (AMD64)
	ByteStreamEmitInteger(header, headersize, 0)		// pad

	integer written = 0
	WriteFile(stream.FileHandle, header, headersize, written, 0)
	stream.FilePosition = stream.FilePosition + written	

	
	EmitDBIModule(stream, stream.DBI.Modules)
}



ComputeSymbolSize : DBIModule ref mod
{
	mod.SymbolSize = 0
	ComputeSymbolSize(mod.Symbols, mod.SymbolSize)
}

ComputeSymbolSize : list<PDBSymbol> ref symlist, integer ref sizecounter
{
	sizecounter += SymbolGetSize(symlist.value) + 2
	
	//while((sizecounter & 3) != 0)
	//{
	//	++sizecounter
	//}
	
	ComputeSymbolSize(symlist.next, sizecounter)
}

ComputeSymbolSize : nothing, integer ref sizecounter


EmitDBIModule : PDBOutputStream ref stream, list<DBIModule> ref modlist
{
	ComputeSymbolSize(modlist.value)


	buffer modinfo = 128
	integer modsize = 0
	
	ByteStreamEmitInteger(modinfo, modsize, 0)			// Unused field?
	
	// Section contribution
	ByteStreamEmitInteger16(modinfo, modsize, 8)		// section index
	ByteStreamEmitInteger16(modinfo, modsize, 0)		// padding
	ByteStreamEmitInteger(modinfo, modsize, 0)			// offset of contribution
	ByteStreamEmitInteger(modinfo, modsize, 65)			// size of contribution		TODO
	ByteStreamEmitInteger(modinfo, modsize, 0x60000020)	// characteristics
	ByteStreamEmitInteger16(modinfo, modsize, 0)		// module index
	ByteStreamEmitInteger16(modinfo, modsize, 0)		// padding
	ByteStreamEmitInteger(modinfo, modsize, 0)			// data crc
	ByteStreamEmitInteger(modinfo, modsize, 0)			// reloc crc
	
	
	ByteStreamEmitInteger16(modinfo, modsize, 0)		// flags		TODO
	ByteStreamEmitInteger16(modinfo, modsize, 8)		// stream number of debug info		TODO
	ByteStreamEmitInteger(modinfo, modsize, modlist.value.SymbolSize + 4)
	ByteStreamEmitInteger(modinfo, modsize, 0)			// bytes of line number info
	ByteStreamEmitInteger(modinfo, modsize, 0)			// bytes of C13 line number info
	
	ByteStreamEmitInteger16(modinfo, modsize, 1)		// num contributing files
	ByteStreamEmitInteger16(modinfo, modsize, 0)		// padding
	
	ByteStreamEmitInteger(modinfo, modsize, 0)			// unused (file name offsets)
	ByteStreamEmitInteger(modinfo, modsize, 0)			// name index for source file name
	ByteStreamEmitInteger(modinfo, modsize, 0)			// name index for path to compiler PDB ??


	integer count = 0
	while(count < length(modlist.value.SourceFile))
	{
		string char = charat(modlist.value.SourceFile, count)
		ByteStreamEmitSubstring(modinfo, modsize, char, 1)

		++count
	}
	
	ByteStreamEmitByte(modinfo, modsize, 0)
	

	count = 0
	while(count < length(modlist.value.ObjectFile))
	{
		string char = charat(modlist.value.ObjectFile, count)
		ByteStreamEmitSubstring(modinfo, modsize, char, 1)

		++count
	}
	
	ByteStreamEmitByte(modinfo, modsize, 0)
	
	while((modsize & 3) != 0)
	{
		ByteStreamEmitByte(modinfo, modsize, 0)
	}
	
	
	integer written = 0
	WriteFile(stream.FileHandle, modinfo, modsize, written, 0)
	stream.FilePosition = stream.FilePosition + written

	EmitDBIModule(stream, modlist.next)
}

EmitDBIModule : PDBOutputStream ref stream, nothing


WriteIPIStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	buffer header = 128
	integer headersize = 0
	
	integer version = 20040203

	ByteStreamEmitInteger(header, headersize, version)
	ByteStreamEmitInteger(header, headersize, 56)			// TODO - hardcoded magic size
	ByteStreamEmitInteger(header, headersize, 0)		// Type index begin
	ByteStreamEmitInteger(header, headersize, 0)		// Type index end
	ByteStreamEmitInteger(header, headersize, 0)		// Type record bytes

	ByteStreamEmitInteger16(header, headersize, 0)		// Hash stream index
	ByteStreamEmitInteger16(header, headersize, 0)		// Hash aux stream index
	
	// These values seem fixed?
	ByteStreamEmitInteger(header, headersize, 4)		// Hash key size
	ByteStreamEmitInteger(header, headersize, 262143)	// Number of hash buckets
	
	ByteStreamEmitInteger(header, headersize, 0)		// Hash value buffer offset
	ByteStreamEmitInteger(header, headersize, 0)		// Hash value buffer length
	
	ByteStreamEmitInteger(header, headersize, 0)		// Index offset buffer offset
	ByteStreamEmitInteger(header, headersize, 0)		// Index offset buffer length
	
	ByteStreamEmitInteger(header, headersize, 0)		// Hash adjustment buffer offset
	ByteStreamEmitInteger(header, headersize, 0)		// Hash adjustment buffer length


	integer written = 0
	WriteFile(pdbfilehandle, header, headersize, written, 0)
	
	endfileposition = startfileposition + written	
}



WriteGlobalsStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	buffer header = 1024
	integer headersize = 0
	
	ByteStreamEmitInteger(header, headersize, 0)		// hash
	ByteStreamEmitInteger(header, headersize, 0)		// address map
	ByteStreamEmitInteger(header, headersize, 0)		// num thunks
	ByteStreamEmitInteger(header, headersize, 0)		// size of thunk
	ByteStreamEmitInteger16(header, headersize, 0)		// section index thunk table
	ByteStreamEmitInteger16(header, headersize, 0)		// padding
	ByteStreamEmitInteger(header, headersize, 0)		// offset of thunk table
	ByteStreamEmitInteger(header, headersize, 0)		// number of sections

	// Hash header
	ByteStreamEmitInteger(header, headersize, 0xffffffff)		// signature
	ByteStreamEmitInteger(header, headersize, 0xeffe0000 + 19990810)		// version
	ByteStreamEmitInteger(header, headersize, 0)		// size
	ByteStreamEmitInteger(header, headersize, 0)		// num buckets
	
	
	// Magic bitmap
	integer count = 0
	while(count < 516)
	{
		ByteStreamEmitByte(header, headersize, 0)
		
		++count
	}
	

	integer written = 0
	WriteFile(pdbfilehandle, header, headersize, written, 0)
	
	endfileposition = startfileposition + written	
}


WritePublicsStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	endfileposition = WriteGlobalsStream(pdbfilehandle, startfileposition)
}


WriteSymbolRecordsStream : Win32Handle pdbfilehandle, integer startfileposition -> integer endfileposition = 0
{
	buffer symbols = 1024
	integer symbolssize = 0


	SymbolSection sectionsymbol = 8, 0x8000, 0x1000, 0x60000020, ".text"
	ByteStreamEmitSymbol(symbols, symbolssize, sectionsymbol)


	integer written = 0
	WriteFile(pdbfilehandle, symbols, symbolssize, written, 0)
	endfileposition = startfileposition + written
}



WriteDBIModuleSymbols : PDBOutputStream ref stream, DBIModule ref module
{
	buffer header = 4
	integer headersize = 0
	
	ByteStreamEmitInteger(header, headersize, 4)
	
	integer written = 0
	WriteFile(stream.FileHandle, header, headersize, written, 0)
	
	stream.FilePosition = stream.FilePosition + written
	
	
	buffer symboldata = module.SymbolSize + 1024
	integer symboldatasize = 0
	ByteStreamEmitSymbolList(symboldata, symboldatasize, module.Symbols)
	
	WriteFile(stream.FileHandle, symboldata, symboldatasize, written, 0)
	stream.FilePosition = stream.FilePosition + written
	
	
	buffer footer = 4
	integer footersize = 0
	
	ByteStreamEmitInteger(footer, footersize, 0)			// Global Refs size
	
	WriteFile(stream.FileHandle, footer, footersize, written, 0)
	stream.FilePosition = stream.FilePosition + written
}


// TODO - replace with better option
charat : string in, integer index -> string c = substring(in, index, 1) [nogc]



WritePadding : Win32Handle filehandle, integer startpos, integer desiredpos -> integer writtenbytes = 0
{
	writtenbytes = desiredpos - startpos

	if(writtenbytes < 0)
	{
		assert(false)
	}

	buffer empty = writtenbytes
	integer written = 0
	WriteFile(filehandle, empty, writtenbytes, written, 0)
}


