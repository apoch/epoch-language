# Code Execution Model #
Epoch code is compiled to a binary bytecode form by the initial compilation pass. When this bytecode is loaded for execution, it is processed through a translation layer which generates LLVM bitcode corresponding to the original program code.

LLVM is then used to JIT this bitcode into native machine code, which is then invoked by the bootstrapping portion of the runtime, and the Epoch program begins execution in the `entrypoint` function.

## Compilation ##
The first stage of preparing a program is compilation. This is performed by the `EpochTools` package at build time. The Epoch compiler emits a stream of custom bytecode, designed for an abstract machine. In the past this bytecode could be interpreted on the fly by a VM layer, but this VM has since been retired for performance and maintenance reasons.

The bytecode stream can either be stored in transient memory (as is the case when `EpochTools` runs a program directly from source code) or embedded into an executable binary.

## Bootstrap Executable Stub ##
When building an executable binary image, the Epoch language infrastructure emits two primary pieces of data; the first is the generated bytecode of the Epoch program in question. The second is a simple platform-specific stub which serves only to load the bytecode and hand it off to the runtime system which then translates the bytecode into machine code and invokes it.

## Bytecode to LLVM Bitcode Translation ##
Once the bytecode stream is loaded into memory, the JIT engine runs a pass over the code and performs a simple conversion into LLVM bitcode form. Each instruction for the abstract machine in the original bytecode corresponds to a relatively small sequence of LLVM bitcode instructions. Entities such as functions, flow control primitives, and so on are handled by the library implementation that registered the associated entities (this is usually the Epoch standard library).

Some operations are optimized slightly by the conversion process. For example, stack push/pop operations are converted to SSA form when possible and into more register-friendly forms in the general case. Any additional logic that is needed to generate the bitcode is performed either on a per-instruction basis by the JIT engine, or a per-entity basis by the library implementation.

The bitcode is then optimized through the LLVM optimization passes and then converted on the fly into machine code. Once the machine code for the entire program has been generated, any global initialization requested by the original program is performed, and then the `entrypoint` function is invoked.